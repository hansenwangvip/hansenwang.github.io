{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1545356072671},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1545356072671},{"_id":"source/.DS_Store","hash":"df15ca84970f8dc01a65e1b70a21b0a5eaf9002d","modified":1545356468839},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1545356072671},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1545356072671},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1545356072671},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1545356072680},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1545356736336},{"_id":"source/_posts/2017-01-27 JavaScript Events 笔记.md","hash":"c8b742fc8e14c06862f7d56911a806a2f9b96ffb","modified":1545638445511},{"_id":"source/_posts/2017-03-06 JavaScript精髓(1).md","hash":"9a33f01077a6e2503851f363e2115d4b1f69d34a","modified":1545637455582},{"_id":"source/_posts/2017-03-07 JavaScript精髓(2).md","hash":"60a5298bcb91649b361cbc8a17dde3f6f4c7a1d4","modified":1545394826780},{"_id":"source/_posts/2017-05-07 JavaScript对象数组排序.md","hash":"13aeb116c7073720dd206ebf3be5e742fb35422d","modified":1545395293133},{"_id":"source/_posts/2017-05-07 JavaScript观察者模式的通用实现.md","hash":"d3c3cb8e16b573a0eb153e35526fbf1eb6b519e4","modified":1545395232016},{"_id":"source/_posts/2017-05-23 深入研究CSRF.md","hash":"15bd6b5ddff11105cd334985ce6dfaebf8b8f4b9","modified":1545394692844},{"_id":"source/_posts/2017-06-06 前端网络原理和优化.md","hash":"a7e6a66b3f7f3d94e4387b276a3d0e627579020c","modified":1545394706544},{"_id":"source/_posts/2017-06-07 Mac安装Sass万能方法.md","hash":"a740b6bf1b9b837d1c024039b4a8aa60cabdee35","modified":1545394834921},{"_id":"source/_posts/2017-07-08 React项目中的高频ES6语法.md","hash":"7620d84792f0ac7faa3d5adff84630036756b5a5","modified":1545394725236},{"_id":"source/_posts/2017-07-22 工作日志.md","hash":"3c77222aa541be2e1e84770b85b8510c01d35372","modified":1545395217130},{"_id":"source/_posts/2017-09-05 第一次翻译MDN文档.md","hash":"22a2db3cec85462626736e23cf9e4a2fe74730f8","modified":1545395078273},{"_id":"source/_posts/2017-10-23 更好用的border-box.md","hash":"d77009236a228c0dcc9720b652fbbdd661a2390d","modified":1545395274590},{"_id":"source/_posts/2017-12-03 随笔-人生哪有那么多太晚，都是懒惰和恐惧的借口罢了.md","hash":"41cefd2e0c7dd83f8a3dc61b6f46852df61b6750","modified":1545395056684},{"_id":"source/_posts/2018-01-28 Array.prototype.sort的高级用法.md","hash":"7261d3b9d19716d3b9f0c99d0e5cbc4cd4a1191e","modified":1545638630237},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1545356072672},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1545356072673},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1545356072672},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1545356072673},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1545356072673},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1545356072673},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1545356072673},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1545356072673},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1545356072674},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1545356072674},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1545356072674},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1545356072674},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1545356072679},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1545356072679},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1545356072679},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1545356072679},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1545356072680},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1545356072679},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1545356072681},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1545356072680},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1545356072675},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1545356072675},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1545356072675},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1545356072675},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1545356072675},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1545356072675},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1545356072676},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1545356072676},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1545356072676},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1545356072676},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1545356072678},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1545356072678},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1545356072678},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1545356072678},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1545356072678},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1545356072678},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1545356072681},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1545356072684},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1545356072690},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1545356072696},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1545356072691},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1545356072691},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1545356072691},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1545356072692},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1545356072692},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1545356072692},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1545356072694},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1545356072695},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1545356072695},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1545356072677},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1545356072677},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1545356072677},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1545356072677},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1545356072677},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1545356072677},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1545356072681},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1545356072682},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1545356072682},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1545356072682},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1545356072682},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1545356072683},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1545356072683},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1545356072683},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1545356072683},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1545356072684},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1545356072684},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1545356072685},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1545356072686},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1545356072688},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1545356072683},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1545356072693},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1545356072693},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1545356072693},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1545356072693},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1545356072694},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1545356072694},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1545356072688},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1545356072687},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1545356072690}],"Category":[{"name":"技术","_id":"cjq21cm770002jts4dk8c45d0"},{"name":"笔记","_id":"cjq21cm7r000ljts4b5b3scvx"},{"name":"日志","_id":"cjq21cm80000zjts4o09cowjy"},{"name":"随笔","_id":"cjq21cm870016jts4n8sdbu81"}],"Data":[],"Page":[],"Post":[{"title":"笔记：JavaScript事件处理","date":"2017-01-26T16:00:00.000Z","update":8,"_content":"\n\n## JavaScript --- 事件处理：\n\n### 笔记摘要\n> 参考书籍：\n> 《Modern JavaScript》(Larry Ullman 著);\n> 《JavaScript高级程序设计》 (Nicholas C Zakas著).\n\n\n\n---\n\n### 一、 事件处理：\n#### 1.嵌入式事件处理器（强烈不建议）:\n```\n\t\t/*比如*/\n        <form action= \"#\" method = \"post\" onsubmit = \"validataForm();\">\n        /*或者*/\n     \t<a href = \"somepage.html\" onclick = \"doSomething();\">Some link</a> \n   \n```\n\n#### 2.传统事件处理方法(不建议)： \n``` JavaScript\n\t\t/* 以下传统方法不建议使用 */\n\t\twindow.onload = init; //易用，可靠，属性名必须全小写。\n\t\t/* 或者 */\n\t\twindow.onload = function(){ //匿名函数方法\n\t\t//Do whatever.\n\t\t}\n```\n> 原因：\n\t\t1. 一次只能指定一个时间处理器；\n\t\t2. 较后的函数会覆盖较前的；\n\t\t\n\t \n``` javascript\ndocument.getElementById('theForm').onsubmit = progress;\ndocument.getElementById('theForm').onsubmit = calculate; // 呃!有问题.\n```\n\n\t\n``` javascript\n\t//缓解方法\n\tdocument.getElementById('theForm').onsubmit = function(){\n\t\tprogress();  //当然你也可以这样解决，但是这样的代码很丑陋。\n\t\tcalculate();\n\t}\n```\n\t \n\n#### 3.W3C事件处理(建议)\n1. 接受三个参数：事件类型，事件发生时调用的函数，表示事件阶段的布尔值。\n``` \n\taddEventListener('load', init , false);  //可以为相同元素添加多个事件监听器；`\n\tremoveEventListener()('load', process , false);\n```\t\n\n2. IE<9的事件处理(事件名称前缀多了\"on\")\n\n\t\t1. attachEvent('onload' , init);\n\t\t2. detachEvent('onload' , init);\n3. 创建一个事件分配器\n\t\n\t``` javascript\n\tfunction addEvent( obj , type , fn){\n\t     if(obj && objEventListener){          //W3c\n\t          obj.addEventListener(type, fn , false);\n\t     }else if(obj && obj.attachEvent){     //IE<9\n\t          obj.attachEvent(\"on\" + type, fn);\n\t     }\n\t} \n\t```\n\t\n#### 4. **范例：创建一个实用程序库**\n\n``` javascript\n    //所有函数都定义在全局对象U中，避免多个新函数污染全局命名空间。\n    \n    //新对象U （Utility的缩写）\n    var U = {\n          //定义$()方法\n          $: function(id){\n               'use strict';\n               if (typeof id == 'string'){\n                    return document.getElementById(id);\n               }\n          },\n\t\t  //定义setText 方法，两个参数：要更新的元素id和消息本身\n          setText: function(id, message){\n          \t'use strict';\n          \tif( (typeof id == 'string') && (typeof message == 'string')){\n          \t\tvar output = this.$(id);\n          \t\tif (!output) {return false};\t//获取id的元素失败\n          \t\tif(output.textContext !== undefined){\n          \t\t\toutput.textContext = message;\n          \t\t}else{\n          \t\t\toutput.innerText = message;\n          \t\t}\n          \t\treturn true;\n          \t}\t//End of main IF.\n          }, \t//End of setText() function.\n          \n          //封装一个‘添加事件监听器’ 函数\n          addEvent: function( obj , type , fn){\n          \t\t'use strict';\n                if(obj && obj.removeEventListener){\n                \tobj.addEventListener(type, fn, false);\n                }else if (obj && obj.detachEvent){\n                \tobj.attachEvent('on' + type , fn);\n                }\n          },   \t//End of addEvent() function\n          \n          //封装一个‘移除事件监听器’函数\n          removeEvent: function( obj , type , fn){\n          \t\t'use strict';\n                if(obj && obj.removeEventListener){\n                \tobj.removeEventListener(type, fn, false);\n                }else if (obj && obj.detachEvent){\n                \tobj.detachEvent('on' + type , fn);\n                }\n          }   \t//End of removeEvent() function\n     };\t//End of U declaration.\n```\n---\n### 二、事件类型\n        \n**事件类型分为4类：**\n - **输入设备**\n - **键盘**\n - **浏览器**\n - **表单** \n\n\n#### 1.输入设备事件\n##### 1. 输入按钮事件：\n\t\t1. click 事件；\n\t\t2. dblclick 事件；\n\t\t3. contextmenu 事件(罕见)；\n##### 2. 输入移动事件：\n\t\t1.  mouseout 鼠标移出;\n\t\t2.  mouseover 鼠标移过;\n\t\t3.  mousemove 鼠标移动（持续监视鼠标，消耗性能）;\n##### 3. 键盘事件：\n\t\t1.   keydown (按下);\n\t\t2.   keyup (释放); \n\t\t3.   keypress (按键，前二者组合);\n##### 4. 浏览器事件：\n\t\t1. load (加载完成);\n\t\t2. unload (卸载);\n\t\t3. resize (改变浏览器窗口大小);\n\t\t4. scroll (滚动事件);\n\t\t5. copy;\n\t\t6. cut;\n\t\t7. paste;  \n##### 5. 表单事件：\n   -- **reset**：表单重置(点击重置html按钮)时触发，用户很少有重置表单的需要；若要使用此事件，可以添加监视：\t \n\t\t\n\t\t\t\t\n\t\t\t```\n\t\t\taddEvent(document.getElementById('theForm'), 'reset' , function(){\n\t\t\t\treturn confirm(\"您确定想要重置表单吗？\");\t\t\n\t\t\t});\n\t\t\t         \n\t\t\t```\n![重置表单提醒](http://img.blog.csdn.net/20161210172136724?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\t\t  \n-- **select**: 文本输入域和文本区域的文本内容被选中时；\n\n-- **change**: 元素值变化时；\n\n-- **focus**: 单击或Tab键到文本输入域时；\n\n-- **blur**: 光标或选择项的移动时；\n\n---\n\n### 三、事件可访问性(Accessibility)\n\n#### 1. 配对事件(Pairing events):\n> 使用同一个函数处理相同元素的类似事件。\n\n#### 2. 可访问性(Accessibility):\n在移动设备和其他非标准浏览器上，对于不使用输入设备的浏览器，mouseover和mouseout事件毫无意义，因为它们永远不会发生。\n例如：\n``` html5\n\t <a href = \"somepage.html\" id = \"link\" > Some Text </a>\n\t <script>\n\t\taddEvent(document.getElementById('link'), 'mouseover',handleLinkMouseOver);\n\t </script>\n```\n> 上述代码中，事件只能通过鼠标触发。\n> 但是还是有缓解方法。\n> 如果浏览器仅由键盘控制，那么它是可以监视**focus**事件的(Tab键)。\n> 因此，**增强可访问性**的事件处理方法是创建两个事件监听器：\n``` html5\n\t <a href = \"somepage.html\" id = \"link\">some Text</a>\n\t <script>\n\t //配对事件\n\t addEvent(document.getElementById('link'), 'mouseover', doSomething);\n\t addEvent(document.getElementById('link'), 'focus', doSomething);\n\t </script>\n```\n\n#### 3.事件和渐进增强\n\n - 渐进增强的真正原则： \n\t > 使用JavaScript( 和CSS )改进**基本功能**，使得用户不管使用何种设备，都不会被抛弃(忽略)。\n\t\n\t- 只有在开发者有意识的**忽略**一些用户时，JavaScript才是有必要的。\n\t- 但是在很多情况下，**JavaScript是没有必要的**：比如表单的提交应该在有无JavaScript的情况下都能进行(在服务端都能验证)。\n\t- 将**渐进增强的思想**应用到事件处理中，向已经有默认事件行为的元素添加事件时必须小心。例如：表单提交时，表单的数据发送给服务器端脚本。为表单添加提交事件，为其添加其他功能，在逻辑上是毫无意义的。\n\n---\n\n### 四、高级事件处理\n\n - 引用事件\n - 事件属性\n - 检查按键\n - 阻止默认事件行为\n - 事件的两个阶段：捕捉和冒泡\n - 委派事件处理 \n\n#### 1.引用事件\n> 当事件处理程序用于多个元素上的相同事件（或者相同元素上的不同事件）时，事件处理程序就必须考虑其灵活性。\n\n``` javascript\n\tfunction someEventHandler(e){  //e就是引用事件，代表发生的事件\n\t\tif(typeof e == \"undefined\"){\n\t\t\te = window.event;      //考虑IE8及更早\n\t\t}\n\t};\n```\n\n#### 2.事件属性\n> 事件对象通过各种属性提供信息，但是不同浏览器支持的属性有所差异。(这里不深究，后续补充。)\n\n#### 3.检查按键\n> 当键盘事件触发时，可以通过事件对象确定按下的具体键。这个问题有点复杂，在这里稍微带过。\n\n示例代码：以一致的方式获得字符：\n\t\n\n```\nvar charCode = e.which || e.keyCode;\t//IE中不支持which\n// 或者更准确的\nvar charCode = (typeof e.which == 'number')?e.which : e.keyCode;\n\n//获得与字符代码相对应的实际字符:\nString.fromCharCode(charcode);\n```\n\n#### 4.阻止事件默认行为\n> 一些与基本浏览器相关的JS事件： 单击链接、提交表单等。在事件处理器存在时，事件发生会调用对应的函数，**在函数运行之后，浏览器仍然继续进行它通常应该进行的事件处理。**\n> 例如：提交表单时，提交事件处理器可能执行客户端验证。**如果发生了错误，应该阻止表单提交到服务器端脚本，让客户有机会改正错误。**\n> 方法：**从事件处理器中返回false**。\n\n```\n// 仅在传统方法注册事件处理器时可靠工作，不建议。\nfunction handleForm(){\n\t//Do whatever.\n\tif(errors){\n\t\treturn false;\n\t}else{\n\t\treturn true;\n\t}\n}\n\n//以下是跨浏览器的兼容方法，调用事件对象的preventDefault();\nif(typeof e == 'undefined') {e = window.event;}\nif(e.preventDefault){\n\te.preventDefault();\n}else {\n\te.returnValue = false;\n}\nreturn false;\t//额外的预防措施。\n\n```\n\n> 使用PreventDefault()或设置returnValue的另一个好处就是：**可以在函数开始时执行，使后续的函数代码仍然运行。**\n#### 5.事件的两个阶段：捕捉和冒泡\n\n##### **示例**：\n\t\n\n``` html5\n\t<div>\n\t\t<h1>This is a title</h1>\n\t\t<p>This is a paragraph.\n\t\t\t<a href = \"#\" id = \"link\">This is a link.</a>\n\t\t</p>\n\t</div>\n\t<script>\n\t\t// U.$()方法与jquery获取DOM节点方法一致，只是在前文定义了一个新对象U.\n\t\taddEvent(U.$('link'), 'mouseover' , doSomething);\n\t</script>\n\t\n```\n\n**在上述代码中，包含关系：a< p< div< html< Document< window。当鼠标悬停在链接之上，mouseover事件实际上经历了几个步骤，在两个不同的阶段到达和离开目标（链接）。\n\n![这里写图片描述](http://img.blog.csdn.net/20161211094137004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n> 注意，事件传播一共有**三个阶段**：1.捕获阶段； 2.调用事件处理程序； 3.冒泡阶段。\n\n1.捕捉阶段：\n\t\n> 当你使用事件捕获时，由外向内，父级元素先触发，子级元素后触发；即div先触发，p后触发。\n\n2.事件处理：\n\n> 调用查找到的事件处理程序；\n\n3.冒泡阶段：\n\n> 事件冒泡\n当你使用事件冒泡时，由内向外，子级元素先触发，父级元素后触发；即p先触发，div后触发。\n\n - W3C模型\n\n> 在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。\n\n程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。\n\n```\nele.addEventListener('click',doSomething2,true)\n```\n\n> true=捕获 false=冒泡\n\n - 传统绑定事件方式\n\n> 在一个支持W3C DOM的浏览器中，像这样一般的绑定事件方式，是采用的事件冒泡方式。\n\n```\nele.onclick = doSomething2\n```\n\n - IE浏览器\n\n> 如上面所说，IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。\n\n```\nele.attachEvent(\"onclick\", doSomething2);\n```\n\n附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。\n\n - 事件的传播是可以阻止的：\n• 在W3C中，使用stopPropagation（）方法\n• 在IE下设置cancelBubble = true；\n\n> 在捕获的过程中`stopPropagation（）;`后，后面的冒泡过程也不会发生了\n\n - 阻止事件的默认行为\n\t - 例如click后的跳转:\n• 在W3C中，使用preventDefault（）方法；\n• 在IE下设置window.event.returnValue = false;\n\n终于写完了，花了一天时间总结了\"事件处理\"，文末部分参考了网友的经验。\n\n九月份看的《JS高级程序设计》，当时云里雾里，后来敲了很多代码半懂不懂，现在写完这篇博客才算明白过来。\n\n在写的时候翻阅《JS权威指南》，里面有更深入的细节，有一部分事件类型已经被HTML5标准化。\n\n后续再补充。^_^","source":"_posts/2017-01-27 JavaScript Events 笔记.md","raw":"---\ntitle: 笔记：JavaScript事件处理\ncategories: 技术\ndate: 2017-01-27\nupdate: 8\ntags: [JavaScript,前端]\n---\n\n\n## JavaScript --- 事件处理：\n\n### 笔记摘要\n> 参考书籍：\n> 《Modern JavaScript》(Larry Ullman 著);\n> 《JavaScript高级程序设计》 (Nicholas C Zakas著).\n\n\n\n---\n\n### 一、 事件处理：\n#### 1.嵌入式事件处理器（强烈不建议）:\n```\n\t\t/*比如*/\n        <form action= \"#\" method = \"post\" onsubmit = \"validataForm();\">\n        /*或者*/\n     \t<a href = \"somepage.html\" onclick = \"doSomething();\">Some link</a> \n   \n```\n\n#### 2.传统事件处理方法(不建议)： \n``` JavaScript\n\t\t/* 以下传统方法不建议使用 */\n\t\twindow.onload = init; //易用，可靠，属性名必须全小写。\n\t\t/* 或者 */\n\t\twindow.onload = function(){ //匿名函数方法\n\t\t//Do whatever.\n\t\t}\n```\n> 原因：\n\t\t1. 一次只能指定一个时间处理器；\n\t\t2. 较后的函数会覆盖较前的；\n\t\t\n\t \n``` javascript\ndocument.getElementById('theForm').onsubmit = progress;\ndocument.getElementById('theForm').onsubmit = calculate; // 呃!有问题.\n```\n\n\t\n``` javascript\n\t//缓解方法\n\tdocument.getElementById('theForm').onsubmit = function(){\n\t\tprogress();  //当然你也可以这样解决，但是这样的代码很丑陋。\n\t\tcalculate();\n\t}\n```\n\t \n\n#### 3.W3C事件处理(建议)\n1. 接受三个参数：事件类型，事件发生时调用的函数，表示事件阶段的布尔值。\n``` \n\taddEventListener('load', init , false);  //可以为相同元素添加多个事件监听器；`\n\tremoveEventListener()('load', process , false);\n```\t\n\n2. IE<9的事件处理(事件名称前缀多了\"on\")\n\n\t\t1. attachEvent('onload' , init);\n\t\t2. detachEvent('onload' , init);\n3. 创建一个事件分配器\n\t\n\t``` javascript\n\tfunction addEvent( obj , type , fn){\n\t     if(obj && objEventListener){          //W3c\n\t          obj.addEventListener(type, fn , false);\n\t     }else if(obj && obj.attachEvent){     //IE<9\n\t          obj.attachEvent(\"on\" + type, fn);\n\t     }\n\t} \n\t```\n\t\n#### 4. **范例：创建一个实用程序库**\n\n``` javascript\n    //所有函数都定义在全局对象U中，避免多个新函数污染全局命名空间。\n    \n    //新对象U （Utility的缩写）\n    var U = {\n          //定义$()方法\n          $: function(id){\n               'use strict';\n               if (typeof id == 'string'){\n                    return document.getElementById(id);\n               }\n          },\n\t\t  //定义setText 方法，两个参数：要更新的元素id和消息本身\n          setText: function(id, message){\n          \t'use strict';\n          \tif( (typeof id == 'string') && (typeof message == 'string')){\n          \t\tvar output = this.$(id);\n          \t\tif (!output) {return false};\t//获取id的元素失败\n          \t\tif(output.textContext !== undefined){\n          \t\t\toutput.textContext = message;\n          \t\t}else{\n          \t\t\toutput.innerText = message;\n          \t\t}\n          \t\treturn true;\n          \t}\t//End of main IF.\n          }, \t//End of setText() function.\n          \n          //封装一个‘添加事件监听器’ 函数\n          addEvent: function( obj , type , fn){\n          \t\t'use strict';\n                if(obj && obj.removeEventListener){\n                \tobj.addEventListener(type, fn, false);\n                }else if (obj && obj.detachEvent){\n                \tobj.attachEvent('on' + type , fn);\n                }\n          },   \t//End of addEvent() function\n          \n          //封装一个‘移除事件监听器’函数\n          removeEvent: function( obj , type , fn){\n          \t\t'use strict';\n                if(obj && obj.removeEventListener){\n                \tobj.removeEventListener(type, fn, false);\n                }else if (obj && obj.detachEvent){\n                \tobj.detachEvent('on' + type , fn);\n                }\n          }   \t//End of removeEvent() function\n     };\t//End of U declaration.\n```\n---\n### 二、事件类型\n        \n**事件类型分为4类：**\n - **输入设备**\n - **键盘**\n - **浏览器**\n - **表单** \n\n\n#### 1.输入设备事件\n##### 1. 输入按钮事件：\n\t\t1. click 事件；\n\t\t2. dblclick 事件；\n\t\t3. contextmenu 事件(罕见)；\n##### 2. 输入移动事件：\n\t\t1.  mouseout 鼠标移出;\n\t\t2.  mouseover 鼠标移过;\n\t\t3.  mousemove 鼠标移动（持续监视鼠标，消耗性能）;\n##### 3. 键盘事件：\n\t\t1.   keydown (按下);\n\t\t2.   keyup (释放); \n\t\t3.   keypress (按键，前二者组合);\n##### 4. 浏览器事件：\n\t\t1. load (加载完成);\n\t\t2. unload (卸载);\n\t\t3. resize (改变浏览器窗口大小);\n\t\t4. scroll (滚动事件);\n\t\t5. copy;\n\t\t6. cut;\n\t\t7. paste;  \n##### 5. 表单事件：\n   -- **reset**：表单重置(点击重置html按钮)时触发，用户很少有重置表单的需要；若要使用此事件，可以添加监视：\t \n\t\t\n\t\t\t\t\n\t\t\t```\n\t\t\taddEvent(document.getElementById('theForm'), 'reset' , function(){\n\t\t\t\treturn confirm(\"您确定想要重置表单吗？\");\t\t\n\t\t\t});\n\t\t\t         \n\t\t\t```\n![重置表单提醒](http://img.blog.csdn.net/20161210172136724?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\t\t  \n-- **select**: 文本输入域和文本区域的文本内容被选中时；\n\n-- **change**: 元素值变化时；\n\n-- **focus**: 单击或Tab键到文本输入域时；\n\n-- **blur**: 光标或选择项的移动时；\n\n---\n\n### 三、事件可访问性(Accessibility)\n\n#### 1. 配对事件(Pairing events):\n> 使用同一个函数处理相同元素的类似事件。\n\n#### 2. 可访问性(Accessibility):\n在移动设备和其他非标准浏览器上，对于不使用输入设备的浏览器，mouseover和mouseout事件毫无意义，因为它们永远不会发生。\n例如：\n``` html5\n\t <a href = \"somepage.html\" id = \"link\" > Some Text </a>\n\t <script>\n\t\taddEvent(document.getElementById('link'), 'mouseover',handleLinkMouseOver);\n\t </script>\n```\n> 上述代码中，事件只能通过鼠标触发。\n> 但是还是有缓解方法。\n> 如果浏览器仅由键盘控制，那么它是可以监视**focus**事件的(Tab键)。\n> 因此，**增强可访问性**的事件处理方法是创建两个事件监听器：\n``` html5\n\t <a href = \"somepage.html\" id = \"link\">some Text</a>\n\t <script>\n\t //配对事件\n\t addEvent(document.getElementById('link'), 'mouseover', doSomething);\n\t addEvent(document.getElementById('link'), 'focus', doSomething);\n\t </script>\n```\n\n#### 3.事件和渐进增强\n\n - 渐进增强的真正原则： \n\t > 使用JavaScript( 和CSS )改进**基本功能**，使得用户不管使用何种设备，都不会被抛弃(忽略)。\n\t\n\t- 只有在开发者有意识的**忽略**一些用户时，JavaScript才是有必要的。\n\t- 但是在很多情况下，**JavaScript是没有必要的**：比如表单的提交应该在有无JavaScript的情况下都能进行(在服务端都能验证)。\n\t- 将**渐进增强的思想**应用到事件处理中，向已经有默认事件行为的元素添加事件时必须小心。例如：表单提交时，表单的数据发送给服务器端脚本。为表单添加提交事件，为其添加其他功能，在逻辑上是毫无意义的。\n\n---\n\n### 四、高级事件处理\n\n - 引用事件\n - 事件属性\n - 检查按键\n - 阻止默认事件行为\n - 事件的两个阶段：捕捉和冒泡\n - 委派事件处理 \n\n#### 1.引用事件\n> 当事件处理程序用于多个元素上的相同事件（或者相同元素上的不同事件）时，事件处理程序就必须考虑其灵活性。\n\n``` javascript\n\tfunction someEventHandler(e){  //e就是引用事件，代表发生的事件\n\t\tif(typeof e == \"undefined\"){\n\t\t\te = window.event;      //考虑IE8及更早\n\t\t}\n\t};\n```\n\n#### 2.事件属性\n> 事件对象通过各种属性提供信息，但是不同浏览器支持的属性有所差异。(这里不深究，后续补充。)\n\n#### 3.检查按键\n> 当键盘事件触发时，可以通过事件对象确定按下的具体键。这个问题有点复杂，在这里稍微带过。\n\n示例代码：以一致的方式获得字符：\n\t\n\n```\nvar charCode = e.which || e.keyCode;\t//IE中不支持which\n// 或者更准确的\nvar charCode = (typeof e.which == 'number')?e.which : e.keyCode;\n\n//获得与字符代码相对应的实际字符:\nString.fromCharCode(charcode);\n```\n\n#### 4.阻止事件默认行为\n> 一些与基本浏览器相关的JS事件： 单击链接、提交表单等。在事件处理器存在时，事件发生会调用对应的函数，**在函数运行之后，浏览器仍然继续进行它通常应该进行的事件处理。**\n> 例如：提交表单时，提交事件处理器可能执行客户端验证。**如果发生了错误，应该阻止表单提交到服务器端脚本，让客户有机会改正错误。**\n> 方法：**从事件处理器中返回false**。\n\n```\n// 仅在传统方法注册事件处理器时可靠工作，不建议。\nfunction handleForm(){\n\t//Do whatever.\n\tif(errors){\n\t\treturn false;\n\t}else{\n\t\treturn true;\n\t}\n}\n\n//以下是跨浏览器的兼容方法，调用事件对象的preventDefault();\nif(typeof e == 'undefined') {e = window.event;}\nif(e.preventDefault){\n\te.preventDefault();\n}else {\n\te.returnValue = false;\n}\nreturn false;\t//额外的预防措施。\n\n```\n\n> 使用PreventDefault()或设置returnValue的另一个好处就是：**可以在函数开始时执行，使后续的函数代码仍然运行。**\n#### 5.事件的两个阶段：捕捉和冒泡\n\n##### **示例**：\n\t\n\n``` html5\n\t<div>\n\t\t<h1>This is a title</h1>\n\t\t<p>This is a paragraph.\n\t\t\t<a href = \"#\" id = \"link\">This is a link.</a>\n\t\t</p>\n\t</div>\n\t<script>\n\t\t// U.$()方法与jquery获取DOM节点方法一致，只是在前文定义了一个新对象U.\n\t\taddEvent(U.$('link'), 'mouseover' , doSomething);\n\t</script>\n\t\n```\n\n**在上述代码中，包含关系：a< p< div< html< Document< window。当鼠标悬停在链接之上，mouseover事件实际上经历了几个步骤，在两个不同的阶段到达和离开目标（链接）。\n\n![这里写图片描述](http://img.blog.csdn.net/20161211094137004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n> 注意，事件传播一共有**三个阶段**：1.捕获阶段； 2.调用事件处理程序； 3.冒泡阶段。\n\n1.捕捉阶段：\n\t\n> 当你使用事件捕获时，由外向内，父级元素先触发，子级元素后触发；即div先触发，p后触发。\n\n2.事件处理：\n\n> 调用查找到的事件处理程序；\n\n3.冒泡阶段：\n\n> 事件冒泡\n当你使用事件冒泡时，由内向外，子级元素先触发，父级元素后触发；即p先触发，div后触发。\n\n - W3C模型\n\n> 在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。\n\n程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。\n\n```\nele.addEventListener('click',doSomething2,true)\n```\n\n> true=捕获 false=冒泡\n\n - 传统绑定事件方式\n\n> 在一个支持W3C DOM的浏览器中，像这样一般的绑定事件方式，是采用的事件冒泡方式。\n\n```\nele.onclick = doSomething2\n```\n\n - IE浏览器\n\n> 如上面所说，IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。\n\n```\nele.attachEvent(\"onclick\", doSomething2);\n```\n\n附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。\n\n - 事件的传播是可以阻止的：\n• 在W3C中，使用stopPropagation（）方法\n• 在IE下设置cancelBubble = true；\n\n> 在捕获的过程中`stopPropagation（）;`后，后面的冒泡过程也不会发生了\n\n - 阻止事件的默认行为\n\t - 例如click后的跳转:\n• 在W3C中，使用preventDefault（）方法；\n• 在IE下设置window.event.returnValue = false;\n\n终于写完了，花了一天时间总结了\"事件处理\"，文末部分参考了网友的经验。\n\n九月份看的《JS高级程序设计》，当时云里雾里，后来敲了很多代码半懂不懂，现在写完这篇博客才算明白过来。\n\n在写的时候翻阅《JS权威指南》，里面有更深入的细节，有一部分事件类型已经被HTML5标准化。\n\n后续再补充。^_^","slug":"2017-01-27 JavaScript Events 笔记","published":1,"updated":"2018-12-24T08:00:45.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm6y0000jts4ihnsrpwz","content":"<h2 id=\"JavaScript-—-事件处理：\"><a href=\"#JavaScript-—-事件处理：\" class=\"headerlink\" title=\"JavaScript — 事件处理：\"></a>JavaScript — 事件处理：</h2><h3 id=\"笔记摘要\"><a href=\"#笔记摘要\" class=\"headerlink\" title=\"笔记摘要\"></a>笔记摘要</h3><blockquote>\n<p>参考书籍：<br>《Modern JavaScript》(Larry Ullman 著);<br>《JavaScript高级程序设计》 (Nicholas C Zakas著).</p>\n</blockquote>\n<hr>\n<h3 id=\"一、-事件处理：\"><a href=\"#一、-事件处理：\" class=\"headerlink\" title=\"一、 事件处理：\"></a>一、 事件处理：</h3><h4 id=\"1-嵌入式事件处理器（强烈不建议）\"><a href=\"#1-嵌入式事件处理器（强烈不建议）\" class=\"headerlink\" title=\"1.嵌入式事件处理器（强烈不建议）:\"></a>1.嵌入式事件处理器（强烈不建议）:</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*比如*/</span><br><span class=\"line\">      &lt;form action= &quot;#&quot; method = &quot;post&quot; onsubmit = &quot;validataForm();&quot;&gt;</span><br><span class=\"line\">      /*或者*/</span><br><span class=\"line\">   \t&lt;a href = &quot;somepage.html&quot; onclick = &quot;doSomething();&quot;&gt;Some link&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-传统事件处理方法-不建议-：\"><a href=\"#2-传统事件处理方法-不建议-：\" class=\"headerlink\" title=\"2.传统事件处理方法(不建议)：\"></a>2.传统事件处理方法(不建议)：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 以下传统方法不建议使用 */</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = init; <span class=\"comment\">//易用，可靠，属性名必须全小写。</span></span><br><span class=\"line\"><span class=\"comment\">/* 或者 */</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//匿名函数方法</span></span><br><span class=\"line\"><span class=\"comment\">//Do whatever.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>原因：</p>\n<pre><code>1. 一次只能指定一个时间处理器；\n2. 较后的函数会覆盖较前的；\n</code></pre></blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'theForm'</span>).onsubmit = progress;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'theForm'</span>).onsubmit = calculate; <span class=\"comment\">// 呃!有问题.</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//缓解方法</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'theForm'</span>).onsubmit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tprogress();  <span class=\"comment\">//当然你也可以这样解决，但是这样的代码很丑陋。</span></span><br><span class=\"line\">\tcalculate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-W3C事件处理-建议\"><a href=\"#3-W3C事件处理-建议\" class=\"headerlink\" title=\"3.W3C事件处理(建议)\"></a>3.W3C事件处理(建议)</h4><ol>\n<li>接受三个参数：事件类型，事件发生时调用的函数，表示事件阶段的布尔值。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\taddEventListener(&apos;load&apos;, init , false);  //可以为相同元素添加多个事件监听器；`</span><br><span class=\"line\">\tremoveEventListener()(&apos;load&apos;, process , false);</span><br><span class=\"line\">```\t</span><br><span class=\"line\"></span><br><span class=\"line\">2. IE&lt;9的事件处理(事件名称前缀多了&quot;on&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t1. attachEvent(&apos;onload&apos; , init);</span><br><span class=\"line\">\t\t2. detachEvent(&apos;onload&apos; , init);</span><br><span class=\"line\">3. 创建一个事件分配器</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t``` javascript</span><br><span class=\"line\">\tfunction addEvent( obj , type , fn)&#123;</span><br><span class=\"line\">\t     if(obj &amp;&amp; objEventListener)&#123;          //W3c</span><br><span class=\"line\">\t          obj.addEventListener(type, fn , false);</span><br><span class=\"line\">\t     &#125;else if(obj &amp;&amp; obj.attachEvent)&#123;     //IE&lt;9</span><br><span class=\"line\">\t          obj.attachEvent(&quot;on&quot; + type, fn);</span><br><span class=\"line\">\t     &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"4-范例：创建一个实用程序库\"><a href=\"#4-范例：创建一个实用程序库\" class=\"headerlink\" title=\"4. 范例：创建一个实用程序库\"></a>4. <strong>范例：创建一个实用程序库</strong></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//所有函数都定义在全局对象U中，避免多个新函数污染全局命名空间。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//新对象U （Utility的缩写）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> U = &#123;</span><br><span class=\"line\">      <span class=\"comment\">//定义$()方法</span></span><br><span class=\"line\">      $: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">           'use strict'</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> id == <span class=\"string\">'string'</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"><span class=\"comment\">//定义setText 方法，两个参数：要更新的元素id和消息本身</span></span><br><span class=\"line\">      setText: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, message</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      \t'use strict'</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>( (<span class=\"keyword\">typeof</span> id == <span class=\"string\">'string'</span>) &amp;&amp; (<span class=\"keyword\">typeof</span> message == <span class=\"string\">'string'</span>))&#123;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">var</span> output = <span class=\"keyword\">this</span>.$(id);</span><br><span class=\"line\">      \t\t<span class=\"keyword\">if</span> (!output) &#123;<span class=\"keyword\">return</span> <span class=\"literal\">false</span>&#125;;\t<span class=\"comment\">//获取id的元素失败</span></span><br><span class=\"line\">      \t\t<span class=\"keyword\">if</span>(output.textContext !== <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">      \t\t\toutput.textContext = message;</span><br><span class=\"line\">      \t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      \t\t\toutput.innerText = message;</span><br><span class=\"line\">      \t\t&#125;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      \t&#125;\t<span class=\"comment\">//End of main IF.</span></span><br><span class=\"line\">      &#125;, \t<span class=\"comment\">//End of setText() function.</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//封装一个‘添加事件监听器’ 函数</span></span><br><span class=\"line\">      addEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> obj , type , fn</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      \t\t'use strict'</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obj &amp;&amp; obj.removeEventListener)&#123;</span><br><span class=\"line\">            \tobj.addEventListener(type, fn, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj &amp;&amp; obj.detachEvent)&#123;</span><br><span class=\"line\">            \tobj.attachEvent(<span class=\"string\">'on'</span> + type , fn);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      &#125;,   \t<span class=\"comment\">//End of addEvent() function</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//封装一个‘移除事件监听器’函数</span></span><br><span class=\"line\">      removeEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> obj , type , fn</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      \t\t'use strict'</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obj &amp;&amp; obj.removeEventListener)&#123;</span><br><span class=\"line\">            \tobj.removeEventListener(type, fn, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj &amp;&amp; obj.detachEvent)&#123;</span><br><span class=\"line\">            \tobj.detachEvent(<span class=\"string\">'on'</span> + type , fn);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      &#125;   \t<span class=\"comment\">//End of removeEvent() function</span></span><br><span class=\"line\"> &#125;;\t<span class=\"comment\">//End of U declaration.</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"二、事件类型\"><a href=\"#二、事件类型\" class=\"headerlink\" title=\"二、事件类型\"></a>二、事件类型</h3><p><strong>事件类型分为4类：</strong></p>\n<ul>\n<li><strong>输入设备</strong></li>\n<li><strong>键盘</strong></li>\n<li><strong>浏览器</strong></li>\n<li><strong>表单</strong> </li>\n</ul>\n<h4 id=\"1-输入设备事件\"><a href=\"#1-输入设备事件\" class=\"headerlink\" title=\"1.输入设备事件\"></a>1.输入设备事件</h4><h5 id=\"1-输入按钮事件：\"><a href=\"#1-输入按钮事件：\" class=\"headerlink\" title=\"1. 输入按钮事件：\"></a>1. 输入按钮事件：</h5><pre><code>1. click 事件；\n2. dblclick 事件；\n3. contextmenu 事件(罕见)；\n</code></pre><h5 id=\"2-输入移动事件：\"><a href=\"#2-输入移动事件：\" class=\"headerlink\" title=\"2. 输入移动事件：\"></a>2. 输入移动事件：</h5><pre><code>1.  mouseout 鼠标移出;\n2.  mouseover 鼠标移过;\n3.  mousemove 鼠标移动（持续监视鼠标，消耗性能）;\n</code></pre><h5 id=\"3-键盘事件：\"><a href=\"#3-键盘事件：\" class=\"headerlink\" title=\"3. 键盘事件：\"></a>3. 键盘事件：</h5><pre><code>1.   keydown (按下);\n2.   keyup (释放); \n3.   keypress (按键，前二者组合);\n</code></pre><h5 id=\"4-浏览器事件：\"><a href=\"#4-浏览器事件：\" class=\"headerlink\" title=\"4. 浏览器事件：\"></a>4. 浏览器事件：</h5><pre><code>1. load (加载完成);\n2. unload (卸载);\n3. resize (改变浏览器窗口大小);\n4. scroll (滚动事件);\n5. copy;\n6. cut;\n7. paste;  \n</code></pre><h5 id=\"5-表单事件：\"><a href=\"#5-表单事件：\" class=\"headerlink\" title=\"5. 表单事件：\"></a>5. 表单事件：</h5><p>   – <strong>reset</strong>：表单重置(点击重置html按钮)时触发，用户很少有重置表单的需要；若要使用此事件，可以添加监视：     </p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document.getElementById(&apos;theForm&apos;), &apos;reset&apos; , function()&#123;</span><br><span class=\"line\">\treturn confirm(&quot;您确定想要重置表单吗？&quot;);\t\t</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</code></pre><p><img src=\"http://img.blog.csdn.net/20161210172136724?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"重置表单提醒\"></p>\n<p>– <strong>select</strong>: 文本输入域和文本区域的文本内容被选中时；</p>\n<p>– <strong>change</strong>: 元素值变化时；</p>\n<p>– <strong>focus</strong>: 单击或Tab键到文本输入域时；</p>\n<p>– <strong>blur</strong>: 光标或选择项的移动时；</p>\n<hr>\n<h3 id=\"三、事件可访问性-Accessibility\"><a href=\"#三、事件可访问性-Accessibility\" class=\"headerlink\" title=\"三、事件可访问性(Accessibility)\"></a>三、事件可访问性(Accessibility)</h3><h4 id=\"1-配对事件-Pairing-events\"><a href=\"#1-配对事件-Pairing-events\" class=\"headerlink\" title=\"1. 配对事件(Pairing events):\"></a>1. 配对事件(Pairing events):</h4><blockquote>\n<p>使用同一个函数处理相同元素的类似事件。</p>\n</blockquote>\n<h4 id=\"2-可访问性-Accessibility\"><a href=\"#2-可访问性-Accessibility\" class=\"headerlink\" title=\"2. 可访问性(Accessibility):\"></a>2. 可访问性(Accessibility):</h4><p>在移动设备和其他非标准浏览器上，对于不使用输入设备的浏览器，mouseover和mouseout事件毫无意义，因为它们永远不会发生。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href = &quot;somepage.html&quot; id = &quot;link&quot; &gt; Some Text &lt;/a&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">addEvent(document.getElementById(&apos;link&apos;), &apos;mouseover&apos;,handleLinkMouseOver);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>上述代码中，事件只能通过鼠标触发。<br>但是还是有缓解方法。<br>如果浏览器仅由键盘控制，那么它是可以监视<strong>focus</strong>事件的(Tab键)。<br>因此，<strong>增强可访问性</strong>的事件处理方法是创建两个事件监听器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href = &quot;somepage.html&quot; id = &quot;link&quot;&gt;some Text&lt;/a&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//配对事件</span><br><span class=\"line\">addEvent(document.getElementById(&apos;link&apos;), &apos;mouseover&apos;, doSomething);</span><br><span class=\"line\">addEvent(document.getElementById(&apos;link&apos;), &apos;focus&apos;, doSomething);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"3-事件和渐进增强\"><a href=\"#3-事件和渐进增强\" class=\"headerlink\" title=\"3.事件和渐进增强\"></a>3.事件和渐进增强</h4><ul>\n<li><p>渐进增强的真正原则： </p>\n<blockquote>\n<p>使用JavaScript( 和CSS )改进<strong>基本功能</strong>，使得用户不管使用何种设备，都不会被抛弃(忽略)。</p>\n</blockquote>\n<ul>\n<li>只有在开发者有意识的<strong>忽略</strong>一些用户时，JavaScript才是有必要的。</li>\n<li>但是在很多情况下，<strong>JavaScript是没有必要的</strong>：比如表单的提交应该在有无JavaScript的情况下都能进行(在服务端都能验证)。</li>\n<li>将<strong>渐进增强的思想</strong>应用到事件处理中，向已经有默认事件行为的元素添加事件时必须小心。例如：表单提交时，表单的数据发送给服务器端脚本。为表单添加提交事件，为其添加其他功能，在逻辑上是毫无意义的。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"四、高级事件处理\"><a href=\"#四、高级事件处理\" class=\"headerlink\" title=\"四、高级事件处理\"></a>四、高级事件处理</h3><ul>\n<li>引用事件</li>\n<li>事件属性</li>\n<li>检查按键</li>\n<li>阻止默认事件行为</li>\n<li>事件的两个阶段：捕捉和冒泡</li>\n<li>委派事件处理 </li>\n</ul>\n<h4 id=\"1-引用事件\"><a href=\"#1-引用事件\" class=\"headerlink\" title=\"1.引用事件\"></a>1.引用事件</h4><blockquote>\n<p>当事件处理程序用于多个元素上的相同事件（或者相同元素上的不同事件）时，事件处理程序就必须考虑其灵活性。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someEventHandler</span>(<span class=\"params\">e</span>)</span>&#123;  <span class=\"comment\">//e就是引用事件，代表发生的事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> e == <span class=\"string\">\"undefined\"</span>)&#123;</span><br><span class=\"line\">\t\te = <span class=\"built_in\">window</span>.event;      <span class=\"comment\">//考虑IE8及更早</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-事件属性\"><a href=\"#2-事件属性\" class=\"headerlink\" title=\"2.事件属性\"></a>2.事件属性</h4><blockquote>\n<p>事件对象通过各种属性提供信息，但是不同浏览器支持的属性有所差异。(这里不深究，后续补充。)</p>\n</blockquote>\n<h4 id=\"3-检查按键\"><a href=\"#3-检查按键\" class=\"headerlink\" title=\"3.检查按键\"></a>3.检查按键</h4><blockquote>\n<p>当键盘事件触发时，可以通过事件对象确定按下的具体键。这个问题有点复杂，在这里稍微带过。</p>\n</blockquote>\n<p>示例代码：以一致的方式获得字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var charCode = e.which || e.keyCode;\t//IE中不支持which</span><br><span class=\"line\">// 或者更准确的</span><br><span class=\"line\">var charCode = (typeof e.which == &apos;number&apos;)?e.which : e.keyCode;</span><br><span class=\"line\"></span><br><span class=\"line\">//获得与字符代码相对应的实际字符:</span><br><span class=\"line\">String.fromCharCode(charcode);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-阻止事件默认行为\"><a href=\"#4-阻止事件默认行为\" class=\"headerlink\" title=\"4.阻止事件默认行为\"></a>4.阻止事件默认行为</h4><blockquote>\n<p>一些与基本浏览器相关的JS事件： 单击链接、提交表单等。在事件处理器存在时，事件发生会调用对应的函数，<strong>在函数运行之后，浏览器仍然继续进行它通常应该进行的事件处理。</strong><br>例如：提交表单时，提交事件处理器可能执行客户端验证。<strong>如果发生了错误，应该阻止表单提交到服务器端脚本，让客户有机会改正错误。</strong><br>方法：<strong>从事件处理器中返回false</strong>。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 仅在传统方法注册事件处理器时可靠工作，不建议。</span><br><span class=\"line\">function handleForm()&#123;</span><br><span class=\"line\">\t//Do whatever.</span><br><span class=\"line\">\tif(errors)&#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//以下是跨浏览器的兼容方法，调用事件对象的preventDefault();</span><br><span class=\"line\">if(typeof e == &apos;undefined&apos;) &#123;e = window.event;&#125;</span><br><span class=\"line\">if(e.preventDefault)&#123;</span><br><span class=\"line\">\te.preventDefault();</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">\te.returnValue = false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return false;\t//额外的预防措施。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用PreventDefault()或设置returnValue的另一个好处就是：<strong>可以在函数开始时执行，使后续的函数代码仍然运行。</strong></p>\n</blockquote>\n<h4 id=\"5-事件的两个阶段：捕捉和冒泡\"><a href=\"#5-事件的两个阶段：捕捉和冒泡\" class=\"headerlink\" title=\"5.事件的两个阶段：捕捉和冒泡\"></a>5.事件的两个阶段：捕捉和冒泡</h4><h5 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a><strong>示例</strong>：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">\t&lt;h1&gt;This is a title&lt;/h1&gt;</span><br><span class=\"line\">\t&lt;p&gt;This is a paragraph.</span><br><span class=\"line\">\t\t&lt;a href = &quot;#&quot; id = &quot;link&quot;&gt;This is a link.&lt;/a&gt;</span><br><span class=\"line\">\t&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t// U.$()方法与jquery获取DOM节点方法一致，只是在前文定义了一个新对象U.</span><br><span class=\"line\">\taddEvent(U.$(&apos;link&apos;), &apos;mouseover&apos; , doSomething);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>**在上述代码中，包含关系：a&lt; p&lt; div&lt; html&lt; Document&lt; window。当鼠标悬停在链接之上，mouseover事件实际上经历了几个步骤，在两个不同的阶段到达和离开目标（链接）。</p>\n<p><img src=\"http://img.blog.csdn.net/20161211094137004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<blockquote>\n<p>注意，事件传播一共有<strong>三个阶段</strong>：1.捕获阶段； 2.调用事件处理程序； 3.冒泡阶段。</p>\n</blockquote>\n<p>1.捕捉阶段：</p>\n<blockquote>\n<p>当你使用事件捕获时，由外向内，父级元素先触发，子级元素后触发；即div先触发，p后触发。</p>\n</blockquote>\n<p>2.事件处理：</p>\n<blockquote>\n<p>调用查找到的事件处理程序；</p>\n</blockquote>\n<p>3.冒泡阶段：</p>\n<blockquote>\n<p>事件冒泡<br>当你使用事件冒泡时，由内向外，子级元素先触发，父级元素后触发；即p先触发，div后触发。</p>\n</blockquote>\n<ul>\n<li>W3C模型</li>\n</ul>\n<blockquote>\n<p>在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。</p>\n</blockquote>\n<p>程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.addEventListener(&apos;click&apos;,doSomething2,true)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>true=捕获 false=冒泡</p>\n</blockquote>\n<ul>\n<li>传统绑定事件方式</li>\n</ul>\n<blockquote>\n<p>在一个支持W3C DOM的浏览器中，像这样一般的绑定事件方式，是采用的事件冒泡方式。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.onclick = doSomething2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>IE浏览器</li>\n</ul>\n<blockquote>\n<p>如上面所说，IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.attachEvent(&quot;onclick&quot;, doSomething2);</span><br></pre></td></tr></table></figure>\n<p>附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。</p>\n<ul>\n<li>事件的传播是可以阻止的：<br>• 在W3C中，使用stopPropagation（）方法<br>• 在IE下设置cancelBubble = true；</li>\n</ul>\n<blockquote>\n<p>在捕获的过程中<code>stopPropagation（）;</code>后，后面的冒泡过程也不会发生了</p>\n</blockquote>\n<ul>\n<li>阻止事件的默认行为<ul>\n<li>例如click后的跳转:<br>• 在W3C中，使用preventDefault（）方法；<br>• 在IE下设置window.event.returnValue = false;</li>\n</ul>\n</li>\n</ul>\n<p>终于写完了，花了一天时间总结了”事件处理”，文末部分参考了网友的经验。</p>\n<p>九月份看的《JS高级程序设计》，当时云里雾里，后来敲了很多代码半懂不懂，现在写完这篇博客才算明白过来。</p>\n<p>在写的时候翻阅《JS权威指南》，里面有更深入的细节，有一部分事件类型已经被HTML5标准化。</p>\n<p>后续再补充。^_^</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JavaScript-—-事件处理：\"><a href=\"#JavaScript-—-事件处理：\" class=\"headerlink\" title=\"JavaScript — 事件处理：\"></a>JavaScript — 事件处理：</h2><h3 id=\"笔记摘要\"><a href=\"#笔记摘要\" class=\"headerlink\" title=\"笔记摘要\"></a>笔记摘要</h3><blockquote>\n<p>参考书籍：<br>《Modern JavaScript》(Larry Ullman 著);<br>《JavaScript高级程序设计》 (Nicholas C Zakas著).</p>\n</blockquote>\n<hr>\n<h3 id=\"一、-事件处理：\"><a href=\"#一、-事件处理：\" class=\"headerlink\" title=\"一、 事件处理：\"></a>一、 事件处理：</h3><h4 id=\"1-嵌入式事件处理器（强烈不建议）\"><a href=\"#1-嵌入式事件处理器（强烈不建议）\" class=\"headerlink\" title=\"1.嵌入式事件处理器（强烈不建议）:\"></a>1.嵌入式事件处理器（强烈不建议）:</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*比如*/</span><br><span class=\"line\">      &lt;form action= &quot;#&quot; method = &quot;post&quot; onsubmit = &quot;validataForm();&quot;&gt;</span><br><span class=\"line\">      /*或者*/</span><br><span class=\"line\">   \t&lt;a href = &quot;somepage.html&quot; onclick = &quot;doSomething();&quot;&gt;Some link&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-传统事件处理方法-不建议-：\"><a href=\"#2-传统事件处理方法-不建议-：\" class=\"headerlink\" title=\"2.传统事件处理方法(不建议)：\"></a>2.传统事件处理方法(不建议)：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 以下传统方法不建议使用 */</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = init; <span class=\"comment\">//易用，可靠，属性名必须全小写。</span></span><br><span class=\"line\"><span class=\"comment\">/* 或者 */</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//匿名函数方法</span></span><br><span class=\"line\"><span class=\"comment\">//Do whatever.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>原因：</p>\n<pre><code>1. 一次只能指定一个时间处理器；\n2. 较后的函数会覆盖较前的；\n</code></pre></blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'theForm'</span>).onsubmit = progress;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'theForm'</span>).onsubmit = calculate; <span class=\"comment\">// 呃!有问题.</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//缓解方法</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'theForm'</span>).onsubmit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tprogress();  <span class=\"comment\">//当然你也可以这样解决，但是这样的代码很丑陋。</span></span><br><span class=\"line\">\tcalculate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-W3C事件处理-建议\"><a href=\"#3-W3C事件处理-建议\" class=\"headerlink\" title=\"3.W3C事件处理(建议)\"></a>3.W3C事件处理(建议)</h4><ol>\n<li>接受三个参数：事件类型，事件发生时调用的函数，表示事件阶段的布尔值。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\taddEventListener(&apos;load&apos;, init , false);  //可以为相同元素添加多个事件监听器；`</span><br><span class=\"line\">\tremoveEventListener()(&apos;load&apos;, process , false);</span><br><span class=\"line\">```\t</span><br><span class=\"line\"></span><br><span class=\"line\">2. IE&lt;9的事件处理(事件名称前缀多了&quot;on&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t1. attachEvent(&apos;onload&apos; , init);</span><br><span class=\"line\">\t\t2. detachEvent(&apos;onload&apos; , init);</span><br><span class=\"line\">3. 创建一个事件分配器</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t``` javascript</span><br><span class=\"line\">\tfunction addEvent( obj , type , fn)&#123;</span><br><span class=\"line\">\t     if(obj &amp;&amp; objEventListener)&#123;          //W3c</span><br><span class=\"line\">\t          obj.addEventListener(type, fn , false);</span><br><span class=\"line\">\t     &#125;else if(obj &amp;&amp; obj.attachEvent)&#123;     //IE&lt;9</span><br><span class=\"line\">\t          obj.attachEvent(&quot;on&quot; + type, fn);</span><br><span class=\"line\">\t     &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"4-范例：创建一个实用程序库\"><a href=\"#4-范例：创建一个实用程序库\" class=\"headerlink\" title=\"4. 范例：创建一个实用程序库\"></a>4. <strong>范例：创建一个实用程序库</strong></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//所有函数都定义在全局对象U中，避免多个新函数污染全局命名空间。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//新对象U （Utility的缩写）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> U = &#123;</span><br><span class=\"line\">      <span class=\"comment\">//定义$()方法</span></span><br><span class=\"line\">      $: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">           'use strict'</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> id == <span class=\"string\">'string'</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"><span class=\"comment\">//定义setText 方法，两个参数：要更新的元素id和消息本身</span></span><br><span class=\"line\">      setText: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, message</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      \t'use strict'</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>( (<span class=\"keyword\">typeof</span> id == <span class=\"string\">'string'</span>) &amp;&amp; (<span class=\"keyword\">typeof</span> message == <span class=\"string\">'string'</span>))&#123;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">var</span> output = <span class=\"keyword\">this</span>.$(id);</span><br><span class=\"line\">      \t\t<span class=\"keyword\">if</span> (!output) &#123;<span class=\"keyword\">return</span> <span class=\"literal\">false</span>&#125;;\t<span class=\"comment\">//获取id的元素失败</span></span><br><span class=\"line\">      \t\t<span class=\"keyword\">if</span>(output.textContext !== <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">      \t\t\toutput.textContext = message;</span><br><span class=\"line\">      \t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      \t\t\toutput.innerText = message;</span><br><span class=\"line\">      \t\t&#125;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      \t&#125;\t<span class=\"comment\">//End of main IF.</span></span><br><span class=\"line\">      &#125;, \t<span class=\"comment\">//End of setText() function.</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//封装一个‘添加事件监听器’ 函数</span></span><br><span class=\"line\">      addEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> obj , type , fn</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      \t\t'use strict'</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obj &amp;&amp; obj.removeEventListener)&#123;</span><br><span class=\"line\">            \tobj.addEventListener(type, fn, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj &amp;&amp; obj.detachEvent)&#123;</span><br><span class=\"line\">            \tobj.attachEvent(<span class=\"string\">'on'</span> + type , fn);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      &#125;,   \t<span class=\"comment\">//End of addEvent() function</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//封装一个‘移除事件监听器’函数</span></span><br><span class=\"line\">      removeEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> obj , type , fn</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      \t\t'use strict'</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obj &amp;&amp; obj.removeEventListener)&#123;</span><br><span class=\"line\">            \tobj.removeEventListener(type, fn, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj &amp;&amp; obj.detachEvent)&#123;</span><br><span class=\"line\">            \tobj.detachEvent(<span class=\"string\">'on'</span> + type , fn);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      &#125;   \t<span class=\"comment\">//End of removeEvent() function</span></span><br><span class=\"line\"> &#125;;\t<span class=\"comment\">//End of U declaration.</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"二、事件类型\"><a href=\"#二、事件类型\" class=\"headerlink\" title=\"二、事件类型\"></a>二、事件类型</h3><p><strong>事件类型分为4类：</strong></p>\n<ul>\n<li><strong>输入设备</strong></li>\n<li><strong>键盘</strong></li>\n<li><strong>浏览器</strong></li>\n<li><strong>表单</strong> </li>\n</ul>\n<h4 id=\"1-输入设备事件\"><a href=\"#1-输入设备事件\" class=\"headerlink\" title=\"1.输入设备事件\"></a>1.输入设备事件</h4><h5 id=\"1-输入按钮事件：\"><a href=\"#1-输入按钮事件：\" class=\"headerlink\" title=\"1. 输入按钮事件：\"></a>1. 输入按钮事件：</h5><pre><code>1. click 事件；\n2. dblclick 事件；\n3. contextmenu 事件(罕见)；\n</code></pre><h5 id=\"2-输入移动事件：\"><a href=\"#2-输入移动事件：\" class=\"headerlink\" title=\"2. 输入移动事件：\"></a>2. 输入移动事件：</h5><pre><code>1.  mouseout 鼠标移出;\n2.  mouseover 鼠标移过;\n3.  mousemove 鼠标移动（持续监视鼠标，消耗性能）;\n</code></pre><h5 id=\"3-键盘事件：\"><a href=\"#3-键盘事件：\" class=\"headerlink\" title=\"3. 键盘事件：\"></a>3. 键盘事件：</h5><pre><code>1.   keydown (按下);\n2.   keyup (释放); \n3.   keypress (按键，前二者组合);\n</code></pre><h5 id=\"4-浏览器事件：\"><a href=\"#4-浏览器事件：\" class=\"headerlink\" title=\"4. 浏览器事件：\"></a>4. 浏览器事件：</h5><pre><code>1. load (加载完成);\n2. unload (卸载);\n3. resize (改变浏览器窗口大小);\n4. scroll (滚动事件);\n5. copy;\n6. cut;\n7. paste;  \n</code></pre><h5 id=\"5-表单事件：\"><a href=\"#5-表单事件：\" class=\"headerlink\" title=\"5. 表单事件：\"></a>5. 表单事件：</h5><p>   – <strong>reset</strong>：表单重置(点击重置html按钮)时触发，用户很少有重置表单的需要；若要使用此事件，可以添加监视：     </p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEvent(document.getElementById(&apos;theForm&apos;), &apos;reset&apos; , function()&#123;</span><br><span class=\"line\">\treturn confirm(&quot;您确定想要重置表单吗？&quot;);\t\t</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</code></pre><p><img src=\"http://img.blog.csdn.net/20161210172136724?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"重置表单提醒\"></p>\n<p>– <strong>select</strong>: 文本输入域和文本区域的文本内容被选中时；</p>\n<p>– <strong>change</strong>: 元素值变化时；</p>\n<p>– <strong>focus</strong>: 单击或Tab键到文本输入域时；</p>\n<p>– <strong>blur</strong>: 光标或选择项的移动时；</p>\n<hr>\n<h3 id=\"三、事件可访问性-Accessibility\"><a href=\"#三、事件可访问性-Accessibility\" class=\"headerlink\" title=\"三、事件可访问性(Accessibility)\"></a>三、事件可访问性(Accessibility)</h3><h4 id=\"1-配对事件-Pairing-events\"><a href=\"#1-配对事件-Pairing-events\" class=\"headerlink\" title=\"1. 配对事件(Pairing events):\"></a>1. 配对事件(Pairing events):</h4><blockquote>\n<p>使用同一个函数处理相同元素的类似事件。</p>\n</blockquote>\n<h4 id=\"2-可访问性-Accessibility\"><a href=\"#2-可访问性-Accessibility\" class=\"headerlink\" title=\"2. 可访问性(Accessibility):\"></a>2. 可访问性(Accessibility):</h4><p>在移动设备和其他非标准浏览器上，对于不使用输入设备的浏览器，mouseover和mouseout事件毫无意义，因为它们永远不会发生。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href = &quot;somepage.html&quot; id = &quot;link&quot; &gt; Some Text &lt;/a&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">addEvent(document.getElementById(&apos;link&apos;), &apos;mouseover&apos;,handleLinkMouseOver);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>上述代码中，事件只能通过鼠标触发。<br>但是还是有缓解方法。<br>如果浏览器仅由键盘控制，那么它是可以监视<strong>focus</strong>事件的(Tab键)。<br>因此，<strong>增强可访问性</strong>的事件处理方法是创建两个事件监听器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href = &quot;somepage.html&quot; id = &quot;link&quot;&gt;some Text&lt;/a&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//配对事件</span><br><span class=\"line\">addEvent(document.getElementById(&apos;link&apos;), &apos;mouseover&apos;, doSomething);</span><br><span class=\"line\">addEvent(document.getElementById(&apos;link&apos;), &apos;focus&apos;, doSomething);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"3-事件和渐进增强\"><a href=\"#3-事件和渐进增强\" class=\"headerlink\" title=\"3.事件和渐进增强\"></a>3.事件和渐进增强</h4><ul>\n<li><p>渐进增强的真正原则： </p>\n<blockquote>\n<p>使用JavaScript( 和CSS )改进<strong>基本功能</strong>，使得用户不管使用何种设备，都不会被抛弃(忽略)。</p>\n</blockquote>\n<ul>\n<li>只有在开发者有意识的<strong>忽略</strong>一些用户时，JavaScript才是有必要的。</li>\n<li>但是在很多情况下，<strong>JavaScript是没有必要的</strong>：比如表单的提交应该在有无JavaScript的情况下都能进行(在服务端都能验证)。</li>\n<li>将<strong>渐进增强的思想</strong>应用到事件处理中，向已经有默认事件行为的元素添加事件时必须小心。例如：表单提交时，表单的数据发送给服务器端脚本。为表单添加提交事件，为其添加其他功能，在逻辑上是毫无意义的。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"四、高级事件处理\"><a href=\"#四、高级事件处理\" class=\"headerlink\" title=\"四、高级事件处理\"></a>四、高级事件处理</h3><ul>\n<li>引用事件</li>\n<li>事件属性</li>\n<li>检查按键</li>\n<li>阻止默认事件行为</li>\n<li>事件的两个阶段：捕捉和冒泡</li>\n<li>委派事件处理 </li>\n</ul>\n<h4 id=\"1-引用事件\"><a href=\"#1-引用事件\" class=\"headerlink\" title=\"1.引用事件\"></a>1.引用事件</h4><blockquote>\n<p>当事件处理程序用于多个元素上的相同事件（或者相同元素上的不同事件）时，事件处理程序就必须考虑其灵活性。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someEventHandler</span>(<span class=\"params\">e</span>)</span>&#123;  <span class=\"comment\">//e就是引用事件，代表发生的事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> e == <span class=\"string\">\"undefined\"</span>)&#123;</span><br><span class=\"line\">\t\te = <span class=\"built_in\">window</span>.event;      <span class=\"comment\">//考虑IE8及更早</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-事件属性\"><a href=\"#2-事件属性\" class=\"headerlink\" title=\"2.事件属性\"></a>2.事件属性</h4><blockquote>\n<p>事件对象通过各种属性提供信息，但是不同浏览器支持的属性有所差异。(这里不深究，后续补充。)</p>\n</blockquote>\n<h4 id=\"3-检查按键\"><a href=\"#3-检查按键\" class=\"headerlink\" title=\"3.检查按键\"></a>3.检查按键</h4><blockquote>\n<p>当键盘事件触发时，可以通过事件对象确定按下的具体键。这个问题有点复杂，在这里稍微带过。</p>\n</blockquote>\n<p>示例代码：以一致的方式获得字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var charCode = e.which || e.keyCode;\t//IE中不支持which</span><br><span class=\"line\">// 或者更准确的</span><br><span class=\"line\">var charCode = (typeof e.which == &apos;number&apos;)?e.which : e.keyCode;</span><br><span class=\"line\"></span><br><span class=\"line\">//获得与字符代码相对应的实际字符:</span><br><span class=\"line\">String.fromCharCode(charcode);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-阻止事件默认行为\"><a href=\"#4-阻止事件默认行为\" class=\"headerlink\" title=\"4.阻止事件默认行为\"></a>4.阻止事件默认行为</h4><blockquote>\n<p>一些与基本浏览器相关的JS事件： 单击链接、提交表单等。在事件处理器存在时，事件发生会调用对应的函数，<strong>在函数运行之后，浏览器仍然继续进行它通常应该进行的事件处理。</strong><br>例如：提交表单时，提交事件处理器可能执行客户端验证。<strong>如果发生了错误，应该阻止表单提交到服务器端脚本，让客户有机会改正错误。</strong><br>方法：<strong>从事件处理器中返回false</strong>。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 仅在传统方法注册事件处理器时可靠工作，不建议。</span><br><span class=\"line\">function handleForm()&#123;</span><br><span class=\"line\">\t//Do whatever.</span><br><span class=\"line\">\tif(errors)&#123;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//以下是跨浏览器的兼容方法，调用事件对象的preventDefault();</span><br><span class=\"line\">if(typeof e == &apos;undefined&apos;) &#123;e = window.event;&#125;</span><br><span class=\"line\">if(e.preventDefault)&#123;</span><br><span class=\"line\">\te.preventDefault();</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">\te.returnValue = false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return false;\t//额外的预防措施。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用PreventDefault()或设置returnValue的另一个好处就是：<strong>可以在函数开始时执行，使后续的函数代码仍然运行。</strong></p>\n</blockquote>\n<h4 id=\"5-事件的两个阶段：捕捉和冒泡\"><a href=\"#5-事件的两个阶段：捕捉和冒泡\" class=\"headerlink\" title=\"5.事件的两个阶段：捕捉和冒泡\"></a>5.事件的两个阶段：捕捉和冒泡</h4><h5 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a><strong>示例</strong>：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">\t&lt;h1&gt;This is a title&lt;/h1&gt;</span><br><span class=\"line\">\t&lt;p&gt;This is a paragraph.</span><br><span class=\"line\">\t\t&lt;a href = &quot;#&quot; id = &quot;link&quot;&gt;This is a link.&lt;/a&gt;</span><br><span class=\"line\">\t&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t// U.$()方法与jquery获取DOM节点方法一致，只是在前文定义了一个新对象U.</span><br><span class=\"line\">\taddEvent(U.$(&apos;link&apos;), &apos;mouseover&apos; , doSomething);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>**在上述代码中，包含关系：a&lt; p&lt; div&lt; html&lt; Document&lt; window。当鼠标悬停在链接之上，mouseover事件实际上经历了几个步骤，在两个不同的阶段到达和离开目标（链接）。</p>\n<p><img src=\"http://img.blog.csdn.net/20161211094137004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<blockquote>\n<p>注意，事件传播一共有<strong>三个阶段</strong>：1.捕获阶段； 2.调用事件处理程序； 3.冒泡阶段。</p>\n</blockquote>\n<p>1.捕捉阶段：</p>\n<blockquote>\n<p>当你使用事件捕获时，由外向内，父级元素先触发，子级元素后触发；即div先触发，p后触发。</p>\n</blockquote>\n<p>2.事件处理：</p>\n<blockquote>\n<p>调用查找到的事件处理程序；</p>\n</blockquote>\n<p>3.冒泡阶段：</p>\n<blockquote>\n<p>事件冒泡<br>当你使用事件冒泡时，由内向外，子级元素先触发，父级元素后触发；即p先触发，div后触发。</p>\n</blockquote>\n<ul>\n<li>W3C模型</li>\n</ul>\n<blockquote>\n<p>在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。</p>\n</blockquote>\n<p>程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.addEventListener(&apos;click&apos;,doSomething2,true)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>true=捕获 false=冒泡</p>\n</blockquote>\n<ul>\n<li>传统绑定事件方式</li>\n</ul>\n<blockquote>\n<p>在一个支持W3C DOM的浏览器中，像这样一般的绑定事件方式，是采用的事件冒泡方式。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.onclick = doSomething2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>IE浏览器</li>\n</ul>\n<blockquote>\n<p>如上面所说，IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.attachEvent(&quot;onclick&quot;, doSomething2);</span><br></pre></td></tr></table></figure>\n<p>附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。</p>\n<ul>\n<li>事件的传播是可以阻止的：<br>• 在W3C中，使用stopPropagation（）方法<br>• 在IE下设置cancelBubble = true；</li>\n</ul>\n<blockquote>\n<p>在捕获的过程中<code>stopPropagation（）;</code>后，后面的冒泡过程也不会发生了</p>\n</blockquote>\n<ul>\n<li>阻止事件的默认行为<ul>\n<li>例如click后的跳转:<br>• 在W3C中，使用preventDefault（）方法；<br>• 在IE下设置window.event.returnValue = false;</li>\n</ul>\n</li>\n</ul>\n<p>终于写完了，花了一天时间总结了”事件处理”，文末部分参考了网友的经验。</p>\n<p>九月份看的《JS高级程序设计》，当时云里雾里，后来敲了很多代码半懂不懂，现在写完这篇博客才算明白过来。</p>\n<p>在写的时候翻阅《JS权威指南》，里面有更深入的细节，有一部分事件类型已经被HTML5标准化。</p>\n<p>后续再补充。^_^</p>\n"},{"title":"JavaScript对象数组排序","date":"2017-05-06T16:00:00.000Z","_content":"# 对象数组排序\n\n\n----------\n\n<!-- more -->\n## 一、按照对象的属性排序\n我要一个函数，传入要对比的key，就能以这个key，把对象数组进行排序。\n```js\n//示例代码\nvar by = function(key) {\n\treturn function(o, p) {\n\t\tvar a, b;\n\t\tif (typeof o === 'object' && typeof p === 'object' && o && p) {\n\t\t\ta = o[key];\n\t\t\tb = p[key];\n\t\t\tif (a === b) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (typeof a === typeof b) {\n\t\t\t\treturn a < b ? -1 : 1;\n\t\t\t}\n\t\t\t//如果a,b所属类型不同，则按类型的英文字符排序，比如'function'排在'object'前面。\n\t\t\treturn typeof a < typeof b ? -1 : 1;\n\t\t} else {\n\t\t\tthrow('error');\n\t\t}\n\t}\n}\n\nvar employees=[]\nemployees[0]={name:\"George\", age:32, retiredate:\"March 12, 2014\"}\nemployees[1]={name:\"Edward\", age:17, retiredate:\"June 2, 2023\"}\nemployees[2]={name:\"Christine\", age:58, retiredate:\"December 20, 2036\"}\nemployees[3]={name:\"Sarah\", age:62, retiredate:\"April 30, 2020\"}\n\nemployees.sort(by('age'));\n//得到根据age属性排序的数组。\n//[{name:\"Edward\", age:17, retiredate:\"June 2, 2023\"},\n//{name:\"George\", age:32, retiredate:\"March 12, 2014\"},\n//{name:\"Christine\", age:58, retiredate:\"December 20, 2036\"},\n//{name:\"Sarah\", age:62, retiredate:\"April 30, 2020\"}]\n\n```\n\n## 二、高级by()函数\n当主要的键值产生一个匹配的时候，另一个compare方法（第二个参数）将被调用以决出高下。\n举个例子，在比较两个对象的age属性时，age的值相等，现在我想要age相等的人，按照别的属性进行排序。于是我想增强`by()` ，现在我这样使用：\n\n```\n//注意外层by函数内有俩个参数，第二个参数就是备用的比较函数。\nemployees.sort(by('age',by('name')));\n```\n\n```\nvar by = function(name,minor){\n    return function(o,p){\n        var a,b;\n        if(o && p && typeof o === 'object' && typeof p ==='object'){\n            a = o[name];\n            b = p[name];\n            if(a === b){\n\t            //如果前后元素相同时，用minor函数比较。\n                return typeof minor === 'function' ? minor(o,p):0;\n            }\n            if(typeof a === typeof b){\n                return a <b ? -1 : 1;\n            }\n            return typeof a < typeof b ? -1 : 1;\n        }else{\n            throw(\"error\");\n        }\n    }\n}\n```\n","source":"_posts/2017-05-07 JavaScript对象数组排序.md","raw":"---\ntitle: JavaScript对象数组排序\ncategories: 技术\ndate: 2017-05-07\ntags: [JavaScript, 算法]\n---\n# 对象数组排序\n\n\n----------\n\n<!-- more -->\n## 一、按照对象的属性排序\n我要一个函数，传入要对比的key，就能以这个key，把对象数组进行排序。\n```js\n//示例代码\nvar by = function(key) {\n\treturn function(o, p) {\n\t\tvar a, b;\n\t\tif (typeof o === 'object' && typeof p === 'object' && o && p) {\n\t\t\ta = o[key];\n\t\t\tb = p[key];\n\t\t\tif (a === b) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (typeof a === typeof b) {\n\t\t\t\treturn a < b ? -1 : 1;\n\t\t\t}\n\t\t\t//如果a,b所属类型不同，则按类型的英文字符排序，比如'function'排在'object'前面。\n\t\t\treturn typeof a < typeof b ? -1 : 1;\n\t\t} else {\n\t\t\tthrow('error');\n\t\t}\n\t}\n}\n\nvar employees=[]\nemployees[0]={name:\"George\", age:32, retiredate:\"March 12, 2014\"}\nemployees[1]={name:\"Edward\", age:17, retiredate:\"June 2, 2023\"}\nemployees[2]={name:\"Christine\", age:58, retiredate:\"December 20, 2036\"}\nemployees[3]={name:\"Sarah\", age:62, retiredate:\"April 30, 2020\"}\n\nemployees.sort(by('age'));\n//得到根据age属性排序的数组。\n//[{name:\"Edward\", age:17, retiredate:\"June 2, 2023\"},\n//{name:\"George\", age:32, retiredate:\"March 12, 2014\"},\n//{name:\"Christine\", age:58, retiredate:\"December 20, 2036\"},\n//{name:\"Sarah\", age:62, retiredate:\"April 30, 2020\"}]\n\n```\n\n## 二、高级by()函数\n当主要的键值产生一个匹配的时候，另一个compare方法（第二个参数）将被调用以决出高下。\n举个例子，在比较两个对象的age属性时，age的值相等，现在我想要age相等的人，按照别的属性进行排序。于是我想增强`by()` ，现在我这样使用：\n\n```\n//注意外层by函数内有俩个参数，第二个参数就是备用的比较函数。\nemployees.sort(by('age',by('name')));\n```\n\n```\nvar by = function(name,minor){\n    return function(o,p){\n        var a,b;\n        if(o && p && typeof o === 'object' && typeof p ==='object'){\n            a = o[name];\n            b = p[name];\n            if(a === b){\n\t            //如果前后元素相同时，用minor函数比较。\n                return typeof minor === 'function' ? minor(o,p):0;\n            }\n            if(typeof a === typeof b){\n                return a <b ? -1 : 1;\n            }\n            return typeof a < typeof b ? -1 : 1;\n        }else{\n            throw(\"error\");\n        }\n    }\n}\n```\n","slug":"2017-05-07 JavaScript对象数组排序","published":1,"updated":"2018-12-21T12:28:13.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm730001jts48jexsktj","content":"<h1 id=\"对象数组排序\"><a href=\"#对象数组排序\" class=\"headerlink\" title=\"对象数组排序\"></a>对象数组排序</h1><hr>\n<a id=\"more\"></a>\n<h2 id=\"一、按照对象的属性排序\"><a href=\"#一、按照对象的属性排序\" class=\"headerlink\" title=\"一、按照对象的属性排序\"></a>一、按照对象的属性排序</h2><p>我要一个函数，传入要对比的key，就能以这个key，把对象数组进行排序。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> by = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o, p</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> a, b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> o === <span class=\"string\">'object'</span> &amp;&amp; <span class=\"keyword\">typeof</span> p === <span class=\"string\">'object'</span> &amp;&amp; o &amp;&amp; p) &#123;</span><br><span class=\"line\">\t\t\ta = o[key];</span><br><span class=\"line\">\t\t\tb = p[key];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a === b) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> a === <span class=\"keyword\">typeof</span> b) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> a &lt; b ? <span class=\"number\">-1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果a,b所属类型不同，则按类型的英文字符排序，比如'function'排在'object'前面。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> a &lt; <span class=\"keyword\">typeof</span> b ? <span class=\"number\">-1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span>(<span class=\"string\">'error'</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> employees=[]</span><br><span class=\"line\">employees[<span class=\"number\">0</span>]=&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"George\"</span>, <span class=\"attr\">age</span>:<span class=\"number\">32</span>, <span class=\"attr\">retiredate</span>:<span class=\"string\">\"March 12, 2014\"</span>&#125;</span><br><span class=\"line\">employees[<span class=\"number\">1</span>]=&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Edward\"</span>, <span class=\"attr\">age</span>:<span class=\"number\">17</span>, <span class=\"attr\">retiredate</span>:<span class=\"string\">\"June 2, 2023\"</span>&#125;</span><br><span class=\"line\">employees[<span class=\"number\">2</span>]=&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Christine\"</span>, <span class=\"attr\">age</span>:<span class=\"number\">58</span>, <span class=\"attr\">retiredate</span>:<span class=\"string\">\"December 20, 2036\"</span>&#125;</span><br><span class=\"line\">employees[<span class=\"number\">3</span>]=&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Sarah\"</span>, <span class=\"attr\">age</span>:<span class=\"number\">62</span>, <span class=\"attr\">retiredate</span>:<span class=\"string\">\"April 30, 2020\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">employees.sort(by(<span class=\"string\">'age'</span>));</span><br><span class=\"line\"><span class=\"comment\">//得到根据age属性排序的数组。</span></span><br><span class=\"line\"><span class=\"comment\">//[&#123;name:\"Edward\", age:17, retiredate:\"June 2, 2023\"&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;name:\"George\", age:32, retiredate:\"March 12, 2014\"&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;name:\"Christine\", age:58, retiredate:\"December 20, 2036\"&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;name:\"Sarah\", age:62, retiredate:\"April 30, 2020\"&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、高级by-函数\"><a href=\"#二、高级by-函数\" class=\"headerlink\" title=\"二、高级by()函数\"></a>二、高级by()函数</h2><p>当主要的键值产生一个匹配的时候，另一个compare方法（第二个参数）将被调用以决出高下。<br>举个例子，在比较两个对象的age属性时，age的值相等，现在我想要age相等的人，按照别的属性进行排序。于是我想增强<code>by()</code> ，现在我这样使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意外层by函数内有俩个参数，第二个参数就是备用的比较函数。</span><br><span class=\"line\">employees.sort(by(&apos;age&apos;,by(&apos;name&apos;)));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var by = function(name,minor)&#123;</span><br><span class=\"line\">    return function(o,p)&#123;</span><br><span class=\"line\">        var a,b;</span><br><span class=\"line\">        if(o &amp;&amp; p &amp;&amp; typeof o === &apos;object&apos; &amp;&amp; typeof p ===&apos;object&apos;)&#123;</span><br><span class=\"line\">            a = o[name];</span><br><span class=\"line\">            b = p[name];</span><br><span class=\"line\">            if(a === b)&#123;</span><br><span class=\"line\">\t            //如果前后元素相同时，用minor函数比较。</span><br><span class=\"line\">                return typeof minor === &apos;function&apos; ? minor(o,p):0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(typeof a === typeof b)&#123;</span><br><span class=\"line\">                return a &lt;b ? -1 : 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return typeof a &lt; typeof b ? -1 : 1;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            throw(&quot;error&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"对象数组排序\"><a href=\"#对象数组排序\" class=\"headerlink\" title=\"对象数组排序\"></a>对象数组排序</h1><hr>","more":"<h2 id=\"一、按照对象的属性排序\"><a href=\"#一、按照对象的属性排序\" class=\"headerlink\" title=\"一、按照对象的属性排序\"></a>一、按照对象的属性排序</h2><p>我要一个函数，传入要对比的key，就能以这个key，把对象数组进行排序。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> by = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o, p</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> a, b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> o === <span class=\"string\">'object'</span> &amp;&amp; <span class=\"keyword\">typeof</span> p === <span class=\"string\">'object'</span> &amp;&amp; o &amp;&amp; p) &#123;</span><br><span class=\"line\">\t\t\ta = o[key];</span><br><span class=\"line\">\t\t\tb = p[key];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a === b) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> a === <span class=\"keyword\">typeof</span> b) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> a &lt; b ? <span class=\"number\">-1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果a,b所属类型不同，则按类型的英文字符排序，比如'function'排在'object'前面。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> a &lt; <span class=\"keyword\">typeof</span> b ? <span class=\"number\">-1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span>(<span class=\"string\">'error'</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> employees=[]</span><br><span class=\"line\">employees[<span class=\"number\">0</span>]=&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"George\"</span>, <span class=\"attr\">age</span>:<span class=\"number\">32</span>, <span class=\"attr\">retiredate</span>:<span class=\"string\">\"March 12, 2014\"</span>&#125;</span><br><span class=\"line\">employees[<span class=\"number\">1</span>]=&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Edward\"</span>, <span class=\"attr\">age</span>:<span class=\"number\">17</span>, <span class=\"attr\">retiredate</span>:<span class=\"string\">\"June 2, 2023\"</span>&#125;</span><br><span class=\"line\">employees[<span class=\"number\">2</span>]=&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Christine\"</span>, <span class=\"attr\">age</span>:<span class=\"number\">58</span>, <span class=\"attr\">retiredate</span>:<span class=\"string\">\"December 20, 2036\"</span>&#125;</span><br><span class=\"line\">employees[<span class=\"number\">3</span>]=&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Sarah\"</span>, <span class=\"attr\">age</span>:<span class=\"number\">62</span>, <span class=\"attr\">retiredate</span>:<span class=\"string\">\"April 30, 2020\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">employees.sort(by(<span class=\"string\">'age'</span>));</span><br><span class=\"line\"><span class=\"comment\">//得到根据age属性排序的数组。</span></span><br><span class=\"line\"><span class=\"comment\">//[&#123;name:\"Edward\", age:17, retiredate:\"June 2, 2023\"&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;name:\"George\", age:32, retiredate:\"March 12, 2014\"&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;name:\"Christine\", age:58, retiredate:\"December 20, 2036\"&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;name:\"Sarah\", age:62, retiredate:\"April 30, 2020\"&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、高级by-函数\"><a href=\"#二、高级by-函数\" class=\"headerlink\" title=\"二、高级by()函数\"></a>二、高级by()函数</h2><p>当主要的键值产生一个匹配的时候，另一个compare方法（第二个参数）将被调用以决出高下。<br>举个例子，在比较两个对象的age属性时，age的值相等，现在我想要age相等的人，按照别的属性进行排序。于是我想增强<code>by()</code> ，现在我这样使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意外层by函数内有俩个参数，第二个参数就是备用的比较函数。</span><br><span class=\"line\">employees.sort(by(&apos;age&apos;,by(&apos;name&apos;)));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var by = function(name,minor)&#123;</span><br><span class=\"line\">    return function(o,p)&#123;</span><br><span class=\"line\">        var a,b;</span><br><span class=\"line\">        if(o &amp;&amp; p &amp;&amp; typeof o === &apos;object&apos; &amp;&amp; typeof p ===&apos;object&apos;)&#123;</span><br><span class=\"line\">            a = o[name];</span><br><span class=\"line\">            b = p[name];</span><br><span class=\"line\">            if(a === b)&#123;</span><br><span class=\"line\">\t            //如果前后元素相同时，用minor函数比较。</span><br><span class=\"line\">                return typeof minor === &apos;function&apos; ? minor(o,p):0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(typeof a === typeof b)&#123;</span><br><span class=\"line\">                return a &lt;b ? -1 : 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return typeof a &lt; typeof b ? -1 : 1;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            throw(&quot;error&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"JavaScript精髓(2)","date":"2017-03-06T16:00:00.000Z","update":"2017-07-10T16:00:00.000Z","_content":"\n这篇博客延续上一篇[JavaScript精髓(1)](#)，继续总结JavaScript语言的核心特性和思想精髓。\n<!--more-->\n\n# 1. JavaScript继承的实现方式\n 1. 构造继承\n 2. 原型继承\n 3. 实例继承\n 4. 拷贝继承\n\n **原型prototype机制或者apply/call方法较简单，建议使用`构造函数与原型混合方式`。**\n \n```js\nfunction Parent(){\n\tthis.name = 'wang';\n}\nfunction Child(){\n\tthis.age = 28;\n}\nChild.prototype = new Parent();\t//通过prototype，继承Parent\t\n\nvar demo = new Child();\nalert(demo.age);\nalert(demo.name);\t//得到继承的属性\n```\n\n\n\n \n# 2. DOM操作——添加、移除、移动、复制、创建和查找节点\n 3. 创建新节点\n 4. createDocumentFragment()\n 5. createElement()\n 6. createTextNode()\n 7. 添加、移除、替换、插入\n 8. appendChild()\n 9. removeChild()\n 10. replaceChild()\n 11. insertBefore()\n 12. 查找\n 13. getElementsByTagName()\n 14. getElementsByName()\n 15. getElementById()\n  \n# 3. Ajax的概念和用法\n 1. AJAX的全称： Asynchronous JavaScript And XML.\n 2. 异步的概念：向服务器发送请求时，不必等待结果，而可以同时做其他事情。\n 3. Ajax用法：\n\t 1. 创建XMLHttpRequest对象，也就是创建一个异步调用对象，\n\t 2. 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL和验证信息，\n\t 3. 设置响应HTTP请求状态变化的函数，\n\t 4. 发送HTTP请求，\n\t 5. 获取异步调用返回的数据，\n\t 6. 使用JavaScript和DOM实现局部刷新 。\n\n  \n# 4. document.write 和 innerHTML的区别\n 1. document.write只能重绘**整个页面**\n 2. innerHTML可以只重绘**页面的一部分**\n\n\n\n# 5. window对象和document对象\n\n - window对象：指的是浏览器打开的窗口\n - document对象：Document对象的一个只读引用，它是window对象的一个属性。\n\n# 6. 通用的事件侦听器函数\n```javascript\n//event工具集，参考来源：github.com/markyun\nmarkyun.Event = {\n\treadyEvent : function(fn){\n\t\tif(fn==null){\n\t\t\tfn = document;\n\t\t}\n\t\tvar oldonload = window.onload;\n\t\tif(typeof window.onload != 'function'){\n\t\t\twindow.onload = fn;\n\t\t}else{\n\t\t\twindow.onload = function(){\n\t\t\t\toldonolad():\n\t\t\t\tfn();\n\t\t\t}\n\t\t}\t\n\t},\n\t//根据能力分别使用DOM 0级 || DOM 2级 || IE方式，来绑定事件\n\t//参数：操作元素，事件名称，事件处理函数\n\taddEvent: function(element, type, handler){\n\t\tif(element.addEventListener){\n\t\t\t//事件类型，需要执行的函数，是否捕捉\n\t\t\telement.addEventListener(type, handler, false);\n\t\t}else if(element.attachEvent){\n\t\t\telement.attachEvent('on' + type, function(){\n\t\t\thandler.call(element);\n\t\t\t});\n\t\t}else{\n\t\t\telement['on' + type ] = handler;\n\t\t}\t\n\t},\n\t\n\t//移除事件\n\tremoveEvent: function(element,type,handler){\n\t\tif(element.removeEventListener){\n\t\t\telement.removeEventListener(type,handler,false);\t\n\t\t}else if(element.detachEvent){\n\t\t\telement.detachEvent('on' + type, handler);\t\t\t\n\t\t}else {\n\t\t\telement['on' + type] = null;\t\n\t\t}\t\n\t}, //End removeEvent\n\t\n\t//阻止事件(主要是事件冒泡， 因为IE不支持事件捕获)\n\tstopPropagation: function(ev){\n\t\tif(ev.stopPropagation){\n\t\t\t\tev.stopPropagation();\n\t\t}else{\n\t\t\tev.cancelBubble = true;\n\t\t}\n\t}, \n\t\n\t//取消事件的默认行为\n\tpreventDefault : function(event){\n\t\tif(event.preventDefault){\n\t\t\tevent.preventDefault();\n\t\t}else{\n\t\t\tevent.returnValue = false;\n\t},\n\t\n\t//获取事件目标\n\tgetTarget: function(event){\n\t\treturn event.target || event.srcElement;\n\t},\n\n\t//获取event对象的引用，取到事件的所有信息，确保随时能使用event；\n\tgetEvent: function(e){\n\t\tvar ev = e || window.event;\n\t\tif(!ev){\n\t\t\tvar c = this.getEvent.caller;\n\t\t\twhile(c){\n\t\t\t\tev = c.arguments[0];\n\t\t\t\tif(ev && Event == ev.constructor){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = c.caller;\n\t\t\t}\t\n\t\t}\n\t\treturn ev;\t\n\t}\n\t\t\n} //End\n```\n","source":"_posts/2017-03-07 JavaScript精髓(2).md","raw":"---\ntitle: JavaScript精髓(2)\ncategories: 技术\ndate: 2017-03-07 \nupdate: 2017-07-11\ntags: JavaScript\n---\n\n这篇博客延续上一篇[JavaScript精髓(1)](#)，继续总结JavaScript语言的核心特性和思想精髓。\n<!--more-->\n\n# 1. JavaScript继承的实现方式\n 1. 构造继承\n 2. 原型继承\n 3. 实例继承\n 4. 拷贝继承\n\n **原型prototype机制或者apply/call方法较简单，建议使用`构造函数与原型混合方式`。**\n \n```js\nfunction Parent(){\n\tthis.name = 'wang';\n}\nfunction Child(){\n\tthis.age = 28;\n}\nChild.prototype = new Parent();\t//通过prototype，继承Parent\t\n\nvar demo = new Child();\nalert(demo.age);\nalert(demo.name);\t//得到继承的属性\n```\n\n\n\n \n# 2. DOM操作——添加、移除、移动、复制、创建和查找节点\n 3. 创建新节点\n 4. createDocumentFragment()\n 5. createElement()\n 6. createTextNode()\n 7. 添加、移除、替换、插入\n 8. appendChild()\n 9. removeChild()\n 10. replaceChild()\n 11. insertBefore()\n 12. 查找\n 13. getElementsByTagName()\n 14. getElementsByName()\n 15. getElementById()\n  \n# 3. Ajax的概念和用法\n 1. AJAX的全称： Asynchronous JavaScript And XML.\n 2. 异步的概念：向服务器发送请求时，不必等待结果，而可以同时做其他事情。\n 3. Ajax用法：\n\t 1. 创建XMLHttpRequest对象，也就是创建一个异步调用对象，\n\t 2. 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL和验证信息，\n\t 3. 设置响应HTTP请求状态变化的函数，\n\t 4. 发送HTTP请求，\n\t 5. 获取异步调用返回的数据，\n\t 6. 使用JavaScript和DOM实现局部刷新 。\n\n  \n# 4. document.write 和 innerHTML的区别\n 1. document.write只能重绘**整个页面**\n 2. innerHTML可以只重绘**页面的一部分**\n\n\n\n# 5. window对象和document对象\n\n - window对象：指的是浏览器打开的窗口\n - document对象：Document对象的一个只读引用，它是window对象的一个属性。\n\n# 6. 通用的事件侦听器函数\n```javascript\n//event工具集，参考来源：github.com/markyun\nmarkyun.Event = {\n\treadyEvent : function(fn){\n\t\tif(fn==null){\n\t\t\tfn = document;\n\t\t}\n\t\tvar oldonload = window.onload;\n\t\tif(typeof window.onload != 'function'){\n\t\t\twindow.onload = fn;\n\t\t}else{\n\t\t\twindow.onload = function(){\n\t\t\t\toldonolad():\n\t\t\t\tfn();\n\t\t\t}\n\t\t}\t\n\t},\n\t//根据能力分别使用DOM 0级 || DOM 2级 || IE方式，来绑定事件\n\t//参数：操作元素，事件名称，事件处理函数\n\taddEvent: function(element, type, handler){\n\t\tif(element.addEventListener){\n\t\t\t//事件类型，需要执行的函数，是否捕捉\n\t\t\telement.addEventListener(type, handler, false);\n\t\t}else if(element.attachEvent){\n\t\t\telement.attachEvent('on' + type, function(){\n\t\t\thandler.call(element);\n\t\t\t});\n\t\t}else{\n\t\t\telement['on' + type ] = handler;\n\t\t}\t\n\t},\n\t\n\t//移除事件\n\tremoveEvent: function(element,type,handler){\n\t\tif(element.removeEventListener){\n\t\t\telement.removeEventListener(type,handler,false);\t\n\t\t}else if(element.detachEvent){\n\t\t\telement.detachEvent('on' + type, handler);\t\t\t\n\t\t}else {\n\t\t\telement['on' + type] = null;\t\n\t\t}\t\n\t}, //End removeEvent\n\t\n\t//阻止事件(主要是事件冒泡， 因为IE不支持事件捕获)\n\tstopPropagation: function(ev){\n\t\tif(ev.stopPropagation){\n\t\t\t\tev.stopPropagation();\n\t\t}else{\n\t\t\tev.cancelBubble = true;\n\t\t}\n\t}, \n\t\n\t//取消事件的默认行为\n\tpreventDefault : function(event){\n\t\tif(event.preventDefault){\n\t\t\tevent.preventDefault();\n\t\t}else{\n\t\t\tevent.returnValue = false;\n\t},\n\t\n\t//获取事件目标\n\tgetTarget: function(event){\n\t\treturn event.target || event.srcElement;\n\t},\n\n\t//获取event对象的引用，取到事件的所有信息，确保随时能使用event；\n\tgetEvent: function(e){\n\t\tvar ev = e || window.event;\n\t\tif(!ev){\n\t\t\tvar c = this.getEvent.caller;\n\t\t\twhile(c){\n\t\t\t\tev = c.arguments[0];\n\t\t\t\tif(ev && Event == ev.constructor){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = c.caller;\n\t\t\t}\t\n\t\t}\n\t\treturn ev;\t\n\t}\n\t\t\n} //End\n```\n","slug":"2017-03-07 JavaScript精髓(2)","published":1,"updated":"2018-12-21T12:20:26.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7a0004jts48rhald30","content":"<p>这篇博客延续上一篇<a href=\"#\">JavaScript精髓(1)</a>，继续总结JavaScript语言的核心特性和思想精髓。<br><a id=\"more\"></a></p>\n<h1 id=\"1-JavaScript继承的实现方式\"><a href=\"#1-JavaScript继承的实现方式\" class=\"headerlink\" title=\"1. JavaScript继承的实现方式\"></a>1. JavaScript继承的实现方式</h1><ol>\n<li>构造继承</li>\n<li>原型继承</li>\n<li>实例继承</li>\n<li><p>拷贝继承</p>\n<p><strong>原型prototype机制或者apply/call方法较简单，建议使用<code>构造函数与原型混合方式</code>。</strong></p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = <span class=\"string\">'wang'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = <span class=\"number\">28</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent();\t<span class=\"comment\">//通过prototype，继承Parent\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> demo = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">alert(demo.age);</span><br><span class=\"line\">alert(demo.name);\t<span class=\"comment\">//得到继承的属性</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"2-DOM操作——添加、移除、移动、复制、创建和查找节点\"><a href=\"#2-DOM操作——添加、移除、移动、复制、创建和查找节点\" class=\"headerlink\" title=\"2. DOM操作——添加、移除、移动、复制、创建和查找节点\"></a>2. DOM操作——添加、移除、移动、复制、创建和查找节点</h1><ol start=\"3\">\n<li>创建新节点</li>\n<li>createDocumentFragment()</li>\n<li>createElement()</li>\n<li>createTextNode()</li>\n<li>添加、移除、替换、插入</li>\n<li>appendChild()</li>\n<li>removeChild()</li>\n<li>replaceChild()</li>\n<li>insertBefore()</li>\n<li>查找</li>\n<li>getElementsByTagName()</li>\n<li>getElementsByName()</li>\n<li>getElementById()</li>\n</ol>\n<h1 id=\"3-Ajax的概念和用法\"><a href=\"#3-Ajax的概念和用法\" class=\"headerlink\" title=\"3. Ajax的概念和用法\"></a>3. Ajax的概念和用法</h1><ol>\n<li>AJAX的全称： Asynchronous JavaScript And XML.</li>\n<li>异步的概念：向服务器发送请求时，不必等待结果，而可以同时做其他事情。</li>\n<li>Ajax用法：<ol>\n<li>创建XMLHttpRequest对象，也就是创建一个异步调用对象，</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL和验证信息，</li>\n<li>设置响应HTTP请求状态变化的函数，</li>\n<li>发送HTTP请求，</li>\n<li>获取异步调用返回的数据，</li>\n<li>使用JavaScript和DOM实现局部刷新 。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"4-document-write-和-innerHTML的区别\"><a href=\"#4-document-write-和-innerHTML的区别\" class=\"headerlink\" title=\"4. document.write 和 innerHTML的区别\"></a>4. document.write 和 innerHTML的区别</h1><ol>\n<li>document.write只能重绘<strong>整个页面</strong></li>\n<li>innerHTML可以只重绘<strong>页面的一部分</strong></li>\n</ol>\n<h1 id=\"5-window对象和document对象\"><a href=\"#5-window对象和document对象\" class=\"headerlink\" title=\"5. window对象和document对象\"></a>5. window对象和document对象</h1><ul>\n<li>window对象：指的是浏览器打开的窗口</li>\n<li>document对象：Document对象的一个只读引用，它是window对象的一个属性。</li>\n</ul>\n<h1 id=\"6-通用的事件侦听器函数\"><a href=\"#6-通用的事件侦听器函数\" class=\"headerlink\" title=\"6. 通用的事件侦听器函数\"></a>6. 通用的事件侦听器函数</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//event工具集，参考来源：github.com/markyun</span></span><br><span class=\"line\">markyun.Event = &#123;</span><br><span class=\"line\">\treadyEvent : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fn==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tfn = <span class=\"built_in\">document</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> oldonload = <span class=\"built_in\">window</span>.onload;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.onload != <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.onload = fn;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t\toldonolad():</span><br><span class=\"line\">\t\t\t\tfn();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"comment\">//根据能力分别使用DOM 0级 || DOM 2级 || IE方式，来绑定事件</span></span><br><span class=\"line\">\t<span class=\"comment\">//参数：操作元素，事件名称，事件处理函数</span></span><br><span class=\"line\">\taddEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, type, handler</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(element.addEventListener)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//事件类型，需要执行的函数，是否捕捉</span></span><br><span class=\"line\">\t\t\telement.addEventListener(type, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(element.attachEvent)&#123;</span><br><span class=\"line\">\t\t\telement.attachEvent(<span class=\"string\">'on'</span> + type, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\thandler.call(element);</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\telement[<span class=\"string\">'on'</span> + type ] = handler;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//移除事件</span></span><br><span class=\"line\">\tremoveEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element,type,handler</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(element.removeEventListener)&#123;</span><br><span class=\"line\">\t\t\telement.removeEventListener(type,handler,<span class=\"literal\">false</span>);\t</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(element.detachEvent)&#123;</span><br><span class=\"line\">\t\t\telement.detachEvent(<span class=\"string\">'on'</span> + type, handler);\t\t\t</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\telement[<span class=\"string\">'on'</span> + type] = <span class=\"literal\">null</span>;\t</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;, <span class=\"comment\">//End removeEvent</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//阻止事件(主要是事件冒泡， 因为IE不支持事件捕获)</span></span><br><span class=\"line\">\tstopPropagation: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ev</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ev.stopPropagation)&#123;</span><br><span class=\"line\">\t\t\t\tev.stopPropagation();</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tev.cancelBubble = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;, </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//取消事件的默认行为</span></span><br><span class=\"line\">\tpreventDefault : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(event.preventDefault)&#123;</span><br><span class=\"line\">\t\t\tevent.preventDefault();</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tevent.returnValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//获取事件目标</span></span><br><span class=\"line\">\tgetTarget: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> event.target || event.srcElement;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></span><br><span class=\"line\">\tgetEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> ev = e || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!ev)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> c = <span class=\"keyword\">this</span>.getEvent.caller;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(c)&#123;</span><br><span class=\"line\">\t\t\t\tev = c.arguments[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ev &amp;&amp; Event == ev.constructor)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tc = c.caller;</span><br><span class=\"line\">\t\t\t&#125;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ev;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&#125; <span class=\"comment\">//End</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>这篇博客延续上一篇<a href=\"#\">JavaScript精髓(1)</a>，继续总结JavaScript语言的核心特性和思想精髓。<br>","more":"</p>\n<h1 id=\"1-JavaScript继承的实现方式\"><a href=\"#1-JavaScript继承的实现方式\" class=\"headerlink\" title=\"1. JavaScript继承的实现方式\"></a>1. JavaScript继承的实现方式</h1><ol>\n<li>构造继承</li>\n<li>原型继承</li>\n<li>实例继承</li>\n<li><p>拷贝继承</p>\n<p><strong>原型prototype机制或者apply/call方法较简单，建议使用<code>构造函数与原型混合方式</code>。</strong></p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = <span class=\"string\">'wang'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = <span class=\"number\">28</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent();\t<span class=\"comment\">//通过prototype，继承Parent\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> demo = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">alert(demo.age);</span><br><span class=\"line\">alert(demo.name);\t<span class=\"comment\">//得到继承的属性</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"2-DOM操作——添加、移除、移动、复制、创建和查找节点\"><a href=\"#2-DOM操作——添加、移除、移动、复制、创建和查找节点\" class=\"headerlink\" title=\"2. DOM操作——添加、移除、移动、复制、创建和查找节点\"></a>2. DOM操作——添加、移除、移动、复制、创建和查找节点</h1><ol start=\"3\">\n<li>创建新节点</li>\n<li>createDocumentFragment()</li>\n<li>createElement()</li>\n<li>createTextNode()</li>\n<li>添加、移除、替换、插入</li>\n<li>appendChild()</li>\n<li>removeChild()</li>\n<li>replaceChild()</li>\n<li>insertBefore()</li>\n<li>查找</li>\n<li>getElementsByTagName()</li>\n<li>getElementsByName()</li>\n<li>getElementById()</li>\n</ol>\n<h1 id=\"3-Ajax的概念和用法\"><a href=\"#3-Ajax的概念和用法\" class=\"headerlink\" title=\"3. Ajax的概念和用法\"></a>3. Ajax的概念和用法</h1><ol>\n<li>AJAX的全称： Asynchronous JavaScript And XML.</li>\n<li>异步的概念：向服务器发送请求时，不必等待结果，而可以同时做其他事情。</li>\n<li>Ajax用法：<ol>\n<li>创建XMLHttpRequest对象，也就是创建一个异步调用对象，</li>\n<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL和验证信息，</li>\n<li>设置响应HTTP请求状态变化的函数，</li>\n<li>发送HTTP请求，</li>\n<li>获取异步调用返回的数据，</li>\n<li>使用JavaScript和DOM实现局部刷新 。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"4-document-write-和-innerHTML的区别\"><a href=\"#4-document-write-和-innerHTML的区别\" class=\"headerlink\" title=\"4. document.write 和 innerHTML的区别\"></a>4. document.write 和 innerHTML的区别</h1><ol>\n<li>document.write只能重绘<strong>整个页面</strong></li>\n<li>innerHTML可以只重绘<strong>页面的一部分</strong></li>\n</ol>\n<h1 id=\"5-window对象和document对象\"><a href=\"#5-window对象和document对象\" class=\"headerlink\" title=\"5. window对象和document对象\"></a>5. window对象和document对象</h1><ul>\n<li>window对象：指的是浏览器打开的窗口</li>\n<li>document对象：Document对象的一个只读引用，它是window对象的一个属性。</li>\n</ul>\n<h1 id=\"6-通用的事件侦听器函数\"><a href=\"#6-通用的事件侦听器函数\" class=\"headerlink\" title=\"6. 通用的事件侦听器函数\"></a>6. 通用的事件侦听器函数</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//event工具集，参考来源：github.com/markyun</span></span><br><span class=\"line\">markyun.Event = &#123;</span><br><span class=\"line\">\treadyEvent : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fn==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tfn = <span class=\"built_in\">document</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> oldonload = <span class=\"built_in\">window</span>.onload;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.onload != <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.onload = fn;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t\toldonolad():</span><br><span class=\"line\">\t\t\t\tfn();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"comment\">//根据能力分别使用DOM 0级 || DOM 2级 || IE方式，来绑定事件</span></span><br><span class=\"line\">\t<span class=\"comment\">//参数：操作元素，事件名称，事件处理函数</span></span><br><span class=\"line\">\taddEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, type, handler</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(element.addEventListener)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//事件类型，需要执行的函数，是否捕捉</span></span><br><span class=\"line\">\t\t\telement.addEventListener(type, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(element.attachEvent)&#123;</span><br><span class=\"line\">\t\t\telement.attachEvent(<span class=\"string\">'on'</span> + type, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\thandler.call(element);</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\telement[<span class=\"string\">'on'</span> + type ] = handler;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//移除事件</span></span><br><span class=\"line\">\tremoveEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element,type,handler</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(element.removeEventListener)&#123;</span><br><span class=\"line\">\t\t\telement.removeEventListener(type,handler,<span class=\"literal\">false</span>);\t</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(element.detachEvent)&#123;</span><br><span class=\"line\">\t\t\telement.detachEvent(<span class=\"string\">'on'</span> + type, handler);\t\t\t</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\telement[<span class=\"string\">'on'</span> + type] = <span class=\"literal\">null</span>;\t</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;, <span class=\"comment\">//End removeEvent</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//阻止事件(主要是事件冒泡， 因为IE不支持事件捕获)</span></span><br><span class=\"line\">\tstopPropagation: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ev</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ev.stopPropagation)&#123;</span><br><span class=\"line\">\t\t\t\tev.stopPropagation();</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tev.cancelBubble = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;, </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//取消事件的默认行为</span></span><br><span class=\"line\">\tpreventDefault : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(event.preventDefault)&#123;</span><br><span class=\"line\">\t\t\tevent.preventDefault();</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tevent.returnValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//获取事件目标</span></span><br><span class=\"line\">\tgetTarget: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> event.target || event.srcElement;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></span><br><span class=\"line\">\tgetEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> ev = e || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!ev)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> c = <span class=\"keyword\">this</span>.getEvent.caller;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(c)&#123;</span><br><span class=\"line\">\t\t\t\tev = c.arguments[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ev &amp;&amp; Event == ev.constructor)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tc = c.caller;</span><br><span class=\"line\">\t\t\t&#125;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ev;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&#125; <span class=\"comment\">//End</span></span><br></pre></td></tr></table></figure>"},{"title":"JavaScript 观察者模式的通用实现","date":"2017-05-06T16:00:00.000Z","_content":"\n这篇文章主要是列举代码，关于一个经典的设计模式——观察者模式，又名发布-订阅模式的通用实现。\n<!--more-->\n\n```js\n//封装观察者模式，放进一个对象中，可复用。\nvar event = {\n\tclientList:[],\n\t//订阅的消息添加进缓存列表\n\tlisten: function(key, fn){\n\t\tif( !this.clientList[key]){\n\t\t\tthis.clientList[key] = [];\n\t\t}\n\t\tthis.clientList[key].push(fn);\n\t},\n\ttrigger: function(){\n\t\tvar key = Array.prototype.shift.call(arguments),\n\t\t\tfns = this.clientList[key];\n\t\tif(!fns || fns.length === 0){\n\t\t\treturn false;\n\t\t}\n\t\tfor(var i = 0, fn; fn = fns[i++];){\n\t\t\tfn.apply(this, arguments);\n\t\t}\n\t}，\n\tremove: function(key, fn){\n\t\tvar fns = ClientList[key];\n\t\tif( !fns ){\n\t\t\treturn false;\n\t\t}\n\t\tif(!fn){\n\t\t\tfns && fns.length = 0;\n\t\t}else{\n\t\t\tfor(var len = fns.length-1; len>=0; len--){\n\t\t\t\tvar _fn = fns[len};\n\t\t\t\tif(_fn === fn){\n\t\t\t\t\tfns.splice(len, 1);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\t\n\t}\n}\n```\n```\n//所有对象都能动态安装 ‘观察者模式’\nvar installEvent = function(obj){\n\tfor (var i in event){\n\t\tobj[i] = event[i];\n\t}\n};\n```\n\n```\n//测试\nvar salesOffices = {};\ninstallEvent(salesOffices);\n\t//订阅\nsalesOffices.listen('squareMeter88', function(price){\n\tconsole.log('88平方米的价格='+price);\n});\nsalesOffices.listen('squareMeter110',function(price){\n\tconsole.log('110平方米的价格='+price);\n});\n\t//发布\nsalesOffices.trigger('squareMeter88',2000000);\t//输出：\"88平方米的价格=2000000\"\nsalesOffices.trigger('squareMeter110',3000000);\t//输出：\"110平方米的价格=3000000\"\t\n\n```\n","source":"_posts/2017-05-07 JavaScript观察者模式的通用实现.md","raw":"---\ntitle: JavaScript 观察者模式的通用实现\ncategories: 技术\ndate: 2017-05-07\ntags: JavaScript\n---\n\n这篇文章主要是列举代码，关于一个经典的设计模式——观察者模式，又名发布-订阅模式的通用实现。\n<!--more-->\n\n```js\n//封装观察者模式，放进一个对象中，可复用。\nvar event = {\n\tclientList:[],\n\t//订阅的消息添加进缓存列表\n\tlisten: function(key, fn){\n\t\tif( !this.clientList[key]){\n\t\t\tthis.clientList[key] = [];\n\t\t}\n\t\tthis.clientList[key].push(fn);\n\t},\n\ttrigger: function(){\n\t\tvar key = Array.prototype.shift.call(arguments),\n\t\t\tfns = this.clientList[key];\n\t\tif(!fns || fns.length === 0){\n\t\t\treturn false;\n\t\t}\n\t\tfor(var i = 0, fn; fn = fns[i++];){\n\t\t\tfn.apply(this, arguments);\n\t\t}\n\t}，\n\tremove: function(key, fn){\n\t\tvar fns = ClientList[key];\n\t\tif( !fns ){\n\t\t\treturn false;\n\t\t}\n\t\tif(!fn){\n\t\t\tfns && fns.length = 0;\n\t\t}else{\n\t\t\tfor(var len = fns.length-1; len>=0; len--){\n\t\t\t\tvar _fn = fns[len};\n\t\t\t\tif(_fn === fn){\n\t\t\t\t\tfns.splice(len, 1);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\t\n\t}\n}\n```\n```\n//所有对象都能动态安装 ‘观察者模式’\nvar installEvent = function(obj){\n\tfor (var i in event){\n\t\tobj[i] = event[i];\n\t}\n};\n```\n\n```\n//测试\nvar salesOffices = {};\ninstallEvent(salesOffices);\n\t//订阅\nsalesOffices.listen('squareMeter88', function(price){\n\tconsole.log('88平方米的价格='+price);\n});\nsalesOffices.listen('squareMeter110',function(price){\n\tconsole.log('110平方米的价格='+price);\n});\n\t//发布\nsalesOffices.trigger('squareMeter88',2000000);\t//输出：\"88平方米的价格=2000000\"\nsalesOffices.trigger('squareMeter110',3000000);\t//输出：\"110平方米的价格=3000000\"\t\n\n```\n","slug":"2017-05-07 JavaScript观察者模式的通用实现","published":1,"updated":"2018-12-21T12:27:12.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7c0005jts4d888hhx9","content":"<p>这篇文章主要是列举代码，关于一个经典的设计模式——观察者模式，又名发布-订阅模式的通用实现。<br><a id=\"more\"></a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//封装观察者模式，放进一个对象中，可复用。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> event = &#123;</span><br><span class=\"line\">\tclientList:[],</span><br><span class=\"line\">\t<span class=\"comment\">//订阅的消息添加进缓存列表</span></span><br><span class=\"line\">\tlisten: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, fn</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( !<span class=\"keyword\">this</span>.clientList[key])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.clientList[key] = [];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.clientList[key].push(fn);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\ttrigger: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> key = <span class=\"built_in\">Array</span>.prototype.shift.call(<span class=\"built_in\">arguments</span>),</span><br><span class=\"line\">\t\t\tfns = <span class=\"keyword\">this</span>.clientList[key];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!fns || fns.length === <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, fn; fn = fns[i++];)&#123;</span><br><span class=\"line\">\t\t\tfn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;，</span><br><span class=\"line\">\tremove: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, fn</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fns = ClientList[key];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( !fns )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!fn)&#123;</span><br><span class=\"line\">\t\t\tfns &amp;&amp; fns.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> len = fns.length<span class=\"number\">-1</span>; len&gt;=<span class=\"number\">0</span>; len--)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> _fn = fns[len&#125;;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(_fn === fn)&#123;</span><br><span class=\"line\">\t\t\t\t\tfns.splice(len, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\t&#125;\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//所有对象都能动态安装 ‘观察者模式’</span><br><span class=\"line\">var installEvent = function(obj)&#123;</span><br><span class=\"line\">\tfor (var i in event)&#123;</span><br><span class=\"line\">\t\tobj[i] = event[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//测试</span><br><span class=\"line\">var salesOffices = &#123;&#125;;</span><br><span class=\"line\">installEvent(salesOffices);</span><br><span class=\"line\">\t//订阅</span><br><span class=\"line\">salesOffices.listen(&apos;squareMeter88&apos;, function(price)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;88平方米的价格=&apos;+price);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">salesOffices.listen(&apos;squareMeter110&apos;,function(price)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;110平方米的价格=&apos;+price);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">\t//发布</span><br><span class=\"line\">salesOffices.trigger(&apos;squareMeter88&apos;,2000000);\t//输出：&quot;88平方米的价格=2000000&quot;</span><br><span class=\"line\">salesOffices.trigger(&apos;squareMeter110&apos;,3000000);\t//输出：&quot;110平方米的价格=3000000&quot;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>这篇文章主要是列举代码，关于一个经典的设计模式——观察者模式，又名发布-订阅模式的通用实现。<br>","more":"</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//封装观察者模式，放进一个对象中，可复用。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> event = &#123;</span><br><span class=\"line\">\tclientList:[],</span><br><span class=\"line\">\t<span class=\"comment\">//订阅的消息添加进缓存列表</span></span><br><span class=\"line\">\tlisten: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, fn</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( !<span class=\"keyword\">this</span>.clientList[key])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.clientList[key] = [];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.clientList[key].push(fn);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\ttrigger: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> key = <span class=\"built_in\">Array</span>.prototype.shift.call(<span class=\"built_in\">arguments</span>),</span><br><span class=\"line\">\t\t\tfns = <span class=\"keyword\">this</span>.clientList[key];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!fns || fns.length === <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, fn; fn = fns[i++];)&#123;</span><br><span class=\"line\">\t\t\tfn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;，</span><br><span class=\"line\">\tremove: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, fn</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fns = ClientList[key];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( !fns )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!fn)&#123;</span><br><span class=\"line\">\t\t\tfns &amp;&amp; fns.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> len = fns.length<span class=\"number\">-1</span>; len&gt;=<span class=\"number\">0</span>; len--)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> _fn = fns[len&#125;;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(_fn === fn)&#123;</span><br><span class=\"line\">\t\t\t\t\tfns.splice(len, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\t&#125;\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//所有对象都能动态安装 ‘观察者模式’</span><br><span class=\"line\">var installEvent = function(obj)&#123;</span><br><span class=\"line\">\tfor (var i in event)&#123;</span><br><span class=\"line\">\t\tobj[i] = event[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//测试</span><br><span class=\"line\">var salesOffices = &#123;&#125;;</span><br><span class=\"line\">installEvent(salesOffices);</span><br><span class=\"line\">\t//订阅</span><br><span class=\"line\">salesOffices.listen(&apos;squareMeter88&apos;, function(price)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;88平方米的价格=&apos;+price);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">salesOffices.listen(&apos;squareMeter110&apos;,function(price)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;110平方米的价格=&apos;+price);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">\t//发布</span><br><span class=\"line\">salesOffices.trigger(&apos;squareMeter88&apos;,2000000);\t//输出：&quot;88平方米的价格=2000000&quot;</span><br><span class=\"line\">salesOffices.trigger(&apos;squareMeter110&apos;,3000000);\t//输出：&quot;110平方米的价格=3000000&quot;</span><br></pre></td></tr></table></figure>"},{"title":"JavaScript精髓(1)","date":"2017-03-05T16:00:00.000Z","update":"2017-07-10T16:00:00.000Z","_content":"\n这篇文章主要总结了JavaScript的基础，包括数据类型，值和易混淆的概念。\n<!--more-->\n\n# 1. JavaScript的基本数据类型\n\n 1. Undefined\n 2. Null\n 3. Number\n 4. Boolean\n 5. String\n 6. Symbol(ES2015新增)\n\n# 2. JavaScript的内置对象\n\n - Object 是JS中所有对象的父对象\n - 数据封装类对象：\n  1. Object\n  2. Array\n  3. Boolean\n  4. Number\n  5. String\n - 其他对象：\n\t 1. Function\n\t 2. Arguments\n\t 3. Math\n\t 4. Date\n\t 5. RegExp\n\t 6. Error \n\n> 参考文档：[文档链接](http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html)\n\n\n\n# 3. JavaScript 中有几种类型的值？\n\n - 栈(Stack)：原始(primitive)数据类型(Undefined, Null , Boolean, Number, String)\n - 堆(Heap)：合成(complex)数据类型(Object, Array, Function)\n\n - 两种类型的区别是： **存储位置不同**\n - 原始数据类型：直接存储在**栈**中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据，所以放入栈中存储；\n - 引用数据类型：存储在堆(Heap)中的对象，占据空间大，大小不固定。如果存储在栈中，则会影响程序的性能。\n > 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后，从堆中获得实体。\n\n - 内存图： \n ![enter image description here](https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966)\n\n\n\n# 4. null和undefined的区别\n\n - null 表示\"没有对象\"，即该处不应该有值，典型用法：\n\n    > 1. 作为函数的参数，表示该函数的参数不是对象。\n    > 2. 作为对象原型链的终点。 \n    \n    ```js\n    Object.getPrototypeOf(Object.prototype)\n    //null\n    ```\n\n - undefined 表示“缺少值”，即此处应该有值，但是没有被赋值，典型用法：\n\n    > 1. 变量被声明了，但是没有赋值，默认等于undefined。\n    > 2. 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n    > 3. 对象没有赋值的属性，该属性默认值为undefined。\n    > 4. 函数没有返回值时，默认返回undefined。\n    ```js\n    var i;\n    i  //undefined\n    \n    function f(x){console.log(x)}\n    f() //undefined\n    \n    var o = new Object();\n    o.p //undefined\n    \n    var x = f();\n    x //undefinde\n    ```\n\n\n```js\n\t//二者的测试\n\ttypeof undefined == \"undefined\" //true\n\ttypeof null == \"object\" //true\n\t\n\tNumber(undefined)   //NaN\n\tNumber(null)  //0\n```\n\n 3. 注意：\n\t 在验证null时，一定要使用 `===`,因为 `==` 无法分辨null和undefined：\n\t \n\t```js\n\t    null == undefined //true\n\t    null === undefined //false\n\t```\n 4. 打个比方： \n  - null\n\t  - Q: 有张三这个人吗？\n\t  - A:  有！\n\t  - Q: 张三有房子吗？\n\t  - A: 没有！\n  - undefined\n\t  - Q: 有张三这个人吗？\n\t  - A: 有！\n\t  - Q: 张三多少岁了？\n\t  - A: 不知道（没有被告诉）\n\n\n\n# 5. JavaScript的this\n\n - this是一个指针\n - this的指向：\n\t 1. 函数直接调用时：this指向函数的直接调用者；\n\t 2. 通过new关键字，this指向new产生的新对象；\n\t 3. 通过call/apply/bind的绑定，this指向绑定对象。\n\t 4. 在JS事件中，this指向触发这个事件的对象，但是在IE中，attachEvent中的this总是指向全局对象Window。\n\n\n\n# 6.JavaScript的作用域链\n全局函数无法查看局部函数的内部细节，但局部函数刻意查看上层函数的细节，直至全局细节。\n\n当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。\n \n\n\n\n\n# 7. JavaScript原型和原型链\n\n - 原型：每个对象都会在其内部初始化一个属性，就是prototype(原型)。换句话说，**所有对象都是以对象为模板创建实例的。**\n\n - 原型链：当我们访问一个对象的属性A时，如果属性A不存在于该对象中，那么我们会去prototype里查找A，而这个prototype又会有自己的prototype，于是就如此查找下去，就形成了一个原型链。这个原型链表示的是一种连带关系。\n\n - 关系：`instance.constructor.prototype = instance.__proto__`\n\n - 特点：JS对象是通过**引用传递**的（对比于值传递），我们创建的每一个新对象实体中，并没有一份属于自己的原型副本。当我们修改了原型，与之相关的对象也会**继承**这些变化。\n - 终点：原型链的顶端，是`Object.prototype`, 它的`__proto__`指向`null`.\n\n# 8.JavaScript的闭包\n\n 1. 概念\n\t闭包是一种手段，一个有权访问另一个函数作用域中变量的函数，记住闭包也是函数。\n\t\n 2. 创建闭包\n  最常见的方式，就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量(相当于一个对外的接口)。\n  \n 3. 作用\n\t利用闭包可以突破作用域链，将函数内部的变量方法传递到外部。\n\t\n 4. 特性\n\t\t 1. 函数内再嵌套函数\n\t\t 2. 内部函数可以引用外层的参数和变量\n\t\t 3. 参数和变量不会被垃圾回收机制回收\n\n# 9. new操作符到底干了什么？\n 1. 创建一个空对象，将this指针指向该对象，同时继承该函数的原型。\n 2. 属性和方法被添加到this指向的对象中。\n 3. 新创建的对象由this所应用，并且最后隐式的返回this 。\n \n ```js\n var obj = {};\n obj.__proto__ = Base.prototype;\n Base.call(obj);\n ```\n\n\n# 10. JavaScript开发的基本规范\n\n 1. 不要在同一行声明多个变量；\n 2. 请使用 ===/!==来比较布尔值或者数值；\n 3. 使用对象字面量替代 new Array这种形式；\n 4. 不要使用全局函数；\n 5. Switch语句必须带有default分支；\n 6. 函数应该有返回值；\n 7. For循环必须使用大括号；\n 8. if语句必须使用大括号；\n 9. for-in循环中的变量应该使用let 关键字明确限定作用域，避免命名空间污染。\n\n\n----------\nTo be continue。","source":"_posts/2017-03-06 JavaScript精髓(1).md","raw":"---\ntitle: JavaScript精髓(1)\ncategories: 技术\ndate: 2017-03-06 \nupdate: 2017-07-11\ntags: JavaScript\n---\n\n这篇文章主要总结了JavaScript的基础，包括数据类型，值和易混淆的概念。\n<!--more-->\n\n# 1. JavaScript的基本数据类型\n\n 1. Undefined\n 2. Null\n 3. Number\n 4. Boolean\n 5. String\n 6. Symbol(ES2015新增)\n\n# 2. JavaScript的内置对象\n\n - Object 是JS中所有对象的父对象\n - 数据封装类对象：\n  1. Object\n  2. Array\n  3. Boolean\n  4. Number\n  5. String\n - 其他对象：\n\t 1. Function\n\t 2. Arguments\n\t 3. Math\n\t 4. Date\n\t 5. RegExp\n\t 6. Error \n\n> 参考文档：[文档链接](http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html)\n\n\n\n# 3. JavaScript 中有几种类型的值？\n\n - 栈(Stack)：原始(primitive)数据类型(Undefined, Null , Boolean, Number, String)\n - 堆(Heap)：合成(complex)数据类型(Object, Array, Function)\n\n - 两种类型的区别是： **存储位置不同**\n - 原始数据类型：直接存储在**栈**中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据，所以放入栈中存储；\n - 引用数据类型：存储在堆(Heap)中的对象，占据空间大，大小不固定。如果存储在栈中，则会影响程序的性能。\n > 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后，从堆中获得实体。\n\n - 内存图： \n ![enter image description here](https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966)\n\n\n\n# 4. null和undefined的区别\n\n - null 表示\"没有对象\"，即该处不应该有值，典型用法：\n\n    > 1. 作为函数的参数，表示该函数的参数不是对象。\n    > 2. 作为对象原型链的终点。 \n    \n    ```js\n    Object.getPrototypeOf(Object.prototype)\n    //null\n    ```\n\n - undefined 表示“缺少值”，即此处应该有值，但是没有被赋值，典型用法：\n\n    > 1. 变量被声明了，但是没有赋值，默认等于undefined。\n    > 2. 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n    > 3. 对象没有赋值的属性，该属性默认值为undefined。\n    > 4. 函数没有返回值时，默认返回undefined。\n    ```js\n    var i;\n    i  //undefined\n    \n    function f(x){console.log(x)}\n    f() //undefined\n    \n    var o = new Object();\n    o.p //undefined\n    \n    var x = f();\n    x //undefinde\n    ```\n\n\n```js\n\t//二者的测试\n\ttypeof undefined == \"undefined\" //true\n\ttypeof null == \"object\" //true\n\t\n\tNumber(undefined)   //NaN\n\tNumber(null)  //0\n```\n\n 3. 注意：\n\t 在验证null时，一定要使用 `===`,因为 `==` 无法分辨null和undefined：\n\t \n\t```js\n\t    null == undefined //true\n\t    null === undefined //false\n\t```\n 4. 打个比方： \n  - null\n\t  - Q: 有张三这个人吗？\n\t  - A:  有！\n\t  - Q: 张三有房子吗？\n\t  - A: 没有！\n  - undefined\n\t  - Q: 有张三这个人吗？\n\t  - A: 有！\n\t  - Q: 张三多少岁了？\n\t  - A: 不知道（没有被告诉）\n\n\n\n# 5. JavaScript的this\n\n - this是一个指针\n - this的指向：\n\t 1. 函数直接调用时：this指向函数的直接调用者；\n\t 2. 通过new关键字，this指向new产生的新对象；\n\t 3. 通过call/apply/bind的绑定，this指向绑定对象。\n\t 4. 在JS事件中，this指向触发这个事件的对象，但是在IE中，attachEvent中的this总是指向全局对象Window。\n\n\n\n# 6.JavaScript的作用域链\n全局函数无法查看局部函数的内部细节，但局部函数刻意查看上层函数的细节，直至全局细节。\n\n当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。\n \n\n\n\n\n# 7. JavaScript原型和原型链\n\n - 原型：每个对象都会在其内部初始化一个属性，就是prototype(原型)。换句话说，**所有对象都是以对象为模板创建实例的。**\n\n - 原型链：当我们访问一个对象的属性A时，如果属性A不存在于该对象中，那么我们会去prototype里查找A，而这个prototype又会有自己的prototype，于是就如此查找下去，就形成了一个原型链。这个原型链表示的是一种连带关系。\n\n - 关系：`instance.constructor.prototype = instance.__proto__`\n\n - 特点：JS对象是通过**引用传递**的（对比于值传递），我们创建的每一个新对象实体中，并没有一份属于自己的原型副本。当我们修改了原型，与之相关的对象也会**继承**这些变化。\n - 终点：原型链的顶端，是`Object.prototype`, 它的`__proto__`指向`null`.\n\n# 8.JavaScript的闭包\n\n 1. 概念\n\t闭包是一种手段，一个有权访问另一个函数作用域中变量的函数，记住闭包也是函数。\n\t\n 2. 创建闭包\n  最常见的方式，就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量(相当于一个对外的接口)。\n  \n 3. 作用\n\t利用闭包可以突破作用域链，将函数内部的变量方法传递到外部。\n\t\n 4. 特性\n\t\t 1. 函数内再嵌套函数\n\t\t 2. 内部函数可以引用外层的参数和变量\n\t\t 3. 参数和变量不会被垃圾回收机制回收\n\n# 9. new操作符到底干了什么？\n 1. 创建一个空对象，将this指针指向该对象，同时继承该函数的原型。\n 2. 属性和方法被添加到this指向的对象中。\n 3. 新创建的对象由this所应用，并且最后隐式的返回this 。\n \n ```js\n var obj = {};\n obj.__proto__ = Base.prototype;\n Base.call(obj);\n ```\n\n\n# 10. JavaScript开发的基本规范\n\n 1. 不要在同一行声明多个变量；\n 2. 请使用 ===/!==来比较布尔值或者数值；\n 3. 使用对象字面量替代 new Array这种形式；\n 4. 不要使用全局函数；\n 5. Switch语句必须带有default分支；\n 6. 函数应该有返回值；\n 7. For循环必须使用大括号；\n 8. if语句必须使用大括号；\n 9. for-in循环中的变量应该使用let 关键字明确限定作用域，避免命名空间污染。\n\n\n----------\nTo be continue。","slug":"2017-03-06 JavaScript精髓(1)","published":1,"updated":"2018-12-24T07:44:15.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7h0006jts463eo8v01","content":"<p>这篇文章主要总结了JavaScript的基础，包括数据类型，值和易混淆的概念。<br><a id=\"more\"></a></p>\n<h1 id=\"1-JavaScript的基本数据类型\"><a href=\"#1-JavaScript的基本数据类型\" class=\"headerlink\" title=\"1. JavaScript的基本数据类型\"></a>1. JavaScript的基本数据类型</h1><ol>\n<li>Undefined</li>\n<li>Null</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Symbol(ES2015新增)</li>\n</ol>\n<h1 id=\"2-JavaScript的内置对象\"><a href=\"#2-JavaScript的内置对象\" class=\"headerlink\" title=\"2. JavaScript的内置对象\"></a>2. JavaScript的内置对象</h1><ul>\n<li>Object 是JS中所有对象的父对象</li>\n<li>数据封装类对象：<ol>\n<li>Object</li>\n<li>Array</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n</ol>\n</li>\n<li>其他对象：<ol>\n<li>Function</li>\n<li>Arguments</li>\n<li>Math</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error </li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>参考文档：<a href=\"http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html\" target=\"_blank\" rel=\"noopener\">文档链接</a></p>\n</blockquote>\n<h1 id=\"3-JavaScript-中有几种类型的值？\"><a href=\"#3-JavaScript-中有几种类型的值？\" class=\"headerlink\" title=\"3. JavaScript 中有几种类型的值？\"></a>3. JavaScript 中有几种类型的值？</h1><ul>\n<li>栈(Stack)：原始(primitive)数据类型(Undefined, Null , Boolean, Number, String)</li>\n<li><p>堆(Heap)：合成(complex)数据类型(Object, Array, Function)</p>\n</li>\n<li><p>两种类型的区别是： <strong>存储位置不同</strong></p>\n</li>\n<li>原始数据类型：直接存储在<strong>栈</strong>中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据，所以放入栈中存储；</li>\n<li><p>引用数据类型：存储在堆(Heap)中的对象，占据空间大，大小不固定。如果存储在栈中，则会影响程序的性能。</p>\n<blockquote>\n<p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后，从堆中获得实体。</p>\n</blockquote>\n</li>\n<li><p>内存图：<br><img src=\"https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966\" alt=\"enter image description here\"></p>\n</li>\n</ul>\n<h1 id=\"4-null和undefined的区别\"><a href=\"#4-null和undefined的区别\" class=\"headerlink\" title=\"4. null和undefined的区别\"></a>4. null和undefined的区别</h1><ul>\n<li><p>null 表示”没有对象”，即该处不应该有值，典型用法：</p>\n<blockquote>\n<ol>\n<li>作为函数的参数，表示该函数的参数不是对象。</li>\n<li>作为对象原型链的终点。 </li>\n</ol>\n</blockquote>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)</span><br><span class=\"line\"><span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>undefined 表示“缺少值”，即此处应该有值，但是没有被赋值，典型用法：</p>\n<blockquote>\n<ol>\n<li>变量被声明了，但是没有赋值，默认等于undefined。</li>\n<li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>\n<li>对象没有赋值的属性，该属性默认值为undefined。</li>\n<li>函数没有返回值时，默认返回undefined。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\">i  <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"built_in\">console</span>.log(x)&#125;</span><br><span class=\"line\">f() <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">o.p <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = f();</span><br><span class=\"line\">x <span class=\"comment\">//undefinde</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二者的测试</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> == <span class=\"string\">\"undefined\"</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> == <span class=\"string\">\"object\"</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">undefined</span>)   <span class=\"comment\">//NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">null</span>)  <span class=\"comment\">//0</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>注意：<br> 在验证null时，一定要使用 <code>===</code>,因为 <code>==</code> 无法分辨null和undefined：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打个比方： </p>\n<ul>\n<li>null<ul>\n<li>Q: 有张三这个人吗？</li>\n<li>A:  有！</li>\n<li>Q: 张三有房子吗？</li>\n<li>A: 没有！</li>\n</ul>\n</li>\n<li>undefined<ul>\n<li>Q: 有张三这个人吗？</li>\n<li>A: 有！</li>\n<li>Q: 张三多少岁了？</li>\n<li>A: 不知道（没有被告诉）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"5-JavaScript的this\"><a href=\"#5-JavaScript的this\" class=\"headerlink\" title=\"5. JavaScript的this\"></a>5. JavaScript的this</h1><ul>\n<li>this是一个指针</li>\n<li>this的指向：<ol>\n<li>函数直接调用时：this指向函数的直接调用者；</li>\n<li>通过new关键字，this指向new产生的新对象；</li>\n<li>通过call/apply/bind的绑定，this指向绑定对象。</li>\n<li>在JS事件中，this指向触发这个事件的对象，但是在IE中，attachEvent中的this总是指向全局对象Window。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"6-JavaScript的作用域链\"><a href=\"#6-JavaScript的作用域链\" class=\"headerlink\" title=\"6.JavaScript的作用域链\"></a>6.JavaScript的作用域链</h1><p>全局函数无法查看局部函数的内部细节，但局部函数刻意查看上层函数的细节，直至全局细节。</p>\n<p>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</p>\n<h1 id=\"7-JavaScript原型和原型链\"><a href=\"#7-JavaScript原型和原型链\" class=\"headerlink\" title=\"7. JavaScript原型和原型链\"></a>7. JavaScript原型和原型链</h1><ul>\n<li><p>原型：每个对象都会在其内部初始化一个属性，就是prototype(原型)。换句话说，<strong>所有对象都是以对象为模板创建实例的。</strong></p>\n</li>\n<li><p>原型链：当我们访问一个对象的属性A时，如果属性A不存在于该对象中，那么我们会去prototype里查找A，而这个prototype又会有自己的prototype，于是就如此查找下去，就形成了一个原型链。这个原型链表示的是一种连带关系。</p>\n</li>\n<li><p>关系：<code>instance.constructor.prototype = instance.__proto__</code></p>\n</li>\n<li><p>特点：JS对象是通过<strong>引用传递</strong>的（对比于值传递），我们创建的每一个新对象实体中，并没有一份属于自己的原型副本。当我们修改了原型，与之相关的对象也会<strong>继承</strong>这些变化。</p>\n</li>\n<li>终点：原型链的顶端，是<code>Object.prototype</code>, 它的<code>__proto__</code>指向<code>null</code>.</li>\n</ul>\n<h1 id=\"8-JavaScript的闭包\"><a href=\"#8-JavaScript的闭包\" class=\"headerlink\" title=\"8.JavaScript的闭包\"></a>8.JavaScript的闭包</h1><ol>\n<li><p>概念<br>闭包是一种手段，一个有权访问另一个函数作用域中变量的函数，记住闭包也是函数。</p>\n</li>\n<li><p>创建闭包<br>最常见的方式，就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量(相当于一个对外的接口)。</p>\n</li>\n<li><p>作用<br>利用闭包可以突破作用域链，将函数内部的变量方法传递到外部。</p>\n</li>\n<li><p>特性</p>\n<pre><code>1. 函数内再嵌套函数\n2. 内部函数可以引用外层的参数和变量\n3. 参数和变量不会被垃圾回收机制回收\n</code></pre></li>\n</ol>\n<h1 id=\"9-new操作符到底干了什么？\"><a href=\"#9-new操作符到底干了什么？\" class=\"headerlink\" title=\"9. new操作符到底干了什么？\"></a>9. new操作符到底干了什么？</h1><ol>\n<li>创建一个空对象，将this指针指向该对象，同时继承该函数的原型。</li>\n<li>属性和方法被添加到this指向的对象中。</li>\n<li><p>新创建的对象由this所应用，并且最后隐式的返回this 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = Base.prototype;</span><br><span class=\"line\">Base.call(obj);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"10-JavaScript开发的基本规范\"><a href=\"#10-JavaScript开发的基本规范\" class=\"headerlink\" title=\"10. JavaScript开发的基本规范\"></a>10. JavaScript开发的基本规范</h1><ol>\n<li>不要在同一行声明多个变量；</li>\n<li>请使用 ===/!==来比较布尔值或者数值；</li>\n<li>使用对象字面量替代 new Array这种形式；</li>\n<li>不要使用全局函数；</li>\n<li>Switch语句必须带有default分支；</li>\n<li>函数应该有返回值；</li>\n<li>For循环必须使用大括号；</li>\n<li>if语句必须使用大括号；</li>\n<li>for-in循环中的变量应该使用let 关键字明确限定作用域，避免命名空间污染。</li>\n</ol>\n<hr>\n<p>To be continue。</p>\n","site":{"data":{}},"excerpt":"<p>这篇文章主要总结了JavaScript的基础，包括数据类型，值和易混淆的概念。<br>","more":"</p>\n<h1 id=\"1-JavaScript的基本数据类型\"><a href=\"#1-JavaScript的基本数据类型\" class=\"headerlink\" title=\"1. JavaScript的基本数据类型\"></a>1. JavaScript的基本数据类型</h1><ol>\n<li>Undefined</li>\n<li>Null</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Symbol(ES2015新增)</li>\n</ol>\n<h1 id=\"2-JavaScript的内置对象\"><a href=\"#2-JavaScript的内置对象\" class=\"headerlink\" title=\"2. JavaScript的内置对象\"></a>2. JavaScript的内置对象</h1><ul>\n<li>Object 是JS中所有对象的父对象</li>\n<li>数据封装类对象：<ol>\n<li>Object</li>\n<li>Array</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n</ol>\n</li>\n<li>其他对象：<ol>\n<li>Function</li>\n<li>Arguments</li>\n<li>Math</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error </li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>参考文档：<a href=\"http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html\" target=\"_blank\" rel=\"noopener\">文档链接</a></p>\n</blockquote>\n<h1 id=\"3-JavaScript-中有几种类型的值？\"><a href=\"#3-JavaScript-中有几种类型的值？\" class=\"headerlink\" title=\"3. JavaScript 中有几种类型的值？\"></a>3. JavaScript 中有几种类型的值？</h1><ul>\n<li>栈(Stack)：原始(primitive)数据类型(Undefined, Null , Boolean, Number, String)</li>\n<li><p>堆(Heap)：合成(complex)数据类型(Object, Array, Function)</p>\n</li>\n<li><p>两种类型的区别是： <strong>存储位置不同</strong></p>\n</li>\n<li>原始数据类型：直接存储在<strong>栈</strong>中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据，所以放入栈中存储；</li>\n<li><p>引用数据类型：存储在堆(Heap)中的对象，占据空间大，大小不固定。如果存储在栈中，则会影响程序的性能。</p>\n<blockquote>\n<p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后，从堆中获得实体。</p>\n</blockquote>\n</li>\n<li><p>内存图：<br><img src=\"https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966\" alt=\"enter image description here\"></p>\n</li>\n</ul>\n<h1 id=\"4-null和undefined的区别\"><a href=\"#4-null和undefined的区别\" class=\"headerlink\" title=\"4. null和undefined的区别\"></a>4. null和undefined的区别</h1><ul>\n<li><p>null 表示”没有对象”，即该处不应该有值，典型用法：</p>\n<blockquote>\n<ol>\n<li>作为函数的参数，表示该函数的参数不是对象。</li>\n<li>作为对象原型链的终点。 </li>\n</ol>\n</blockquote>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)</span><br><span class=\"line\"><span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>undefined 表示“缺少值”，即此处应该有值，但是没有被赋值，典型用法：</p>\n<blockquote>\n<ol>\n<li>变量被声明了，但是没有赋值，默认等于undefined。</li>\n<li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>\n<li>对象没有赋值的属性，该属性默认值为undefined。</li>\n<li>函数没有返回值时，默认返回undefined。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\">i  <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"built_in\">console</span>.log(x)&#125;</span><br><span class=\"line\">f() <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">o.p <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = f();</span><br><span class=\"line\">x <span class=\"comment\">//undefinde</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二者的测试</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> == <span class=\"string\">\"undefined\"</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> == <span class=\"string\">\"object\"</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">undefined</span>)   <span class=\"comment\">//NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">null</span>)  <span class=\"comment\">//0</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>注意：<br> 在验证null时，一定要使用 <code>===</code>,因为 <code>==</code> 无法分辨null和undefined：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打个比方： </p>\n<ul>\n<li>null<ul>\n<li>Q: 有张三这个人吗？</li>\n<li>A:  有！</li>\n<li>Q: 张三有房子吗？</li>\n<li>A: 没有！</li>\n</ul>\n</li>\n<li>undefined<ul>\n<li>Q: 有张三这个人吗？</li>\n<li>A: 有！</li>\n<li>Q: 张三多少岁了？</li>\n<li>A: 不知道（没有被告诉）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"5-JavaScript的this\"><a href=\"#5-JavaScript的this\" class=\"headerlink\" title=\"5. JavaScript的this\"></a>5. JavaScript的this</h1><ul>\n<li>this是一个指针</li>\n<li>this的指向：<ol>\n<li>函数直接调用时：this指向函数的直接调用者；</li>\n<li>通过new关键字，this指向new产生的新对象；</li>\n<li>通过call/apply/bind的绑定，this指向绑定对象。</li>\n<li>在JS事件中，this指向触发这个事件的对象，但是在IE中，attachEvent中的this总是指向全局对象Window。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"6-JavaScript的作用域链\"><a href=\"#6-JavaScript的作用域链\" class=\"headerlink\" title=\"6.JavaScript的作用域链\"></a>6.JavaScript的作用域链</h1><p>全局函数无法查看局部函数的内部细节，但局部函数刻意查看上层函数的细节，直至全局细节。</p>\n<p>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</p>\n<h1 id=\"7-JavaScript原型和原型链\"><a href=\"#7-JavaScript原型和原型链\" class=\"headerlink\" title=\"7. JavaScript原型和原型链\"></a>7. JavaScript原型和原型链</h1><ul>\n<li><p>原型：每个对象都会在其内部初始化一个属性，就是prototype(原型)。换句话说，<strong>所有对象都是以对象为模板创建实例的。</strong></p>\n</li>\n<li><p>原型链：当我们访问一个对象的属性A时，如果属性A不存在于该对象中，那么我们会去prototype里查找A，而这个prototype又会有自己的prototype，于是就如此查找下去，就形成了一个原型链。这个原型链表示的是一种连带关系。</p>\n</li>\n<li><p>关系：<code>instance.constructor.prototype = instance.__proto__</code></p>\n</li>\n<li><p>特点：JS对象是通过<strong>引用传递</strong>的（对比于值传递），我们创建的每一个新对象实体中，并没有一份属于自己的原型副本。当我们修改了原型，与之相关的对象也会<strong>继承</strong>这些变化。</p>\n</li>\n<li>终点：原型链的顶端，是<code>Object.prototype</code>, 它的<code>__proto__</code>指向<code>null</code>.</li>\n</ul>\n<h1 id=\"8-JavaScript的闭包\"><a href=\"#8-JavaScript的闭包\" class=\"headerlink\" title=\"8.JavaScript的闭包\"></a>8.JavaScript的闭包</h1><ol>\n<li><p>概念<br>闭包是一种手段，一个有权访问另一个函数作用域中变量的函数，记住闭包也是函数。</p>\n</li>\n<li><p>创建闭包<br>最常见的方式，就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量(相当于一个对外的接口)。</p>\n</li>\n<li><p>作用<br>利用闭包可以突破作用域链，将函数内部的变量方法传递到外部。</p>\n</li>\n<li><p>特性</p>\n<pre><code>1. 函数内再嵌套函数\n2. 内部函数可以引用外层的参数和变量\n3. 参数和变量不会被垃圾回收机制回收\n</code></pre></li>\n</ol>\n<h1 id=\"9-new操作符到底干了什么？\"><a href=\"#9-new操作符到底干了什么？\" class=\"headerlink\" title=\"9. new操作符到底干了什么？\"></a>9. new操作符到底干了什么？</h1><ol>\n<li>创建一个空对象，将this指针指向该对象，同时继承该函数的原型。</li>\n<li>属性和方法被添加到this指向的对象中。</li>\n<li><p>新创建的对象由this所应用，并且最后隐式的返回this 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = Base.prototype;</span><br><span class=\"line\">Base.call(obj);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"10-JavaScript开发的基本规范\"><a href=\"#10-JavaScript开发的基本规范\" class=\"headerlink\" title=\"10. JavaScript开发的基本规范\"></a>10. JavaScript开发的基本规范</h1><ol>\n<li>不要在同一行声明多个变量；</li>\n<li>请使用 ===/!==来比较布尔值或者数值；</li>\n<li>使用对象字面量替代 new Array这种形式；</li>\n<li>不要使用全局函数；</li>\n<li>Switch语句必须带有default分支；</li>\n<li>函数应该有返回值；</li>\n<li>For循环必须使用大括号；</li>\n<li>if语句必须使用大括号；</li>\n<li>for-in循环中的变量应该使用let 关键字明确限定作用域，避免命名空间污染。</li>\n</ol>\n<hr>\n<p>To be continue。</p>"},{"title":"如何应对CSRF攻击","date":"2017-05-22T16:00:00.000Z","keywords":"前端技术 博客笔记 CSRF 网络安全","description":"本文详细介绍了CSRF攻击，并列举了业界当前的防范方法。","_content":"\n---\n作为Web安全数一数二的隐患，CSRF一直让开发人员头疼。本文详细介绍了CSRF攻击的概念，危害，案例和解决方案，为网站安全优化理清思路。\n\n<!--more-->\n# 一、CSRF的来龙去脉\n\n## 1. 什么是CSRF？\n\nCSRF（Cross Site Request Forgery, **跨站域请求伪造**）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。\n其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。\n\n---\n## 2. CSRF攻击实例\nCSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。\n\n比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求\n>  http://bank.example/withdraw?account=bob&amount=1000000&for=bob2\n\n 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。\n\n通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。\n\nMallory 可以自己发送一个请求给银行：\n> http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory\n\n但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。\n\n>  src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”\n\n并且通过广告等**诱使 Bob 来访问他的网站**。\n\n当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而**这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器**。\n\n大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。\n\n但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 **session 尚未过期**，浏览器的 cookie 之中含有 Bob 的认证信息。\n\n这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时**毫不知情**。\n\n等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。\n\n## 3. CSRF攻击的对象\n\n在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。\n\n从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。\n\n> 因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。\n\n所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。\n\n比如银行系统中**转账**的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。\n\n\n\n# 二、防御 CSRF 的几种策略\n\n在业界目前防御 CSRF 攻击主要有三种策略：\n\n - 验证 HTTP Referer 字段；\n - 在请求地址中添加 token 并验证；\n - 在 HTTP 头中自定义属性并验证。\n\n## 1. 验证 HTTP Referer 字段\n### 1.1 什么是Referer？\n根据 HTTP 协议，在 HTTP 头中有一个字段叫 **Referer**，它记录了该 **HTTP 请求的来源地址**。\n\n在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问\n> http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory\n\n用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。\n\n这时，该转帐请求的 Referer 值就会是**转账按钮所在的页面的 URL**，通常是以 bank.example 域名开头的地址。\n\n而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。\n### 1.2 如何验证Referer？\n因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。\n### 1.3 Referer验证的优缺点\n优点：这种方法简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一**增加一个拦截器来检查 Referer 的值**就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。\n\n缺点：\n\n 1. Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。\n > 使用验证值的方法，**就是把安全性都依赖于第三方（即浏览器）来保障**，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行CSRF 攻击。\n\n 2. 如果用户为了保护隐私，而设置浏览器使其在发送请求时**不再提供 Referer**。当他们正常访问银行网站时，网站会因为请求Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。\n\n## 2. 在请求地址中添加 token 并验证\n### 2.1 黑客总是能找到漏洞\nCSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。\n\n### 2.2 那我们就加一把钥匙\n要抵御 CSRF，关键在于**在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。**可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。\n\n这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。\n\n但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>，这样就把 token 以参数的形式加入请求了。\n### 2.3 使用token的缺点：\n①. 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是**对于在页面加载之后动态生成的 html 代码，这种方法就没有作用**，还需要程序员在编码时手动添加 token。\n\n②. 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。\n\n为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。\n\n## 3. 在 HTTP 头中自定义属性并验证\n### 3.1 把密钥放到HTTP请求头中\n这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。\n\n通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。\n\n这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。\n\n### 3.2 缺点：\n然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。\n\n------\n\n# 三、代码实例(java)：\n\n## 1. 使用Filter验证Referer\n\n``` java\n\t//从HTTP头部取得Referer值\n\t String referer = request.getHeader(\"Referer\");\n\t //判断Referer是否以bank.example开头\n\t if((refirer != null) && (referer.trim().startsWith(\"bank.example\"))){\n\t vhain.doFilter(request, response);\n\t }else{\n\trequest.getRequestDispatcher(\"error.jsp\").forward(request,response);\n\t}\n```\n\n以上代码先取得Referer值，然后进行判断，当其非空并以bank.example开头时，则继续请求，否则的话可能是CSRF攻击，转到error.jsp页面。\n\n## 2.进一步验证请求中的token\n``` java\nHttpServletRequest req = (HttpServletRequest)request;\nHttpSession s = req.getSession();\n//从session中，得到csrftoken属性\nString sToken = (String)s.getAttribute(\"csrftoken\");\nif(sToken == null){\n\t//产生新的token放入session中\n\tsToken = generateToken();\n\ts.setAttribute(\"csrftoken\", sToken);\n\tchain.doFilter(request, response);\n}else{\n\t//从HTTP头中取得csrftoken\n\tString xhrToken = req.getHeader(\"csrftoken\");\n\t//从请求参数中取得csrftoken\n\tString pToken = req.getParameter(\"csrftoken\");\n\tif(sToken != null && xhrToken != null && sToken.equals(xhrToken)){\n\t\tchain.doFilter(request, response);\n\t}else{\n\trequest.getRequestDispatcher(\"error.jsp\").forward(request,response);\n\t}\n}\n```\n\n## 3.在客户端对请求附加token\n``` javascript\nfunction appendTOken(){\n\tupdateForms();\n\tupdateTags();\n}\nfunction updateForms(){\n\t//获取所有form元素\n\tvar forms = document.getElementsByTagName('form');\n\tfor (i = 0; i < forms.length; i++){\n\t\tvar url = forms[i].action;\n\n\t\t//如果这个form的action值为空，则不附加csrftoken\n\t\tif(url == null || url == \"\") continue;\n\n\t\t//动态生成input元素，加到 form 之后\n\t\tvar e = docement.createElement(\"input\");\n\t\te.name = \"csrftoken\";\n\t\te.value = token;\n\t\te.type = \"hidden\";\n\t\tforms[i].appendChild(e);\n\t}\n}\n\nfunction updateTags(){\n\tvar all = document.getElementsByTagName('a');\n\tvar len = all.length;\n\n\t//遍历所有a元素\n\tfor(var i = 0; i< len; i++){\n\t\tvar e = all[i];\n\t\tupdateTag(e, \"href\" , token);\n\t}\n}\n\nfunction updateTag(element, attr, token){\n\tvar location = element.getAttribute(attr);\n\tif(location != null && location != '' ''){\n\t\tvar fragmentIndex = location.indexOf(\"#\");\n\t\tvar fragment = null;\n\t\tif(fragmentIndex != -1){\n\t\t\t//url中含有#锚标记\n\t\t\tfragment = location.substring(fragmentIndex);\n\t\t\tlocation = location.substring(0, fragmentIndex);\n\t\t}\n\n\n\t\tvar index = location.indexOf('?');\n\t\tif(index !== -1){\n\t\t\t//url中已含有其他参数\n\t\t\tlocation = location + '&csrftoken=' + token;\n\t\t}else{\n\t\t\t//url中没有其他参数\n\t\t\tlocation = location + '?csrftoken=' + token;\n\t\t}\n\t\tif(fragment != null){\n\t\t\tlocation += fragment;\n\t\t}\n\t\telement.setAttribute(attr, location);\n\t}\n}\n```\n\n在客户端html中，主要有两个地方需要加上token，一个是表单form，另一个就是a标签。上面这段代码，首先遍历所有的form, 在form最后添加一段**隐藏字段**，把csrftoken放入其中。然后，代码遍历所有的a标签，在其href属性中加入csrftoken参数。 注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。\n\n## 4. 在 HTTP 头中自定义属性\n\n     var plainXhr = dojo.xhr;\n\n     // 重写 dojo.xhr 方法\n     dojo.xhr = function(method,args,hasBody) {\n        // 确保 header 对象存在\n        args.headers = args.header || {};\n\n        tokenValue = '<%=request.getSession(false).getAttribute(\"csrftoken\")%>';\n        var token = dojo.getObject(\"tokenValue\");\n\n        // 把 csrftoken 属性放到头中\n        args.headers[\"csrftoken\"] = (token) ? token : \"  \";\n        return plainXhr(method,args,hasBody);\n     };\n\n这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。\n\n# 四、如何选择CSRF防御方法？\n\n目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。\n\n如果网站是一个现有系统，想要**在最短时间内获得一定程度的 CSRF 的保护**，那么**验证 Referer** 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。\n\n如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。\n在这种情况下，你需要**小心规划你网站提供的各种服务**，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。\n\n如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议**对于重要的服务，可以尽量使用 XMLHttpRequest 来访问**，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。\n\n最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。\n\n# 五、总结\n\n可见，CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF 的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token 方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视 CSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低。\n\n---\n>  [参考链接：IBM的技术博客](https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/)\n","source":"_posts/2017-05-23 深入研究CSRF.md","raw":"title: 如何应对CSRF攻击\ndate: 2017-5-23\ncategories: 技术\ntags: [前端,安全]\nkeywords: 前端技术 博客笔记 CSRF 网络安全\ndescription: 本文详细介绍了CSRF攻击，并列举了业界当前的防范方法。\n\n# CSRF攻击的应对之道\n\n---\n\n---\n作为Web安全数一数二的隐患，CSRF一直让开发人员头疼。本文详细介绍了CSRF攻击的概念，危害，案例和解决方案，为网站安全优化理清思路。\n\n<!--more-->\n# 一、CSRF的来龙去脉\n\n## 1. 什么是CSRF？\n\nCSRF（Cross Site Request Forgery, **跨站域请求伪造**）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。\n其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。\n\n---\n## 2. CSRF攻击实例\nCSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。\n\n比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求\n>  http://bank.example/withdraw?account=bob&amount=1000000&for=bob2\n\n 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。\n\n通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。\n\nMallory 可以自己发送一个请求给银行：\n> http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory\n\n但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。\n\n>  src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”\n\n并且通过广告等**诱使 Bob 来访问他的网站**。\n\n当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而**这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器**。\n\n大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。\n\n但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 **session 尚未过期**，浏览器的 cookie 之中含有 Bob 的认证信息。\n\n这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时**毫不知情**。\n\n等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。\n\n## 3. CSRF攻击的对象\n\n在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。\n\n从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。\n\n> 因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。\n\n所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。\n\n比如银行系统中**转账**的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。\n\n\n\n# 二、防御 CSRF 的几种策略\n\n在业界目前防御 CSRF 攻击主要有三种策略：\n\n - 验证 HTTP Referer 字段；\n - 在请求地址中添加 token 并验证；\n - 在 HTTP 头中自定义属性并验证。\n\n## 1. 验证 HTTP Referer 字段\n### 1.1 什么是Referer？\n根据 HTTP 协议，在 HTTP 头中有一个字段叫 **Referer**，它记录了该 **HTTP 请求的来源地址**。\n\n在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问\n> http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory\n\n用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。\n\n这时，该转帐请求的 Referer 值就会是**转账按钮所在的页面的 URL**，通常是以 bank.example 域名开头的地址。\n\n而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。\n### 1.2 如何验证Referer？\n因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。\n### 1.3 Referer验证的优缺点\n优点：这种方法简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一**增加一个拦截器来检查 Referer 的值**就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。\n\n缺点：\n\n 1. Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。\n > 使用验证值的方法，**就是把安全性都依赖于第三方（即浏览器）来保障**，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行CSRF 攻击。\n\n 2. 如果用户为了保护隐私，而设置浏览器使其在发送请求时**不再提供 Referer**。当他们正常访问银行网站时，网站会因为请求Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。\n\n## 2. 在请求地址中添加 token 并验证\n### 2.1 黑客总是能找到漏洞\nCSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。\n\n### 2.2 那我们就加一把钥匙\n要抵御 CSRF，关键在于**在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。**可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。\n\n这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。\n\n但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>，这样就把 token 以参数的形式加入请求了。\n### 2.3 使用token的缺点：\n①. 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是**对于在页面加载之后动态生成的 html 代码，这种方法就没有作用**，还需要程序员在编码时手动添加 token。\n\n②. 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。\n\n为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。\n\n## 3. 在 HTTP 头中自定义属性并验证\n### 3.1 把密钥放到HTTP请求头中\n这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。\n\n通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。\n\n这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。\n\n### 3.2 缺点：\n然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。\n\n------\n\n# 三、代码实例(java)：\n\n## 1. 使用Filter验证Referer\n\n``` java\n\t//从HTTP头部取得Referer值\n\t String referer = request.getHeader(\"Referer\");\n\t //判断Referer是否以bank.example开头\n\t if((refirer != null) && (referer.trim().startsWith(\"bank.example\"))){\n\t vhain.doFilter(request, response);\n\t }else{\n\trequest.getRequestDispatcher(\"error.jsp\").forward(request,response);\n\t}\n```\n\n以上代码先取得Referer值，然后进行判断，当其非空并以bank.example开头时，则继续请求，否则的话可能是CSRF攻击，转到error.jsp页面。\n\n## 2.进一步验证请求中的token\n``` java\nHttpServletRequest req = (HttpServletRequest)request;\nHttpSession s = req.getSession();\n//从session中，得到csrftoken属性\nString sToken = (String)s.getAttribute(\"csrftoken\");\nif(sToken == null){\n\t//产生新的token放入session中\n\tsToken = generateToken();\n\ts.setAttribute(\"csrftoken\", sToken);\n\tchain.doFilter(request, response);\n}else{\n\t//从HTTP头中取得csrftoken\n\tString xhrToken = req.getHeader(\"csrftoken\");\n\t//从请求参数中取得csrftoken\n\tString pToken = req.getParameter(\"csrftoken\");\n\tif(sToken != null && xhrToken != null && sToken.equals(xhrToken)){\n\t\tchain.doFilter(request, response);\n\t}else{\n\trequest.getRequestDispatcher(\"error.jsp\").forward(request,response);\n\t}\n}\n```\n\n## 3.在客户端对请求附加token\n``` javascript\nfunction appendTOken(){\n\tupdateForms();\n\tupdateTags();\n}\nfunction updateForms(){\n\t//获取所有form元素\n\tvar forms = document.getElementsByTagName('form');\n\tfor (i = 0; i < forms.length; i++){\n\t\tvar url = forms[i].action;\n\n\t\t//如果这个form的action值为空，则不附加csrftoken\n\t\tif(url == null || url == \"\") continue;\n\n\t\t//动态生成input元素，加到 form 之后\n\t\tvar e = docement.createElement(\"input\");\n\t\te.name = \"csrftoken\";\n\t\te.value = token;\n\t\te.type = \"hidden\";\n\t\tforms[i].appendChild(e);\n\t}\n}\n\nfunction updateTags(){\n\tvar all = document.getElementsByTagName('a');\n\tvar len = all.length;\n\n\t//遍历所有a元素\n\tfor(var i = 0; i< len; i++){\n\t\tvar e = all[i];\n\t\tupdateTag(e, \"href\" , token);\n\t}\n}\n\nfunction updateTag(element, attr, token){\n\tvar location = element.getAttribute(attr);\n\tif(location != null && location != '' ''){\n\t\tvar fragmentIndex = location.indexOf(\"#\");\n\t\tvar fragment = null;\n\t\tif(fragmentIndex != -1){\n\t\t\t//url中含有#锚标记\n\t\t\tfragment = location.substring(fragmentIndex);\n\t\t\tlocation = location.substring(0, fragmentIndex);\n\t\t}\n\n\n\t\tvar index = location.indexOf('?');\n\t\tif(index !== -1){\n\t\t\t//url中已含有其他参数\n\t\t\tlocation = location + '&csrftoken=' + token;\n\t\t}else{\n\t\t\t//url中没有其他参数\n\t\t\tlocation = location + '?csrftoken=' + token;\n\t\t}\n\t\tif(fragment != null){\n\t\t\tlocation += fragment;\n\t\t}\n\t\telement.setAttribute(attr, location);\n\t}\n}\n```\n\n在客户端html中，主要有两个地方需要加上token，一个是表单form，另一个就是a标签。上面这段代码，首先遍历所有的form, 在form最后添加一段**隐藏字段**，把csrftoken放入其中。然后，代码遍历所有的a标签，在其href属性中加入csrftoken参数。 注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。\n\n## 4. 在 HTTP 头中自定义属性\n\n     var plainXhr = dojo.xhr;\n\n     // 重写 dojo.xhr 方法\n     dojo.xhr = function(method,args,hasBody) {\n        // 确保 header 对象存在\n        args.headers = args.header || {};\n\n        tokenValue = '<%=request.getSession(false).getAttribute(\"csrftoken\")%>';\n        var token = dojo.getObject(\"tokenValue\");\n\n        // 把 csrftoken 属性放到头中\n        args.headers[\"csrftoken\"] = (token) ? token : \"  \";\n        return plainXhr(method,args,hasBody);\n     };\n\n这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。\n\n# 四、如何选择CSRF防御方法？\n\n目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。\n\n如果网站是一个现有系统，想要**在最短时间内获得一定程度的 CSRF 的保护**，那么**验证 Referer** 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。\n\n如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。\n在这种情况下，你需要**小心规划你网站提供的各种服务**，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。\n\n如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议**对于重要的服务，可以尽量使用 XMLHttpRequest 来访问**，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。\n\n最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。\n\n# 五、总结\n\n可见，CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF 的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token 方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视 CSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低。\n\n---\n>  [参考链接：IBM的技术博客](https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/)\n","slug":"2017-05-23 深入研究CSRF","published":1,"updated":"2018-12-21T12:18:12.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7l000ajts4qo8ardtp","content":"<hr>\n<p>作为Web安全数一数二的隐患，CSRF一直让开发人员头疼。本文详细介绍了CSRF攻击的概念，危害，案例和解决方案，为网站安全优化理清思路。</p>\n<a id=\"more\"></a>\n<h1 id=\"一、CSRF的来龙去脉\"><a href=\"#一、CSRF的来龙去脉\" class=\"headerlink\" title=\"一、CSRF的来龙去脉\"></a>一、CSRF的来龙去脉</h1><h2 id=\"1-什么是CSRF？\"><a href=\"#1-什么是CSRF？\" class=\"headerlink\" title=\"1. 什么是CSRF？\"></a>1. 什么是CSRF？</h2><p>CSRF（Cross Site Request Forgery, <strong>跨站域请求伪造</strong>）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。<br>其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。</p>\n<hr>\n<h2 id=\"2-CSRF攻击实例\"><a href=\"#2-CSRF攻击实例\" class=\"headerlink\" title=\"2. CSRF攻击实例\"></a>2. CSRF攻击实例</h2><p>CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。</p>\n<p>比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求</p>\n<blockquote>\n<p> <a href=\"http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2\" target=\"_blank\" rel=\"noopener\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a></p>\n</blockquote>\n<p> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。</p>\n<p>通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p>\n<p>Mallory 可以自己发送一个请求给银行：</p>\n<blockquote>\n<p><a href=\"http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory\" target=\"_blank\" rel=\"noopener\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a></p>\n</blockquote>\n<p>但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p>\n<blockquote>\n<p> src=”<a href=\"http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory\" target=\"_blank\" rel=\"noopener\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”</p>\n</blockquote>\n<p>并且通过广告等<strong>诱使 Bob 来访问他的网站</strong>。</p>\n<p>当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而<strong>这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器</strong>。</p>\n<p>大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。</p>\n<p>但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 <strong>session 尚未过期</strong>，浏览器的 cookie 之中含有 Bob 的认证信息。</p>\n<p>这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时<strong>毫不知情</strong>。</p>\n<p>等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p>\n<h2 id=\"3-CSRF攻击的对象\"><a href=\"#3-CSRF攻击的对象\" class=\"headerlink\" title=\"3. CSRF攻击的对象\"></a>3. CSRF攻击的对象</h2><p>在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。</p>\n<p>从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。</p>\n<blockquote>\n<p>因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p>\n</blockquote>\n<p>所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。</p>\n<p>比如银行系统中<strong>转账</strong>的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。</p>\n<h1 id=\"二、防御-CSRF-的几种策略\"><a href=\"#二、防御-CSRF-的几种策略\" class=\"headerlink\" title=\"二、防御 CSRF 的几种策略\"></a>二、防御 CSRF 的几种策略</h1><p>在业界目前防御 CSRF 攻击主要有三种策略：</p>\n<ul>\n<li>验证 HTTP Referer 字段；</li>\n<li>在请求地址中添加 token 并验证；</li>\n<li>在 HTTP 头中自定义属性并验证。</li>\n</ul>\n<h2 id=\"1-验证-HTTP-Referer-字段\"><a href=\"#1-验证-HTTP-Referer-字段\" class=\"headerlink\" title=\"1. 验证 HTTP Referer 字段\"></a>1. 验证 HTTP Referer 字段</h2><h3 id=\"1-1-什么是Referer？\"><a href=\"#1-1-什么是Referer？\" class=\"headerlink\" title=\"1.1 什么是Referer？\"></a>1.1 什么是Referer？</h3><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 <strong>Referer</strong>，它记录了该 <strong>HTTP 请求的来源地址</strong>。</p>\n<p>在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问</p>\n<blockquote>\n<p><a href=\"http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory\" target=\"_blank\" rel=\"noopener\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a></p>\n</blockquote>\n<p>用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。</p>\n<p>这时，该转帐请求的 Referer 值就会是<strong>转账按钮所在的页面的 URL</strong>，通常是以 bank.example 域名开头的地址。</p>\n<p>而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。</p>\n<h3 id=\"1-2-如何验证Referer？\"><a href=\"#1-2-如何验证Referer？\" class=\"headerlink\" title=\"1.2 如何验证Referer？\"></a>1.2 如何验证Referer？</h3><p>因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>\n<h3 id=\"1-3-Referer验证的优缺点\"><a href=\"#1-3-Referer验证的优缺点\" class=\"headerlink\" title=\"1.3 Referer验证的优缺点\"></a>1.3 Referer验证的优缺点</h3><p>优点：这种方法简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一<strong>增加一个拦截器来检查 Referer 的值</strong>就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>\n<p>缺点：</p>\n<ol>\n<li><p>Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。</p>\n<blockquote>\n<p>使用验证值的方法，<strong>就是把安全性都依赖于第三方（即浏览器）来保障</strong>，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行CSRF 攻击。</p>\n</blockquote>\n</li>\n<li><p>如果用户为了保护隐私，而设置浏览器使其在发送请求时<strong>不再提供 Referer</strong>。当他们正常访问银行网站时，网站会因为请求Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>\n</li>\n</ol>\n<h2 id=\"2-在请求地址中添加-token-并验证\"><a href=\"#2-在请求地址中添加-token-并验证\" class=\"headerlink\" title=\"2. 在请求地址中添加 token 并验证\"></a>2. 在请求地址中添加 token 并验证</h2><h3 id=\"2-1-黑客总是能找到漏洞\"><a href=\"#2-1-黑客总是能找到漏洞\" class=\"headerlink\" title=\"2.1 黑客总是能找到漏洞\"></a>2.1 黑客总是能找到漏洞</h3><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。</p>\n<h3 id=\"2-2-那我们就加一把钥匙\"><a href=\"#2-2-那我们就加一把钥匙\" class=\"headerlink\" title=\"2.2 那我们就加一把钥匙\"></a>2.2 那我们就加一把钥匙</h3><p>要抵御 CSRF，关键在于<strong>在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。</strong>可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>\n<p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。</p>\n<p>但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href=\"http://url?csrftoken=tokenvalue。\" target=\"_blank\" rel=\"noopener\">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type=\"”hidden”\" name=\"”csrftoken”\" value=\"”tokenvalue”/\">，这样就把 token 以参数的形式加入请求了。</p>\n<h3 id=\"2-3-使用token的缺点：\"><a href=\"#2-3-使用token的缺点：\" class=\"headerlink\" title=\"2.3 使用token的缺点：\"></a>2.3 使用token的缺点：</h3><p>①. 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是<strong>对于在页面加载之后动态生成的 html 代码，这种方法就没有作用</strong>，还需要程序员在编码时手动添加 token。</p>\n<p>②. 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。</p>\n<p>为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>\n<h2 id=\"3-在-HTTP-头中自定义属性并验证\"><a href=\"#3-在-HTTP-头中自定义属性并验证\" class=\"headerlink\" title=\"3. 在 HTTP 头中自定义属性并验证\"></a>3. 在 HTTP 头中自定义属性并验证</h2><h3 id=\"3-1-把密钥放到HTTP请求头中\"><a href=\"#3-1-把密钥放到HTTP请求头中\" class=\"headerlink\" title=\"3.1 把密钥放到HTTP请求头中\"></a>3.1 把密钥放到HTTP请求头中</h3><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。</p>\n<p>通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。</p>\n<p>这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>\n<h3 id=\"3-2-缺点：\"><a href=\"#3-2-缺点：\" class=\"headerlink\" title=\"3.2 缺点：\"></a>3.2 缺点：</h3><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>\n<hr>\n<h1 id=\"三、代码实例-java-：\"><a href=\"#三、代码实例-java-：\" class=\"headerlink\" title=\"三、代码实例(java)：\"></a>三、代码实例(java)：</h1><h2 id=\"1-使用Filter验证Referer\"><a href=\"#1-使用Filter验证Referer\" class=\"headerlink\" title=\"1. 使用Filter验证Referer\"></a>1. 使用Filter验证Referer</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从HTTP头部取得Referer值</span></span><br><span class=\"line\"> String referer = request.getHeader(<span class=\"string\">\"Referer\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">//判断Referer是否以bank.example开头</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>((refirer != <span class=\"keyword\">null</span>) &amp;&amp; (referer.trim().startsWith(<span class=\"string\">\"bank.example\"</span>)))&#123;</span><br><span class=\"line\"> vhain.doFilter(request, response);</span><br><span class=\"line\"> &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">request.getRequestDispatcher(<span class=\"string\">\"error.jsp\"</span>).forward(request,response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码先取得Referer值，然后进行判断，当其非空并以bank.example开头时，则继续请求，否则的话可能是CSRF攻击，转到error.jsp页面。</p>\n<h2 id=\"2-进一步验证请求中的token\"><a href=\"#2-进一步验证请求中的token\" class=\"headerlink\" title=\"2.进一步验证请求中的token\"></a>2.进一步验证请求中的token</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HttpServletRequest req = (HttpServletRequest)request;</span><br><span class=\"line\">HttpSession s = req.getSession();</span><br><span class=\"line\"><span class=\"comment\">//从session中，得到csrftoken属性</span></span><br><span class=\"line\">String sToken = (String)s.getAttribute(<span class=\"string\">\"csrftoken\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(sToken == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//产生新的token放入session中</span></span><br><span class=\"line\">\tsToken = generateToken();</span><br><span class=\"line\">\ts.setAttribute(<span class=\"string\">\"csrftoken\"</span>, sToken);</span><br><span class=\"line\">\tchain.doFilter(request, response);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从HTTP头中取得csrftoken</span></span><br><span class=\"line\">\tString xhrToken = req.getHeader(<span class=\"string\">\"csrftoken\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//从请求参数中取得csrftoken</span></span><br><span class=\"line\">\tString pToken = req.getParameter(<span class=\"string\">\"csrftoken\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(sToken != <span class=\"keyword\">null</span> &amp;&amp; xhrToken != <span class=\"keyword\">null</span> &amp;&amp; sToken.equals(xhrToken))&#123;</span><br><span class=\"line\">\t\tchain.doFilter(request, response);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\trequest.getRequestDispatcher(<span class=\"string\">\"error.jsp\"</span>).forward(request,response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-在客户端对请求附加token\"><a href=\"#3-在客户端对请求附加token\" class=\"headerlink\" title=\"3.在客户端对请求附加token\"></a>3.在客户端对请求附加token</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendTOken</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tupdateForms();</span><br><span class=\"line\">\tupdateTags();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateForms</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获取所有form元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> forms = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'form'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; forms.length; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> url = forms[i].action;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果这个form的action值为空，则不附加csrftoken</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(url == <span class=\"literal\">null</span> || url == <span class=\"string\">\"\"</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//动态生成input元素，加到 form 之后</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e = docement.createElement(<span class=\"string\">\"input\"</span>);</span><br><span class=\"line\">\t\te.name = <span class=\"string\">\"csrftoken\"</span>;</span><br><span class=\"line\">\t\te.value = token;</span><br><span class=\"line\">\t\te.type = <span class=\"string\">\"hidden\"</span>;</span><br><span class=\"line\">\t\tforms[i].appendChild(e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateTags</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> all = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> len = all.length;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历所有a元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i&lt; len; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e = all[i];</span><br><span class=\"line\">\t\tupdateTag(e, <span class=\"string\">\"href\"</span> , token);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateTag</span>(<span class=\"params\">element, attr, token</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> location = element.getAttribute(attr);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(location != <span class=\"literal\">null</span> &amp;&amp; location != <span class=\"string\">''</span> <span class=\"string\">''</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fragmentIndex = location.indexOf(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fragment = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fragmentIndex != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//url中含有#锚标记</span></span><br><span class=\"line\">\t\t\tfragment = location.substring(fragmentIndex);</span><br><span class=\"line\">\t\t\tlocation = location.substring(<span class=\"number\">0</span>, fragmentIndex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> index = location.indexOf(<span class=\"string\">'?'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(index !== <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//url中已含有其他参数</span></span><br><span class=\"line\">\t\t\tlocation = location + <span class=\"string\">'&amp;csrftoken='</span> + token;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//url中没有其他参数</span></span><br><span class=\"line\">\t\t\tlocation = location + <span class=\"string\">'?csrftoken='</span> + token;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fragment != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tlocation += fragment;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telement.setAttribute(attr, location);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在客户端html中，主要有两个地方需要加上token，一个是表单form，另一个就是a标签。上面这段代码，首先遍历所有的form, 在form最后添加一段<strong>隐藏字段</strong>，把csrftoken放入其中。然后，代码遍历所有的a标签，在其href属性中加入csrftoken参数。 注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。</p>\n<h2 id=\"4-在-HTTP-头中自定义属性\"><a href=\"#4-在-HTTP-头中自定义属性\" class=\"headerlink\" title=\"4. 在 HTTP 头中自定义属性\"></a>4. 在 HTTP 头中自定义属性</h2><pre><code>var plainXhr = dojo.xhr;\n\n// 重写 dojo.xhr 方法\ndojo.xhr = function(method,args,hasBody) {\n   // 确保 header 对象存在\n   args.headers = args.header || {};\n\n   tokenValue = &apos;&lt;%=request.getSession(false).getAttribute(&quot;csrftoken&quot;)%&gt;&apos;;\n   var token = dojo.getObject(&quot;tokenValue&quot;);\n\n   // 把 csrftoken 属性放到头中\n   args.headers[&quot;csrftoken&quot;] = (token) ? token : &quot;  &quot;;\n   return plainXhr(method,args,hasBody);\n};\n</code></pre><p>这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。</p>\n<h1 id=\"四、如何选择CSRF防御方法？\"><a href=\"#四、如何选择CSRF防御方法？\" class=\"headerlink\" title=\"四、如何选择CSRF防御方法？\"></a>四、如何选择CSRF防御方法？</h1><p>目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。</p>\n<p>如果网站是一个现有系统，想要<strong>在最短时间内获得一定程度的 CSRF 的保护</strong>，那么<strong>验证 Referer</strong> 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。</p>\n<p>如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。<br>在这种情况下，你需要<strong>小心规划你网站提供的各种服务</strong>，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。</p>\n<p>如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议<strong>对于重要的服务，可以尽量使用 XMLHttpRequest 来访问</strong>，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。</p>\n<p>最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。</p>\n<h1 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h1><p>可见，CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF 的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token 方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视 CSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低。</p>\n<hr>\n<blockquote>\n<p> <a href=\"https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/\" target=\"_blank\" rel=\"noopener\">参考链接：IBM的技术博客</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<hr>\n<p>作为Web安全数一数二的隐患，CSRF一直让开发人员头疼。本文详细介绍了CSRF攻击的概念，危害，案例和解决方案，为网站安全优化理清思路。</p>","more":"<h1 id=\"一、CSRF的来龙去脉\"><a href=\"#一、CSRF的来龙去脉\" class=\"headerlink\" title=\"一、CSRF的来龙去脉\"></a>一、CSRF的来龙去脉</h1><h2 id=\"1-什么是CSRF？\"><a href=\"#1-什么是CSRF？\" class=\"headerlink\" title=\"1. 什么是CSRF？\"></a>1. 什么是CSRF？</h2><p>CSRF（Cross Site Request Forgery, <strong>跨站域请求伪造</strong>）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。<br>其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。</p>\n<hr>\n<h2 id=\"2-CSRF攻击实例\"><a href=\"#2-CSRF攻击实例\" class=\"headerlink\" title=\"2. CSRF攻击实例\"></a>2. CSRF攻击实例</h2><p>CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。</p>\n<p>比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求</p>\n<blockquote>\n<p> <a href=\"http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2\" target=\"_blank\" rel=\"noopener\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a></p>\n</blockquote>\n<p> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。</p>\n<p>通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p>\n<p>Mallory 可以自己发送一个请求给银行：</p>\n<blockquote>\n<p><a href=\"http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory\" target=\"_blank\" rel=\"noopener\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a></p>\n</blockquote>\n<p>但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p>\n<blockquote>\n<p> src=”<a href=\"http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory\" target=\"_blank\" rel=\"noopener\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”</p>\n</blockquote>\n<p>并且通过广告等<strong>诱使 Bob 来访问他的网站</strong>。</p>\n<p>当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而<strong>这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器</strong>。</p>\n<p>大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。</p>\n<p>但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 <strong>session 尚未过期</strong>，浏览器的 cookie 之中含有 Bob 的认证信息。</p>\n<p>这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时<strong>毫不知情</strong>。</p>\n<p>等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p>\n<h2 id=\"3-CSRF攻击的对象\"><a href=\"#3-CSRF攻击的对象\" class=\"headerlink\" title=\"3. CSRF攻击的对象\"></a>3. CSRF攻击的对象</h2><p>在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。</p>\n<p>从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。</p>\n<blockquote>\n<p>因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p>\n</blockquote>\n<p>所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。</p>\n<p>比如银行系统中<strong>转账</strong>的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。</p>\n<h1 id=\"二、防御-CSRF-的几种策略\"><a href=\"#二、防御-CSRF-的几种策略\" class=\"headerlink\" title=\"二、防御 CSRF 的几种策略\"></a>二、防御 CSRF 的几种策略</h1><p>在业界目前防御 CSRF 攻击主要有三种策略：</p>\n<ul>\n<li>验证 HTTP Referer 字段；</li>\n<li>在请求地址中添加 token 并验证；</li>\n<li>在 HTTP 头中自定义属性并验证。</li>\n</ul>\n<h2 id=\"1-验证-HTTP-Referer-字段\"><a href=\"#1-验证-HTTP-Referer-字段\" class=\"headerlink\" title=\"1. 验证 HTTP Referer 字段\"></a>1. 验证 HTTP Referer 字段</h2><h3 id=\"1-1-什么是Referer？\"><a href=\"#1-1-什么是Referer？\" class=\"headerlink\" title=\"1.1 什么是Referer？\"></a>1.1 什么是Referer？</h3><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 <strong>Referer</strong>，它记录了该 <strong>HTTP 请求的来源地址</strong>。</p>\n<p>在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问</p>\n<blockquote>\n<p><a href=\"http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory\" target=\"_blank\" rel=\"noopener\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a></p>\n</blockquote>\n<p>用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。</p>\n<p>这时，该转帐请求的 Referer 值就会是<strong>转账按钮所在的页面的 URL</strong>，通常是以 bank.example 域名开头的地址。</p>\n<p>而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。</p>\n<h3 id=\"1-2-如何验证Referer？\"><a href=\"#1-2-如何验证Referer？\" class=\"headerlink\" title=\"1.2 如何验证Referer？\"></a>1.2 如何验证Referer？</h3><p>因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>\n<h3 id=\"1-3-Referer验证的优缺点\"><a href=\"#1-3-Referer验证的优缺点\" class=\"headerlink\" title=\"1.3 Referer验证的优缺点\"></a>1.3 Referer验证的优缺点</h3><p>优点：这种方法简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一<strong>增加一个拦截器来检查 Referer 的值</strong>就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>\n<p>缺点：</p>\n<ol>\n<li><p>Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。</p>\n<blockquote>\n<p>使用验证值的方法，<strong>就是把安全性都依赖于第三方（即浏览器）来保障</strong>，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行CSRF 攻击。</p>\n</blockquote>\n</li>\n<li><p>如果用户为了保护隐私，而设置浏览器使其在发送请求时<strong>不再提供 Referer</strong>。当他们正常访问银行网站时，网站会因为请求Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>\n</li>\n</ol>\n<h2 id=\"2-在请求地址中添加-token-并验证\"><a href=\"#2-在请求地址中添加-token-并验证\" class=\"headerlink\" title=\"2. 在请求地址中添加 token 并验证\"></a>2. 在请求地址中添加 token 并验证</h2><h3 id=\"2-1-黑客总是能找到漏洞\"><a href=\"#2-1-黑客总是能找到漏洞\" class=\"headerlink\" title=\"2.1 黑客总是能找到漏洞\"></a>2.1 黑客总是能找到漏洞</h3><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。</p>\n<h3 id=\"2-2-那我们就加一把钥匙\"><a href=\"#2-2-那我们就加一把钥匙\" class=\"headerlink\" title=\"2.2 那我们就加一把钥匙\"></a>2.2 那我们就加一把钥匙</h3><p>要抵御 CSRF，关键在于<strong>在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。</strong>可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>\n<p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。</p>\n<p>但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href=\"http://url?csrftoken=tokenvalue。\" target=\"_blank\" rel=\"noopener\">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type=\"”hidden”\" name=\"”csrftoken”\" value=\"”tokenvalue”/\">，这样就把 token 以参数的形式加入请求了。</p>\n<h3 id=\"2-3-使用token的缺点：\"><a href=\"#2-3-使用token的缺点：\" class=\"headerlink\" title=\"2.3 使用token的缺点：\"></a>2.3 使用token的缺点：</h3><p>①. 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是<strong>对于在页面加载之后动态生成的 html 代码，这种方法就没有作用</strong>，还需要程序员在编码时手动添加 token。</p>\n<p>②. 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。</p>\n<p>为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>\n<h2 id=\"3-在-HTTP-头中自定义属性并验证\"><a href=\"#3-在-HTTP-头中自定义属性并验证\" class=\"headerlink\" title=\"3. 在 HTTP 头中自定义属性并验证\"></a>3. 在 HTTP 头中自定义属性并验证</h2><h3 id=\"3-1-把密钥放到HTTP请求头中\"><a href=\"#3-1-把密钥放到HTTP请求头中\" class=\"headerlink\" title=\"3.1 把密钥放到HTTP请求头中\"></a>3.1 把密钥放到HTTP请求头中</h3><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。</p>\n<p>通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。</p>\n<p>这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>\n<h3 id=\"3-2-缺点：\"><a href=\"#3-2-缺点：\" class=\"headerlink\" title=\"3.2 缺点：\"></a>3.2 缺点：</h3><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>\n<hr>\n<h1 id=\"三、代码实例-java-：\"><a href=\"#三、代码实例-java-：\" class=\"headerlink\" title=\"三、代码实例(java)：\"></a>三、代码实例(java)：</h1><h2 id=\"1-使用Filter验证Referer\"><a href=\"#1-使用Filter验证Referer\" class=\"headerlink\" title=\"1. 使用Filter验证Referer\"></a>1. 使用Filter验证Referer</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从HTTP头部取得Referer值</span></span><br><span class=\"line\"> String referer = request.getHeader(<span class=\"string\">\"Referer\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">//判断Referer是否以bank.example开头</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>((refirer != <span class=\"keyword\">null</span>) &amp;&amp; (referer.trim().startsWith(<span class=\"string\">\"bank.example\"</span>)))&#123;</span><br><span class=\"line\"> vhain.doFilter(request, response);</span><br><span class=\"line\"> &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">request.getRequestDispatcher(<span class=\"string\">\"error.jsp\"</span>).forward(request,response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码先取得Referer值，然后进行判断，当其非空并以bank.example开头时，则继续请求，否则的话可能是CSRF攻击，转到error.jsp页面。</p>\n<h2 id=\"2-进一步验证请求中的token\"><a href=\"#2-进一步验证请求中的token\" class=\"headerlink\" title=\"2.进一步验证请求中的token\"></a>2.进一步验证请求中的token</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HttpServletRequest req = (HttpServletRequest)request;</span><br><span class=\"line\">HttpSession s = req.getSession();</span><br><span class=\"line\"><span class=\"comment\">//从session中，得到csrftoken属性</span></span><br><span class=\"line\">String sToken = (String)s.getAttribute(<span class=\"string\">\"csrftoken\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(sToken == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//产生新的token放入session中</span></span><br><span class=\"line\">\tsToken = generateToken();</span><br><span class=\"line\">\ts.setAttribute(<span class=\"string\">\"csrftoken\"</span>, sToken);</span><br><span class=\"line\">\tchain.doFilter(request, response);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从HTTP头中取得csrftoken</span></span><br><span class=\"line\">\tString xhrToken = req.getHeader(<span class=\"string\">\"csrftoken\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//从请求参数中取得csrftoken</span></span><br><span class=\"line\">\tString pToken = req.getParameter(<span class=\"string\">\"csrftoken\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(sToken != <span class=\"keyword\">null</span> &amp;&amp; xhrToken != <span class=\"keyword\">null</span> &amp;&amp; sToken.equals(xhrToken))&#123;</span><br><span class=\"line\">\t\tchain.doFilter(request, response);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\trequest.getRequestDispatcher(<span class=\"string\">\"error.jsp\"</span>).forward(request,response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-在客户端对请求附加token\"><a href=\"#3-在客户端对请求附加token\" class=\"headerlink\" title=\"3.在客户端对请求附加token\"></a>3.在客户端对请求附加token</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendTOken</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tupdateForms();</span><br><span class=\"line\">\tupdateTags();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateForms</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获取所有form元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> forms = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'form'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; forms.length; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> url = forms[i].action;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果这个form的action值为空，则不附加csrftoken</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(url == <span class=\"literal\">null</span> || url == <span class=\"string\">\"\"</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//动态生成input元素，加到 form 之后</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e = docement.createElement(<span class=\"string\">\"input\"</span>);</span><br><span class=\"line\">\t\te.name = <span class=\"string\">\"csrftoken\"</span>;</span><br><span class=\"line\">\t\te.value = token;</span><br><span class=\"line\">\t\te.type = <span class=\"string\">\"hidden\"</span>;</span><br><span class=\"line\">\t\tforms[i].appendChild(e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateTags</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> all = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> len = all.length;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历所有a元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i&lt; len; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e = all[i];</span><br><span class=\"line\">\t\tupdateTag(e, <span class=\"string\">\"href\"</span> , token);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateTag</span>(<span class=\"params\">element, attr, token</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> location = element.getAttribute(attr);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(location != <span class=\"literal\">null</span> &amp;&amp; location != <span class=\"string\">''</span> <span class=\"string\">''</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fragmentIndex = location.indexOf(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fragment = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fragmentIndex != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//url中含有#锚标记</span></span><br><span class=\"line\">\t\t\tfragment = location.substring(fragmentIndex);</span><br><span class=\"line\">\t\t\tlocation = location.substring(<span class=\"number\">0</span>, fragmentIndex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> index = location.indexOf(<span class=\"string\">'?'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(index !== <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//url中已含有其他参数</span></span><br><span class=\"line\">\t\t\tlocation = location + <span class=\"string\">'&amp;csrftoken='</span> + token;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//url中没有其他参数</span></span><br><span class=\"line\">\t\t\tlocation = location + <span class=\"string\">'?csrftoken='</span> + token;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fragment != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tlocation += fragment;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telement.setAttribute(attr, location);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在客户端html中，主要有两个地方需要加上token，一个是表单form，另一个就是a标签。上面这段代码，首先遍历所有的form, 在form最后添加一段<strong>隐藏字段</strong>，把csrftoken放入其中。然后，代码遍历所有的a标签，在其href属性中加入csrftoken参数。 注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。</p>\n<h2 id=\"4-在-HTTP-头中自定义属性\"><a href=\"#4-在-HTTP-头中自定义属性\" class=\"headerlink\" title=\"4. 在 HTTP 头中自定义属性\"></a>4. 在 HTTP 头中自定义属性</h2><pre><code>var plainXhr = dojo.xhr;\n\n// 重写 dojo.xhr 方法\ndojo.xhr = function(method,args,hasBody) {\n   // 确保 header 对象存在\n   args.headers = args.header || {};\n\n   tokenValue = &apos;&lt;%=request.getSession(false).getAttribute(&quot;csrftoken&quot;)%&gt;&apos;;\n   var token = dojo.getObject(&quot;tokenValue&quot;);\n\n   // 把 csrftoken 属性放到头中\n   args.headers[&quot;csrftoken&quot;] = (token) ? token : &quot;  &quot;;\n   return plainXhr(method,args,hasBody);\n};\n</code></pre><p>这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。</p>\n<h1 id=\"四、如何选择CSRF防御方法？\"><a href=\"#四、如何选择CSRF防御方法？\" class=\"headerlink\" title=\"四、如何选择CSRF防御方法？\"></a>四、如何选择CSRF防御方法？</h1><p>目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。</p>\n<p>如果网站是一个现有系统，想要<strong>在最短时间内获得一定程度的 CSRF 的保护</strong>，那么<strong>验证 Referer</strong> 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。</p>\n<p>如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。<br>在这种情况下，你需要<strong>小心规划你网站提供的各种服务</strong>，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。</p>\n<p>如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议<strong>对于重要的服务，可以尽量使用 XMLHttpRequest 来访问</strong>，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。</p>\n<p>最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。</p>\n<h1 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h1><p>可见，CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF 的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token 方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视 CSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低。</p>\n<hr>\n<blockquote>\n<p> <a href=\"https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/\" target=\"_blank\" rel=\"noopener\">参考链接：IBM的技术博客</a></p>\n</blockquote>"},{"title":"简述网络原理和优化","date":"2017-06-06T09:01:19.000Z","_content":"\n\n\n# 1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？\n<!--more-->\n## 1.1 浏览器处理请求\n浏览器开启一个线程处理这个请求，对URL分析判断，如果是HTTP协议，就按Web方式处理。\n\n## 1.2 浏览器处理URL\n调用浏览器内核中的对应方法，比如WebView中的loadUrl方法。\n\n## 1.3 DNS解析\n通过DNS解析，获取域名的IP地址，设置UA等信息发出第二个GET请求。\n\n## 1.4 建立连接\n进行HTTP协议回话，客户端发送报头（请求报头）；\n\n## 1.5 服务器系统响应\n进入到Web服务器上的Web Server， 如Apache 、Tomcat 、 Node.JS 等服务器。\n\n## 1.6 服务器程序处理\n进入部署好的后端应用，如PHP、Java、JavaScript、Python等，找到相应的请求处理。\n\n## 1.7 服务器处理完成，返回数据\n处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，如果一致，则返回304.\n\n## 1.8 浏览器开始下载HTML\n浏览器开始下载HTML文档(响应报头，状态码200)，同时使用缓存。\n\n## 1.9 DOM树建立，加载外部文件\n文档树开始建立，根据标记请求所需指定MIME类型的文件（比如CSS，JS），同时设置Cookie。\n\n## 1.10 页面渲染\n页面开始渲染DOM，JS根据DOM API操作DOM，执行事件绑定等，页面显示完成。\n\n# 2. HTTP状态码\n\n - 100  继续， 一般在发送post请求时， 已发送了http header之后，服务器将返回此信息，表示确认。\n - 200 正常返回信息\n - 201 请求成功并且服务器创建了新的资源\n - 202 服务器已接受请求，但尚未处理\n - 301 永久重定向\n - 302 临时重定向\n - 303 临时重定向，且总是使用GET请求新的URI\n - 304 资源未修改，自从上次请求后，请求的网页未修改过。\n\n - 400 请求格式错误，客户端不应当再犯同样的错误\n - 401 请求未授权\n - 403 禁止访问\n - 404 找不到资源\n \n - 500 服务器内部错误\n - 502 网关错误\n - 503 服务器暂时无法处理请求，可能是过载或者维护\n\n# 3. 前端性能优化\n\n## 3.1 减少http请求次数\nCSS雪碧图，JS、CSS代码压缩，图片压缩；\n\n网页Gzip，CDN托管，data缓存，分离图片服务器。\n\n## 3.2 前端模板优化\n精简HTML标签，避免带宽浪费。\n\n用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。\n\n## 3.3 DOM操作\n用`innerHTML`代替DOM操作，减少DOM操作次数，优化JavaScript性能。\n\n缓存DOM节点查找的结果，减少IO读取操作。\n\n## 3.4 避免直接操作style\n当需要设置的样式很多时，设置className，而非直接操作style。\n\n## 3.5 少用全局变量","source":"_posts/2017-06-06 前端网络原理和优化.md","raw":"---\ntitle: 简述网络原理和优化\ncategories: 笔记\ndate: 2017-06-06 17:01:19\ntags: 学习笔记\n---\n\n\n\n# 1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？\n<!--more-->\n## 1.1 浏览器处理请求\n浏览器开启一个线程处理这个请求，对URL分析判断，如果是HTTP协议，就按Web方式处理。\n\n## 1.2 浏览器处理URL\n调用浏览器内核中的对应方法，比如WebView中的loadUrl方法。\n\n## 1.3 DNS解析\n通过DNS解析，获取域名的IP地址，设置UA等信息发出第二个GET请求。\n\n## 1.4 建立连接\n进行HTTP协议回话，客户端发送报头（请求报头）；\n\n## 1.5 服务器系统响应\n进入到Web服务器上的Web Server， 如Apache 、Tomcat 、 Node.JS 等服务器。\n\n## 1.6 服务器程序处理\n进入部署好的后端应用，如PHP、Java、JavaScript、Python等，找到相应的请求处理。\n\n## 1.7 服务器处理完成，返回数据\n处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，如果一致，则返回304.\n\n## 1.8 浏览器开始下载HTML\n浏览器开始下载HTML文档(响应报头，状态码200)，同时使用缓存。\n\n## 1.9 DOM树建立，加载外部文件\n文档树开始建立，根据标记请求所需指定MIME类型的文件（比如CSS，JS），同时设置Cookie。\n\n## 1.10 页面渲染\n页面开始渲染DOM，JS根据DOM API操作DOM，执行事件绑定等，页面显示完成。\n\n# 2. HTTP状态码\n\n - 100  继续， 一般在发送post请求时， 已发送了http header之后，服务器将返回此信息，表示确认。\n - 200 正常返回信息\n - 201 请求成功并且服务器创建了新的资源\n - 202 服务器已接受请求，但尚未处理\n - 301 永久重定向\n - 302 临时重定向\n - 303 临时重定向，且总是使用GET请求新的URI\n - 304 资源未修改，自从上次请求后，请求的网页未修改过。\n\n - 400 请求格式错误，客户端不应当再犯同样的错误\n - 401 请求未授权\n - 403 禁止访问\n - 404 找不到资源\n \n - 500 服务器内部错误\n - 502 网关错误\n - 503 服务器暂时无法处理请求，可能是过载或者维护\n\n# 3. 前端性能优化\n\n## 3.1 减少http请求次数\nCSS雪碧图，JS、CSS代码压缩，图片压缩；\n\n网页Gzip，CDN托管，data缓存，分离图片服务器。\n\n## 3.2 前端模板优化\n精简HTML标签，避免带宽浪费。\n\n用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。\n\n## 3.3 DOM操作\n用`innerHTML`代替DOM操作，减少DOM操作次数，优化JavaScript性能。\n\n缓存DOM节点查找的结果，减少IO读取操作。\n\n## 3.4 避免直接操作style\n当需要设置的样式很多时，设置className，而非直接操作style。\n\n## 3.5 少用全局变量","slug":"2017-06-06 前端网络原理和优化","published":1,"updated":"2018-12-21T12:18:26.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7m000cjts4jrs2tbbj","content":"<h1 id=\"1-一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？\"><a href=\"#1-一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？\" class=\"headerlink\" title=\"1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？\"></a>1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？</h1><a id=\"more\"></a>\n<h2 id=\"1-1-浏览器处理请求\"><a href=\"#1-1-浏览器处理请求\" class=\"headerlink\" title=\"1.1 浏览器处理请求\"></a>1.1 浏览器处理请求</h2><p>浏览器开启一个线程处理这个请求，对URL分析判断，如果是HTTP协议，就按Web方式处理。</p>\n<h2 id=\"1-2-浏览器处理URL\"><a href=\"#1-2-浏览器处理URL\" class=\"headerlink\" title=\"1.2 浏览器处理URL\"></a>1.2 浏览器处理URL</h2><p>调用浏览器内核中的对应方法，比如WebView中的loadUrl方法。</p>\n<h2 id=\"1-3-DNS解析\"><a href=\"#1-3-DNS解析\" class=\"headerlink\" title=\"1.3 DNS解析\"></a>1.3 DNS解析</h2><p>通过DNS解析，获取域名的IP地址，设置UA等信息发出第二个GET请求。</p>\n<h2 id=\"1-4-建立连接\"><a href=\"#1-4-建立连接\" class=\"headerlink\" title=\"1.4 建立连接\"></a>1.4 建立连接</h2><p>进行HTTP协议回话，客户端发送报头（请求报头）；</p>\n<h2 id=\"1-5-服务器系统响应\"><a href=\"#1-5-服务器系统响应\" class=\"headerlink\" title=\"1.5 服务器系统响应\"></a>1.5 服务器系统响应</h2><p>进入到Web服务器上的Web Server， 如Apache 、Tomcat 、 Node.JS 等服务器。</p>\n<h2 id=\"1-6-服务器程序处理\"><a href=\"#1-6-服务器程序处理\" class=\"headerlink\" title=\"1.6 服务器程序处理\"></a>1.6 服务器程序处理</h2><p>进入部署好的后端应用，如PHP、Java、JavaScript、Python等，找到相应的请求处理。</p>\n<h2 id=\"1-7-服务器处理完成，返回数据\"><a href=\"#1-7-服务器处理完成，返回数据\" class=\"headerlink\" title=\"1.7 服务器处理完成，返回数据\"></a>1.7 服务器处理完成，返回数据</h2><p>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，如果一致，则返回304.</p>\n<h2 id=\"1-8-浏览器开始下载HTML\"><a href=\"#1-8-浏览器开始下载HTML\" class=\"headerlink\" title=\"1.8 浏览器开始下载HTML\"></a>1.8 浏览器开始下载HTML</h2><p>浏览器开始下载HTML文档(响应报头，状态码200)，同时使用缓存。</p>\n<h2 id=\"1-9-DOM树建立，加载外部文件\"><a href=\"#1-9-DOM树建立，加载外部文件\" class=\"headerlink\" title=\"1.9 DOM树建立，加载外部文件\"></a>1.9 DOM树建立，加载外部文件</h2><p>文档树开始建立，根据标记请求所需指定MIME类型的文件（比如CSS，JS），同时设置Cookie。</p>\n<h2 id=\"1-10-页面渲染\"><a href=\"#1-10-页面渲染\" class=\"headerlink\" title=\"1.10 页面渲染\"></a>1.10 页面渲染</h2><p>页面开始渲染DOM，JS根据DOM API操作DOM，执行事件绑定等，页面显示完成。</p>\n<h1 id=\"2-HTTP状态码\"><a href=\"#2-HTTP状态码\" class=\"headerlink\" title=\"2. HTTP状态码\"></a>2. HTTP状态码</h1><ul>\n<li>100  继续， 一般在发送post请求时， 已发送了http header之后，服务器将返回此信息，表示确认。</li>\n<li>200 正常返回信息</li>\n<li>201 请求成功并且服务器创建了新的资源</li>\n<li>202 服务器已接受请求，但尚未处理</li>\n<li>301 永久重定向</li>\n<li>302 临时重定向</li>\n<li>303 临时重定向，且总是使用GET请求新的URI</li>\n<li><p>304 资源未修改，自从上次请求后，请求的网页未修改过。</p>\n</li>\n<li><p>400 请求格式错误，客户端不应当再犯同样的错误</p>\n</li>\n<li>401 请求未授权</li>\n<li>403 禁止访问</li>\n<li><p>404 找不到资源</p>\n</li>\n<li><p>500 服务器内部错误</p>\n</li>\n<li>502 网关错误</li>\n<li>503 服务器暂时无法处理请求，可能是过载或者维护</li>\n</ul>\n<h1 id=\"3-前端性能优化\"><a href=\"#3-前端性能优化\" class=\"headerlink\" title=\"3. 前端性能优化\"></a>3. 前端性能优化</h1><h2 id=\"3-1-减少http请求次数\"><a href=\"#3-1-减少http请求次数\" class=\"headerlink\" title=\"3.1 减少http请求次数\"></a>3.1 减少http请求次数</h2><p>CSS雪碧图，JS、CSS代码压缩，图片压缩；</p>\n<p>网页Gzip，CDN托管，data缓存，分离图片服务器。</p>\n<h2 id=\"3-2-前端模板优化\"><a href=\"#3-2-前端模板优化\" class=\"headerlink\" title=\"3.2 前端模板优化\"></a>3.2 前端模板优化</h2><p>精简HTML标签，避免带宽浪费。</p>\n<p>用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。</p>\n<h2 id=\"3-3-DOM操作\"><a href=\"#3-3-DOM操作\" class=\"headerlink\" title=\"3.3 DOM操作\"></a>3.3 DOM操作</h2><p>用<code>innerHTML</code>代替DOM操作，减少DOM操作次数，优化JavaScript性能。</p>\n<p>缓存DOM节点查找的结果，减少IO读取操作。</p>\n<h2 id=\"3-4-避免直接操作style\"><a href=\"#3-4-避免直接操作style\" class=\"headerlink\" title=\"3.4 避免直接操作style\"></a>3.4 避免直接操作style</h2><p>当需要设置的样式很多时，设置className，而非直接操作style。</p>\n<h2 id=\"3-5-少用全局变量\"><a href=\"#3-5-少用全局变量\" class=\"headerlink\" title=\"3.5 少用全局变量\"></a>3.5 少用全局变量</h2>","site":{"data":{}},"excerpt":"<h1 id=\"1-一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？\"><a href=\"#1-一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？\" class=\"headerlink\" title=\"1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？\"></a>1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？</h1>","more":"<h2 id=\"1-1-浏览器处理请求\"><a href=\"#1-1-浏览器处理请求\" class=\"headerlink\" title=\"1.1 浏览器处理请求\"></a>1.1 浏览器处理请求</h2><p>浏览器开启一个线程处理这个请求，对URL分析判断，如果是HTTP协议，就按Web方式处理。</p>\n<h2 id=\"1-2-浏览器处理URL\"><a href=\"#1-2-浏览器处理URL\" class=\"headerlink\" title=\"1.2 浏览器处理URL\"></a>1.2 浏览器处理URL</h2><p>调用浏览器内核中的对应方法，比如WebView中的loadUrl方法。</p>\n<h2 id=\"1-3-DNS解析\"><a href=\"#1-3-DNS解析\" class=\"headerlink\" title=\"1.3 DNS解析\"></a>1.3 DNS解析</h2><p>通过DNS解析，获取域名的IP地址，设置UA等信息发出第二个GET请求。</p>\n<h2 id=\"1-4-建立连接\"><a href=\"#1-4-建立连接\" class=\"headerlink\" title=\"1.4 建立连接\"></a>1.4 建立连接</h2><p>进行HTTP协议回话，客户端发送报头（请求报头）；</p>\n<h2 id=\"1-5-服务器系统响应\"><a href=\"#1-5-服务器系统响应\" class=\"headerlink\" title=\"1.5 服务器系统响应\"></a>1.5 服务器系统响应</h2><p>进入到Web服务器上的Web Server， 如Apache 、Tomcat 、 Node.JS 等服务器。</p>\n<h2 id=\"1-6-服务器程序处理\"><a href=\"#1-6-服务器程序处理\" class=\"headerlink\" title=\"1.6 服务器程序处理\"></a>1.6 服务器程序处理</h2><p>进入部署好的后端应用，如PHP、Java、JavaScript、Python等，找到相应的请求处理。</p>\n<h2 id=\"1-7-服务器处理完成，返回数据\"><a href=\"#1-7-服务器处理完成，返回数据\" class=\"headerlink\" title=\"1.7 服务器处理完成，返回数据\"></a>1.7 服务器处理完成，返回数据</h2><p>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，如果一致，则返回304.</p>\n<h2 id=\"1-8-浏览器开始下载HTML\"><a href=\"#1-8-浏览器开始下载HTML\" class=\"headerlink\" title=\"1.8 浏览器开始下载HTML\"></a>1.8 浏览器开始下载HTML</h2><p>浏览器开始下载HTML文档(响应报头，状态码200)，同时使用缓存。</p>\n<h2 id=\"1-9-DOM树建立，加载外部文件\"><a href=\"#1-9-DOM树建立，加载外部文件\" class=\"headerlink\" title=\"1.9 DOM树建立，加载外部文件\"></a>1.9 DOM树建立，加载外部文件</h2><p>文档树开始建立，根据标记请求所需指定MIME类型的文件（比如CSS，JS），同时设置Cookie。</p>\n<h2 id=\"1-10-页面渲染\"><a href=\"#1-10-页面渲染\" class=\"headerlink\" title=\"1.10 页面渲染\"></a>1.10 页面渲染</h2><p>页面开始渲染DOM，JS根据DOM API操作DOM，执行事件绑定等，页面显示完成。</p>\n<h1 id=\"2-HTTP状态码\"><a href=\"#2-HTTP状态码\" class=\"headerlink\" title=\"2. HTTP状态码\"></a>2. HTTP状态码</h1><ul>\n<li>100  继续， 一般在发送post请求时， 已发送了http header之后，服务器将返回此信息，表示确认。</li>\n<li>200 正常返回信息</li>\n<li>201 请求成功并且服务器创建了新的资源</li>\n<li>202 服务器已接受请求，但尚未处理</li>\n<li>301 永久重定向</li>\n<li>302 临时重定向</li>\n<li>303 临时重定向，且总是使用GET请求新的URI</li>\n<li><p>304 资源未修改，自从上次请求后，请求的网页未修改过。</p>\n</li>\n<li><p>400 请求格式错误，客户端不应当再犯同样的错误</p>\n</li>\n<li>401 请求未授权</li>\n<li>403 禁止访问</li>\n<li><p>404 找不到资源</p>\n</li>\n<li><p>500 服务器内部错误</p>\n</li>\n<li>502 网关错误</li>\n<li>503 服务器暂时无法处理请求，可能是过载或者维护</li>\n</ul>\n<h1 id=\"3-前端性能优化\"><a href=\"#3-前端性能优化\" class=\"headerlink\" title=\"3. 前端性能优化\"></a>3. 前端性能优化</h1><h2 id=\"3-1-减少http请求次数\"><a href=\"#3-1-减少http请求次数\" class=\"headerlink\" title=\"3.1 减少http请求次数\"></a>3.1 减少http请求次数</h2><p>CSS雪碧图，JS、CSS代码压缩，图片压缩；</p>\n<p>网页Gzip，CDN托管，data缓存，分离图片服务器。</p>\n<h2 id=\"3-2-前端模板优化\"><a href=\"#3-2-前端模板优化\" class=\"headerlink\" title=\"3.2 前端模板优化\"></a>3.2 前端模板优化</h2><p>精简HTML标签，避免带宽浪费。</p>\n<p>用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。</p>\n<h2 id=\"3-3-DOM操作\"><a href=\"#3-3-DOM操作\" class=\"headerlink\" title=\"3.3 DOM操作\"></a>3.3 DOM操作</h2><p>用<code>innerHTML</code>代替DOM操作，减少DOM操作次数，优化JavaScript性能。</p>\n<p>缓存DOM节点查找的结果，减少IO读取操作。</p>\n<h2 id=\"3-4-避免直接操作style\"><a href=\"#3-4-避免直接操作style\" class=\"headerlink\" title=\"3.4 避免直接操作style\"></a>3.4 避免直接操作style</h2><p>当需要设置的样式很多时，设置className，而非直接操作style。</p>\n<h2 id=\"3-5-少用全局变量\"><a href=\"#3-5-少用全局变量\" class=\"headerlink\" title=\"3.5 少用全局变量\"></a>3.5 少用全局变量</h2>"},{"title":"React项目中的高频ES6语法","date":"2017-07-08T08:06:44.000Z","keywords":"前端 React","_content":"\n\n---\n在学习React过程中，注意到无论是GitHub上的Demo还是React相关文档，ES6语法都有大量使用。如果不了解其中一些语法，学习曲线就会越来越陡峭。但是要系统学习ES6，又会消耗大量时间。\n\n在这篇博客里，我把一些常用的ES6语法做一些总结，以更快更好地理解React中的概念和用法。\n\n<!--more-->\n\n在线练习ES6的工具：[ES6 fiddle](http://www.es6fiddle.net)\n\n--- \n\n## 1. let & const\nES6的两个新关键字，主要是引入了块级作用域，不存在变量提升，不允许重复定义等特性，减少了ES5中很容易踩到的地雷。const用来定义常量，不允许后期修改赋值。\n参考文档：[阮一峰的博客](http://es6.ruanyifeng.com/#docs/let)\n\n## 2.解构赋值\n\n - 常规用法：\n\n``` js\n\tlet {x} = {x:1, y:2}\n\tlet { PropTypes } = React\n```\n\t\n这里是对象的解构赋值，等同于`let PropTypes = React.PropTypes`\n> 这里其实包含了两步：\n> \n> 1. 声明变量PropTypes;\n> 2. 给其赋值为React.PropTypes。\n\n所以等效于这样的写法：\n\n\t```\n\t    let PropTypes\n\t    { PropTypes } = React;\n\t```\n\n - 可以同时写多个变量：\n \n``` js\n    let { PropTypes, Component } = React;\n```\n\n - 如果想定义的变量名和属性名不一样：\n \n``` js\n    //声明x1变量，赋值为1. \n    //x是模式，不是变量也不会被赋值\n    let { x : x1 } = { x:1, y:2 }\n```\n  \n\n - **对象， 数组， 字符串等都有解构赋值的用法。**\n \n - 参考文档：[解构赋值](http://es6.ruanyifeng.com/#docs/destructuring)\n\n## 3.对象的拓展\n### 3.1 属性的简洁表达式\n\n    let x = '123';\n    //等同于：let obj = { x: x, y: '33}\n    let obj = {x, y: '33' };\n   \n### 3.2 方法名的简写\n```\n    let User = {\n\t    method (){   //等同于method: function(){...}\n\t\t    //...\n\t    }\n    }\n```\n\n### 3.3属性名表达式\n\n``` js\n    let key = 'id';\n    let obj = {\n\t\t    [key] : '1010', //注意方括号\n\t\t    ['use' + 'name' ]: 'x'\n\t}\n```\n\n把表达式写在 [] 中， 表达式的值作为字段名称：\n\n``` js\n    let obj = {\n\t    id : '1010',\n\t    usename: 'x'\n\t}\n```\n**注意**：属性名表达式与属性名简写不能同时使用：\n\n``` js\n    let key = 'id';\n    let id = '1010';\n    let obj ={\n\t    [key]\n\t}  //Error!\n```\n\n## 4. ES6 Class语法\n使用ES6语法定义一个React组件：\n\n``` jsx\nexport class Counter extends React.Component{\n\tconstructor(props){\n\t\tsuper(props);\n\t\tthis.state = {count: props.initialCount};\n\t\tthis.tick = this.tick.bind(this);\n\t}\n\n\ttick(){\n\t\tthis.setState({count: this.state.count + 1});\n\t}\n\trender(){\n\t\t\treturn (\n\t\t\t\t<div onClick = {this.tick}\n\t\t\t\t</div>\n\t\t\t);\n\t}\n}\n\nCounter.propTypes = { initialCount : Reart.PropTypes.number };\n\nCounter.defaultProps = { initialCount: 0 };\n```\n\n**注意**：\n\n1. ES6的继承语法： extends关键字；\n2. 各个方法使用了方法简写，如tick(){}和render(){}, 方法之间不加 “,”；\n3. `constructor` 是构造函数， 可以替代getInitialState ； \n4. 构造函数内需要调用父类的构造函数：`super(props)` , 否则就会报错。因为子类没有自身的`this` 对象，需要从父类继承。\n5. `this.tick = this.tick.bind(this)`中， 使用**bind**来绑定执行作用域（使用React.createClass是自动绑定的), 也可以在render中监听事件的位置，使用bind(this):\n\t\n\t``` jsx\n    <div onClick= {this.tick.bind(this)}>\n\t      Clicks: {this.state.count}\n    </div>\n\t```    \n**官方建议统一写在constructor中，这样子该方法就只需绑定一次。**\n6. 除了使用bind, 还可以使用箭头函数：\n``` jsx\n\t<div onClick = {() => this.tick()}>\n\t\tClicks: {this.state.count}\n\t</div>\n```\n> 箭头函数的特性：\n> 函数体内的this就是定义是的对象， 而非调用时所在的对象。箭头函数的this指向是固定的， 而普通函数是可变的。\n\n## 5. 箭头函数 \n\n - ES6允许使用 `=>` 来定义函数：\n\n\t``` js\n\tlet f = v => v+2\n\t//等同于\n\tlet f = function(v){\n\t\treturn v + 2;\n\t}\t\n\t```\n\n - 如果有多个参数：\n\n\t``` js\n\t\tlet f = (x ,y) => x + y;\n\t``` \n\n - 函数有多条语句， 用大括号包装：\n\n\t``` js\n\t\tlet f = (x,y) => {\n\t\t\tx = x + 11;\n\t\t\ty = y + 33;\n\t\t\treturn x + y;\n\t\t}\t\n\t```\n\n> 箭头函数的this指向能保持不变， 不是因为内部有绑定机制， 而是因为，**箭头函数没有自己的this， 导致代码内的this就是外层代码块的this。**\n\n - 参考文档： [箭头函数](#)\n\n## 6. export & import\n - export用于输出模块对外的接口， import用于导入其他模块提供的功能。 \n \n``` js\nexport let client = \"App\"\t//输出变量\nexport function mul(x, y){\t//输出函数\n\treturn x + y;\n}\nexport class Toast(){}\t\t//输出类\t\n```\n\n - 也可以统一输出：\n \n``` js\n\t//文件名： Util.js\n\tlet client = 'App';\n\tfunction mul (x , y){\n\t\treturn x + y;\n\t}\n\texport { client, mul }\t\n```\n\n- 那么别的组件就要这样导入它：\n\n``` js\n\timport {client, mul} from './Util.js'\n```\n\n- 还可以打包导入：\n``` js\n\timport * as U from './Util.js'\n\tU.client //使用U\n```\n\n- 常用的 `export default` 命令， 用于输出默认的方法， 变量或类：\n``` js\n\texport default React.createClass({\n\t\t//...\n\t})\t\n```\n- 引入的时候就更方便， 可以随意指定名称：\n``` js\n\timport Tab from 'tab'; \n```\n- 参考文档：[export&import](#)\n\n## 7. 对象的拓展运算符: “...”\n拓展运算符在Redux的示例Demo中很常见。\n\n- 拓展运算符可以用来合并两个对象：\n``` js\n\t//state = { name: 'y' }\n\treturn {...state, name: 'x', id: 101 }\n\t//返回 { name: 'x', id: 101 }\n```\n\t> 上面代码有两个过程:1.去除state对象的所有可比案例属性， 拷贝到当前对象上；\n\t\t\t\t\t  2.如果自定义的属性在后面， 拓展运算符的同名属性会被覆盖。\n\n- 这种用法等同于 Object.assign:\n\n``` js\n\t//assign字面意思为分配\n\tObject.assign({}, state, {name: 'x', id:101})\n``` \n\n- 使用拓展运算符需要安装`transform-object-rest-spread`插件， 然后在babel中配置。 配置如下：\n\n``` js\ntest: /\\.js$/,\nexclude: /node_modules/,\nloader: 'babel',\nquery:{\n    presets: ['react', 'es2015'],\n    plugins: [\"transform-object-rest-spread\"]\n}\n```\n\n- 参考文档：[ES6拓展运算符](#)\n\n---\nThe End.\n","source":"_posts/2017-07-08 React项目中的高频ES6语法.md","raw":"---\ntitle: React项目中的高频ES6语法\ndate: 2017-07-08 16:06:44\ncategories: 技术\nkeywords: 前端 React\n---\n\n\n---\n在学习React过程中，注意到无论是GitHub上的Demo还是React相关文档，ES6语法都有大量使用。如果不了解其中一些语法，学习曲线就会越来越陡峭。但是要系统学习ES6，又会消耗大量时间。\n\n在这篇博客里，我把一些常用的ES6语法做一些总结，以更快更好地理解React中的概念和用法。\n\n<!--more-->\n\n在线练习ES6的工具：[ES6 fiddle](http://www.es6fiddle.net)\n\n--- \n\n## 1. let & const\nES6的两个新关键字，主要是引入了块级作用域，不存在变量提升，不允许重复定义等特性，减少了ES5中很容易踩到的地雷。const用来定义常量，不允许后期修改赋值。\n参考文档：[阮一峰的博客](http://es6.ruanyifeng.com/#docs/let)\n\n## 2.解构赋值\n\n - 常规用法：\n\n``` js\n\tlet {x} = {x:1, y:2}\n\tlet { PropTypes } = React\n```\n\t\n这里是对象的解构赋值，等同于`let PropTypes = React.PropTypes`\n> 这里其实包含了两步：\n> \n> 1. 声明变量PropTypes;\n> 2. 给其赋值为React.PropTypes。\n\n所以等效于这样的写法：\n\n\t```\n\t    let PropTypes\n\t    { PropTypes } = React;\n\t```\n\n - 可以同时写多个变量：\n \n``` js\n    let { PropTypes, Component } = React;\n```\n\n - 如果想定义的变量名和属性名不一样：\n \n``` js\n    //声明x1变量，赋值为1. \n    //x是模式，不是变量也不会被赋值\n    let { x : x1 } = { x:1, y:2 }\n```\n  \n\n - **对象， 数组， 字符串等都有解构赋值的用法。**\n \n - 参考文档：[解构赋值](http://es6.ruanyifeng.com/#docs/destructuring)\n\n## 3.对象的拓展\n### 3.1 属性的简洁表达式\n\n    let x = '123';\n    //等同于：let obj = { x: x, y: '33}\n    let obj = {x, y: '33' };\n   \n### 3.2 方法名的简写\n```\n    let User = {\n\t    method (){   //等同于method: function(){...}\n\t\t    //...\n\t    }\n    }\n```\n\n### 3.3属性名表达式\n\n``` js\n    let key = 'id';\n    let obj = {\n\t\t    [key] : '1010', //注意方括号\n\t\t    ['use' + 'name' ]: 'x'\n\t}\n```\n\n把表达式写在 [] 中， 表达式的值作为字段名称：\n\n``` js\n    let obj = {\n\t    id : '1010',\n\t    usename: 'x'\n\t}\n```\n**注意**：属性名表达式与属性名简写不能同时使用：\n\n``` js\n    let key = 'id';\n    let id = '1010';\n    let obj ={\n\t    [key]\n\t}  //Error!\n```\n\n## 4. ES6 Class语法\n使用ES6语法定义一个React组件：\n\n``` jsx\nexport class Counter extends React.Component{\n\tconstructor(props){\n\t\tsuper(props);\n\t\tthis.state = {count: props.initialCount};\n\t\tthis.tick = this.tick.bind(this);\n\t}\n\n\ttick(){\n\t\tthis.setState({count: this.state.count + 1});\n\t}\n\trender(){\n\t\t\treturn (\n\t\t\t\t<div onClick = {this.tick}\n\t\t\t\t</div>\n\t\t\t);\n\t}\n}\n\nCounter.propTypes = { initialCount : Reart.PropTypes.number };\n\nCounter.defaultProps = { initialCount: 0 };\n```\n\n**注意**：\n\n1. ES6的继承语法： extends关键字；\n2. 各个方法使用了方法简写，如tick(){}和render(){}, 方法之间不加 “,”；\n3. `constructor` 是构造函数， 可以替代getInitialState ； \n4. 构造函数内需要调用父类的构造函数：`super(props)` , 否则就会报错。因为子类没有自身的`this` 对象，需要从父类继承。\n5. `this.tick = this.tick.bind(this)`中， 使用**bind**来绑定执行作用域（使用React.createClass是自动绑定的), 也可以在render中监听事件的位置，使用bind(this):\n\t\n\t``` jsx\n    <div onClick= {this.tick.bind(this)}>\n\t      Clicks: {this.state.count}\n    </div>\n\t```    \n**官方建议统一写在constructor中，这样子该方法就只需绑定一次。**\n6. 除了使用bind, 还可以使用箭头函数：\n``` jsx\n\t<div onClick = {() => this.tick()}>\n\t\tClicks: {this.state.count}\n\t</div>\n```\n> 箭头函数的特性：\n> 函数体内的this就是定义是的对象， 而非调用时所在的对象。箭头函数的this指向是固定的， 而普通函数是可变的。\n\n## 5. 箭头函数 \n\n - ES6允许使用 `=>` 来定义函数：\n\n\t``` js\n\tlet f = v => v+2\n\t//等同于\n\tlet f = function(v){\n\t\treturn v + 2;\n\t}\t\n\t```\n\n - 如果有多个参数：\n\n\t``` js\n\t\tlet f = (x ,y) => x + y;\n\t``` \n\n - 函数有多条语句， 用大括号包装：\n\n\t``` js\n\t\tlet f = (x,y) => {\n\t\t\tx = x + 11;\n\t\t\ty = y + 33;\n\t\t\treturn x + y;\n\t\t}\t\n\t```\n\n> 箭头函数的this指向能保持不变， 不是因为内部有绑定机制， 而是因为，**箭头函数没有自己的this， 导致代码内的this就是外层代码块的this。**\n\n - 参考文档： [箭头函数](#)\n\n## 6. export & import\n - export用于输出模块对外的接口， import用于导入其他模块提供的功能。 \n \n``` js\nexport let client = \"App\"\t//输出变量\nexport function mul(x, y){\t//输出函数\n\treturn x + y;\n}\nexport class Toast(){}\t\t//输出类\t\n```\n\n - 也可以统一输出：\n \n``` js\n\t//文件名： Util.js\n\tlet client = 'App';\n\tfunction mul (x , y){\n\t\treturn x + y;\n\t}\n\texport { client, mul }\t\n```\n\n- 那么别的组件就要这样导入它：\n\n``` js\n\timport {client, mul} from './Util.js'\n```\n\n- 还可以打包导入：\n``` js\n\timport * as U from './Util.js'\n\tU.client //使用U\n```\n\n- 常用的 `export default` 命令， 用于输出默认的方法， 变量或类：\n``` js\n\texport default React.createClass({\n\t\t//...\n\t})\t\n```\n- 引入的时候就更方便， 可以随意指定名称：\n``` js\n\timport Tab from 'tab'; \n```\n- 参考文档：[export&import](#)\n\n## 7. 对象的拓展运算符: “...”\n拓展运算符在Redux的示例Demo中很常见。\n\n- 拓展运算符可以用来合并两个对象：\n``` js\n\t//state = { name: 'y' }\n\treturn {...state, name: 'x', id: 101 }\n\t//返回 { name: 'x', id: 101 }\n```\n\t> 上面代码有两个过程:1.去除state对象的所有可比案例属性， 拷贝到当前对象上；\n\t\t\t\t\t  2.如果自定义的属性在后面， 拓展运算符的同名属性会被覆盖。\n\n- 这种用法等同于 Object.assign:\n\n``` js\n\t//assign字面意思为分配\n\tObject.assign({}, state, {name: 'x', id:101})\n``` \n\n- 使用拓展运算符需要安装`transform-object-rest-spread`插件， 然后在babel中配置。 配置如下：\n\n``` js\ntest: /\\.js$/,\nexclude: /node_modules/,\nloader: 'babel',\nquery:{\n    presets: ['react', 'es2015'],\n    plugins: [\"transform-object-rest-spread\"]\n}\n```\n\n- 参考文档：[ES6拓展运算符](#)\n\n---\nThe End.\n","slug":"2017-07-08 React项目中的高频ES6语法","published":1,"updated":"2018-12-21T12:18:45.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7p000gjts4xe2g8vsf","content":"<hr>\n<p>在学习React过程中，注意到无论是GitHub上的Demo还是React相关文档，ES6语法都有大量使用。如果不了解其中一些语法，学习曲线就会越来越陡峭。但是要系统学习ES6，又会消耗大量时间。</p>\n<p>在这篇博客里，我把一些常用的ES6语法做一些总结，以更快更好地理解React中的概念和用法。</p>\n<a id=\"more\"></a>\n<p>在线练习ES6的工具：<a href=\"http://www.es6fiddle.net\" target=\"_blank\" rel=\"noopener\">ES6 fiddle</a></p>\n<hr>\n<h2 id=\"1-let-amp-const\"><a href=\"#1-let-amp-const\" class=\"headerlink\" title=\"1. let &amp; const\"></a>1. let &amp; const</h2><p>ES6的两个新关键字，主要是引入了块级作用域，不存在变量提升，不允许重复定义等特性，减少了ES5中很容易踩到的地雷。const用来定义常量，不允许后期修改赋值。<br>参考文档：<a href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener\">阮一峰的博客</a></p>\n<h2 id=\"2-解构赋值\"><a href=\"#2-解构赋值\" class=\"headerlink\" title=\"2.解构赋值\"></a>2.解构赋值</h2><ul>\n<li>常规用法：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;x&#125; = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>, <span class=\"attr\">y</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; PropTypes &#125; = React</span><br></pre></td></tr></table></figure>\n<p>这里是对象的解构赋值，等同于<code>let PropTypes = React.PropTypes</code></p>\n<blockquote>\n<p>这里其实包含了两步：</p>\n<ol>\n<li>声明变量PropTypes;</li>\n<li>给其赋值为React.PropTypes。</li>\n</ol>\n</blockquote>\n<p>所以等效于这样的写法：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let PropTypes</span><br><span class=\"line\">&#123; PropTypes &#125; = React;</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>可以同时写多个变量：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; PropTypes, Component &#125; = React;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果想定义的变量名和属性名不一样：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明x1变量，赋值为1. </span></span><br><span class=\"line\"><span class=\"comment\">//x是模式，不是变量也不会被赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">x</span> : x1 &#125; = &#123; <span class=\"attr\">x</span>:<span class=\"number\">1</span>, <span class=\"attr\">y</span>:<span class=\"number\">2</span> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>对象， 数组， 字符串等都有解构赋值的用法。</strong></p>\n</li>\n<li><p>参考文档：<a href=\"http://es6.ruanyifeng.com/#docs/destructuring\" target=\"_blank\" rel=\"noopener\">解构赋值</a></p>\n</li>\n</ul>\n<h2 id=\"3-对象的拓展\"><a href=\"#3-对象的拓展\" class=\"headerlink\" title=\"3.对象的拓展\"></a>3.对象的拓展</h2><h3 id=\"3-1-属性的简洁表达式\"><a href=\"#3-1-属性的简洁表达式\" class=\"headerlink\" title=\"3.1 属性的简洁表达式\"></a>3.1 属性的简洁表达式</h3><pre><code>let x = &apos;123&apos;;\n//等同于：let obj = { x: x, y: &apos;33}\nlet obj = {x, y: &apos;33&apos; };\n</code></pre><h3 id=\"3-2-方法名的简写\"><a href=\"#3-2-方法名的简写\" class=\"headerlink\" title=\"3.2 方法名的简写\"></a>3.2 方法名的简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let User = &#123;</span><br><span class=\"line\"> method ()&#123;   //等同于method: function()&#123;...&#125;</span><br><span class=\"line\">  //...</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3属性名表达式\"><a href=\"#3-3属性名表达式\" class=\"headerlink\" title=\"3.3属性名表达式\"></a>3.3属性名表达式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">let</span> key = <span class=\"string\">'id'</span>;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\t    [key] : <span class=\"string\">'1010'</span>, <span class=\"comment\">//注意方括号</span></span><br><span class=\"line\">\t    [<span class=\"string\">'use'</span> + <span class=\"string\">'name'</span> ]: <span class=\"string\">'x'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把表达式写在 [] 中， 表达式的值作为字段名称：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    id : <span class=\"string\">'1010'</span>,</span><br><span class=\"line\">    usename: <span class=\"string\">'x'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：属性名表达式与属性名简写不能同时使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">let</span> key = <span class=\"string\">'id'</span>;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> id = <span class=\"string\">'1010'</span>;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> obj =&#123;</span><br><span class=\"line\">    [key]</span><br><span class=\"line\">&#125;  <span class=\"comment\">//Error!</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-ES6-Class语法\"><a href=\"#4-ES6-Class语法\" class=\"headerlink\" title=\"4. ES6 Class语法\"></a>4. ES6 Class语法</h2><p>使用ES6语法定义一个React组件：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">count</span>: props.initialCount&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.tick = <span class=\"keyword\">this</span>.tick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttick()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trender()&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t\t\t&lt;div onClick = &#123;<span class=\"keyword\">this</span>.tick&#125;</span><br><span class=\"line\">\t\t\t\t&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t);</span></span><br><span class=\"line\"><span class=\"regexp\">\t&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Counter.propTypes = &#123; initialCount : Reart.PropTypes.number &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Counter.defaultProps = &#123; initialCount: 0 &#125;;</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：</p>\n<ol>\n<li>ES6的继承语法： extends关键字；</li>\n<li>各个方法使用了方法简写，如tick(){}和render(){}, 方法之间不加 “,”；</li>\n<li><code>constructor</code> 是构造函数， 可以替代getInitialState ； </li>\n<li>构造函数内需要调用父类的构造函数：<code>super(props)</code> , 否则就会报错。因为子类没有自身的<code>this</code> 对象，需要从父类继承。</li>\n<li><p><code>this.tick = this.tick.bind(this)</code>中， 使用<strong>bind</strong>来绑定执行作用域（使用React.createClass是自动绑定的), 也可以在render中监听事件的位置，使用bind(this):</p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;div onClick= &#123;<span class=\"keyword\">this</span>.tick.bind(<span class=\"keyword\">this</span>)&#125;&gt;</span><br><span class=\"line\">\t      Clicks: &#123;<span class=\"keyword\">this</span>.state.count&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t```    </span></span><br><span class=\"line\"><span class=\"regexp\">**官方建议统一写在constructor中，这样子该方法就只需绑定一次。**</span></span><br><span class=\"line\"><span class=\"regexp\">6. 除了使用bind, 还可以使用箭头函数：</span></span><br><span class=\"line\"><span class=\"regexp\">``` jsx</span></span><br><span class=\"line\"><span class=\"regexp\">\t&lt;div onClick = &#123;() =&gt; this.tick()&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\tClicks: &#123;this.state.count&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">\t&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>箭头函数的特性：<br>函数体内的this就是定义是的对象， 而非调用时所在的对象。箭头函数的this指向是固定的， 而普通函数是可变的。</p>\n</blockquote>\n<h2 id=\"5-箭头函数\"><a href=\"#5-箭头函数\" class=\"headerlink\" title=\"5. 箭头函数\"></a>5. 箭头函数</h2><ul>\n<li><p>ES6允许使用 <code>=&gt;</code> 来定义函数：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v+<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">//等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v + <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果有多个参数：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">let</span> f = <span class=\"function\">(<span class=\"params\">x ,y</span>) =&gt;</span> x + y;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- 函数有多条语句， 用大括号包装：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> js</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> f = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\tx = x + <span class=\"number\">11</span>;</span><br><span class=\"line\">\t\ty = y + <span class=\"number\">33</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>箭头函数的this指向能保持不变， 不是因为内部有绑定机制， 而是因为，<strong>箭头函数没有自己的this， 导致代码内的this就是外层代码块的this。</strong></p>\n</blockquote>\n<ul>\n<li>参考文档： <a href=\"#\">箭头函数</a></li>\n</ul>\n<h2 id=\"6-export-amp-import\"><a href=\"#6-export-amp-import\" class=\"headerlink\" title=\"6. export &amp; import\"></a>6. export &amp; import</h2><ul>\n<li>export用于输出模块对外的接口， import用于导入其他模块提供的功能。 </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> client = <span class=\"string\">\"App\"</span>\t<span class=\"comment\">//输出变量</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mul</span>(<span class=\"params\">x, y</span>)</span>&#123;\t<span class=\"comment\">//输出函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toast</span>()</span>&#123;&#125;\t\t<span class=\"comment\">//输出类</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>也可以统一输出：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//文件名： Util.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> client = <span class=\"string\">'App'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mul</span> (<span class=\"params\">x , y</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; client, mul &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>那么别的组件就要这样导入它：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;client, mul&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./Util.js'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>还可以打包导入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> U <span class=\"keyword\">from</span> <span class=\"string\">'./Util.js'</span></span><br><span class=\"line\">U.client <span class=\"comment\">//使用U</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用的 <code>export default</code> 命令， 用于输出默认的方法， 变量或类：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> React.createClass(&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入的时候就更方便， 可以随意指定名称：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Tab <span class=\"keyword\">from</span> <span class=\"string\">'tab'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>参考文档：<a href=\"#\">export&amp;import</a></p>\n</li>\n</ul>\n<h2 id=\"7-对象的拓展运算符-“…”\"><a href=\"#7-对象的拓展运算符-“…”\" class=\"headerlink\" title=\"7. 对象的拓展运算符: “…”\"></a>7. 对象的拓展运算符: “…”</h2><p>拓展运算符在Redux的示例Demo中很常见。</p>\n<ul>\n<li><p>拓展运算符可以用来合并两个对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//state = &#123; name: 'y' &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;...state, <span class=\"attr\">name</span>: <span class=\"string\">'x'</span>, <span class=\"attr\">id</span>: <span class=\"number\">101</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">//返回 &#123; name: 'x', id: 101 &#125;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面代码有两个过程:1.去除state对象的所有可比案例属性， 拷贝到当前对象上；</p>\n<pre><code>2.如果自定义的属性在后面， 拓展运算符的同名属性会被覆盖。\n</code></pre></blockquote>\n</li>\n<li><p>这种用法等同于 Object.assign:</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">//assign字面意思为分配</span></span><br><span class=\"line\">\t<span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;<span class=\"attr\">name</span>: <span class=\"string\">'x'</span>, <span class=\"attr\">id</span>:<span class=\"number\">101</span>&#125;)</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- 使用拓展运算符需要安装`</span>transform-object-rest-spread<span class=\"string\">`插件， 然后在babel中配置。 配置如下：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> js</span><br><span class=\"line\">test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">loader: <span class=\"string\">'babel'</span>,</span><br><span class=\"line\">query:&#123;</span><br><span class=\"line\">    presets: [<span class=\"string\">'react'</span>, <span class=\"string\">'es2015'</span>],</span><br><span class=\"line\">    plugins: [<span class=\"string\">\"transform-object-rest-spread\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参考文档：<a href=\"#\">ES6拓展运算符</a></li>\n</ul>\n<hr>\n<p>The End.</p>\n","site":{"data":{}},"excerpt":"<hr>\n<p>在学习React过程中，注意到无论是GitHub上的Demo还是React相关文档，ES6语法都有大量使用。如果不了解其中一些语法，学习曲线就会越来越陡峭。但是要系统学习ES6，又会消耗大量时间。</p>\n<p>在这篇博客里，我把一些常用的ES6语法做一些总结，以更快更好地理解React中的概念和用法。</p>","more":"<p>在线练习ES6的工具：<a href=\"http://www.es6fiddle.net\" target=\"_blank\" rel=\"noopener\">ES6 fiddle</a></p>\n<hr>\n<h2 id=\"1-let-amp-const\"><a href=\"#1-let-amp-const\" class=\"headerlink\" title=\"1. let &amp; const\"></a>1. let &amp; const</h2><p>ES6的两个新关键字，主要是引入了块级作用域，不存在变量提升，不允许重复定义等特性，减少了ES5中很容易踩到的地雷。const用来定义常量，不允许后期修改赋值。<br>参考文档：<a href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener\">阮一峰的博客</a></p>\n<h2 id=\"2-解构赋值\"><a href=\"#2-解构赋值\" class=\"headerlink\" title=\"2.解构赋值\"></a>2.解构赋值</h2><ul>\n<li>常规用法：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;x&#125; = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>, <span class=\"attr\">y</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; PropTypes &#125; = React</span><br></pre></td></tr></table></figure>\n<p>这里是对象的解构赋值，等同于<code>let PropTypes = React.PropTypes</code></p>\n<blockquote>\n<p>这里其实包含了两步：</p>\n<ol>\n<li>声明变量PropTypes;</li>\n<li>给其赋值为React.PropTypes。</li>\n</ol>\n</blockquote>\n<p>所以等效于这样的写法：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let PropTypes</span><br><span class=\"line\">&#123; PropTypes &#125; = React;</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>可以同时写多个变量：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; PropTypes, Component &#125; = React;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果想定义的变量名和属性名不一样：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明x1变量，赋值为1. </span></span><br><span class=\"line\"><span class=\"comment\">//x是模式，不是变量也不会被赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">x</span> : x1 &#125; = &#123; <span class=\"attr\">x</span>:<span class=\"number\">1</span>, <span class=\"attr\">y</span>:<span class=\"number\">2</span> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>对象， 数组， 字符串等都有解构赋值的用法。</strong></p>\n</li>\n<li><p>参考文档：<a href=\"http://es6.ruanyifeng.com/#docs/destructuring\" target=\"_blank\" rel=\"noopener\">解构赋值</a></p>\n</li>\n</ul>\n<h2 id=\"3-对象的拓展\"><a href=\"#3-对象的拓展\" class=\"headerlink\" title=\"3.对象的拓展\"></a>3.对象的拓展</h2><h3 id=\"3-1-属性的简洁表达式\"><a href=\"#3-1-属性的简洁表达式\" class=\"headerlink\" title=\"3.1 属性的简洁表达式\"></a>3.1 属性的简洁表达式</h3><pre><code>let x = &apos;123&apos;;\n//等同于：let obj = { x: x, y: &apos;33}\nlet obj = {x, y: &apos;33&apos; };\n</code></pre><h3 id=\"3-2-方法名的简写\"><a href=\"#3-2-方法名的简写\" class=\"headerlink\" title=\"3.2 方法名的简写\"></a>3.2 方法名的简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let User = &#123;</span><br><span class=\"line\"> method ()&#123;   //等同于method: function()&#123;...&#125;</span><br><span class=\"line\">  //...</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3属性名表达式\"><a href=\"#3-3属性名表达式\" class=\"headerlink\" title=\"3.3属性名表达式\"></a>3.3属性名表达式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">let</span> key = <span class=\"string\">'id'</span>;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\t    [key] : <span class=\"string\">'1010'</span>, <span class=\"comment\">//注意方括号</span></span><br><span class=\"line\">\t    [<span class=\"string\">'use'</span> + <span class=\"string\">'name'</span> ]: <span class=\"string\">'x'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把表达式写在 [] 中， 表达式的值作为字段名称：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    id : <span class=\"string\">'1010'</span>,</span><br><span class=\"line\">    usename: <span class=\"string\">'x'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：属性名表达式与属性名简写不能同时使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">let</span> key = <span class=\"string\">'id'</span>;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> id = <span class=\"string\">'1010'</span>;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> obj =&#123;</span><br><span class=\"line\">    [key]</span><br><span class=\"line\">&#125;  <span class=\"comment\">//Error!</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-ES6-Class语法\"><a href=\"#4-ES6-Class语法\" class=\"headerlink\" title=\"4. ES6 Class语法\"></a>4. ES6 Class语法</h2><p>使用ES6语法定义一个React组件：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">count</span>: props.initialCount&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.tick = <span class=\"keyword\">this</span>.tick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttick()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trender()&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t\t\t&lt;div onClick = &#123;<span class=\"keyword\">this</span>.tick&#125;</span><br><span class=\"line\">\t\t\t\t&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t);</span></span><br><span class=\"line\"><span class=\"regexp\">\t&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Counter.propTypes = &#123; initialCount : Reart.PropTypes.number &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Counter.defaultProps = &#123; initialCount: 0 &#125;;</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：</p>\n<ol>\n<li>ES6的继承语法： extends关键字；</li>\n<li>各个方法使用了方法简写，如tick(){}和render(){}, 方法之间不加 “,”；</li>\n<li><code>constructor</code> 是构造函数， 可以替代getInitialState ； </li>\n<li>构造函数内需要调用父类的构造函数：<code>super(props)</code> , 否则就会报错。因为子类没有自身的<code>this</code> 对象，需要从父类继承。</li>\n<li><p><code>this.tick = this.tick.bind(this)</code>中， 使用<strong>bind</strong>来绑定执行作用域（使用React.createClass是自动绑定的), 也可以在render中监听事件的位置，使用bind(this):</p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;div onClick= &#123;<span class=\"keyword\">this</span>.tick.bind(<span class=\"keyword\">this</span>)&#125;&gt;</span><br><span class=\"line\">\t      Clicks: &#123;<span class=\"keyword\">this</span>.state.count&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t```    </span></span><br><span class=\"line\"><span class=\"regexp\">**官方建议统一写在constructor中，这样子该方法就只需绑定一次。**</span></span><br><span class=\"line\"><span class=\"regexp\">6. 除了使用bind, 还可以使用箭头函数：</span></span><br><span class=\"line\"><span class=\"regexp\">``` jsx</span></span><br><span class=\"line\"><span class=\"regexp\">\t&lt;div onClick = &#123;() =&gt; this.tick()&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\tClicks: &#123;this.state.count&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">\t&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>箭头函数的特性：<br>函数体内的this就是定义是的对象， 而非调用时所在的对象。箭头函数的this指向是固定的， 而普通函数是可变的。</p>\n</blockquote>\n<h2 id=\"5-箭头函数\"><a href=\"#5-箭头函数\" class=\"headerlink\" title=\"5. 箭头函数\"></a>5. 箭头函数</h2><ul>\n<li><p>ES6允许使用 <code>=&gt;</code> 来定义函数：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v+<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">//等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v + <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果有多个参数：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">let</span> f = <span class=\"function\">(<span class=\"params\">x ,y</span>) =&gt;</span> x + y;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- 函数有多条语句， 用大括号包装：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> js</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> f = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\tx = x + <span class=\"number\">11</span>;</span><br><span class=\"line\">\t\ty = y + <span class=\"number\">33</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>箭头函数的this指向能保持不变， 不是因为内部有绑定机制， 而是因为，<strong>箭头函数没有自己的this， 导致代码内的this就是外层代码块的this。</strong></p>\n</blockquote>\n<ul>\n<li>参考文档： <a href=\"#\">箭头函数</a></li>\n</ul>\n<h2 id=\"6-export-amp-import\"><a href=\"#6-export-amp-import\" class=\"headerlink\" title=\"6. export &amp; import\"></a>6. export &amp; import</h2><ul>\n<li>export用于输出模块对外的接口， import用于导入其他模块提供的功能。 </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> client = <span class=\"string\">\"App\"</span>\t<span class=\"comment\">//输出变量</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mul</span>(<span class=\"params\">x, y</span>)</span>&#123;\t<span class=\"comment\">//输出函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toast</span>()</span>&#123;&#125;\t\t<span class=\"comment\">//输出类</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>也可以统一输出：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//文件名： Util.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> client = <span class=\"string\">'App'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mul</span> (<span class=\"params\">x , y</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; client, mul &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>那么别的组件就要这样导入它：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;client, mul&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./Util.js'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>还可以打包导入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> U <span class=\"keyword\">from</span> <span class=\"string\">'./Util.js'</span></span><br><span class=\"line\">U.client <span class=\"comment\">//使用U</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用的 <code>export default</code> 命令， 用于输出默认的方法， 变量或类：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> React.createClass(&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入的时候就更方便， 可以随意指定名称：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Tab <span class=\"keyword\">from</span> <span class=\"string\">'tab'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>参考文档：<a href=\"#\">export&amp;import</a></p>\n</li>\n</ul>\n<h2 id=\"7-对象的拓展运算符-“…”\"><a href=\"#7-对象的拓展运算符-“…”\" class=\"headerlink\" title=\"7. 对象的拓展运算符: “…”\"></a>7. 对象的拓展运算符: “…”</h2><p>拓展运算符在Redux的示例Demo中很常见。</p>\n<ul>\n<li><p>拓展运算符可以用来合并两个对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//state = &#123; name: 'y' &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;...state, <span class=\"attr\">name</span>: <span class=\"string\">'x'</span>, <span class=\"attr\">id</span>: <span class=\"number\">101</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">//返回 &#123; name: 'x', id: 101 &#125;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面代码有两个过程:1.去除state对象的所有可比案例属性， 拷贝到当前对象上；</p>\n<pre><code>2.如果自定义的属性在后面， 拓展运算符的同名属性会被覆盖。\n</code></pre></blockquote>\n</li>\n<li><p>这种用法等同于 Object.assign:</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">//assign字面意思为分配</span></span><br><span class=\"line\">\t<span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;<span class=\"attr\">name</span>: <span class=\"string\">'x'</span>, <span class=\"attr\">id</span>:<span class=\"number\">101</span>&#125;)</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- 使用拓展运算符需要安装`</span>transform-object-rest-spread<span class=\"string\">`插件， 然后在babel中配置。 配置如下：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> js</span><br><span class=\"line\">test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">loader: <span class=\"string\">'babel'</span>,</span><br><span class=\"line\">query:&#123;</span><br><span class=\"line\">    presets: [<span class=\"string\">'react'</span>, <span class=\"string\">'es2015'</span>],</span><br><span class=\"line\">    plugins: [<span class=\"string\">\"transform-object-rest-spread\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参考文档：<a href=\"#\">ES6拓展运算符</a></li>\n</ul>\n<hr>\n<p>The End.</p>"},{"title":"Mac安装Sass万能方法","date":"2017-06-06T16:00:00.000Z","_content":"\n\n# Mac OSX系统下使用RVM修复安装Sass的错误\n\n这个万金油方法能解决大多数的gem安装问题。\n\n<!--more-->\n如果你使用通用的` gem install sass` 出现错误：\n\n```\nERROR:  While executing gem ... (Errno::EACCES)\n    Permission denied - /var/lib/gems\n```\n那么这篇文章也许能解决你的问题。\n    \n这个错误说明Ruby的权限有问题，要解决这个权限问题很麻烦，不过有一个方法可以跳过这个坑：\n\n**使用RVM(Ruby Version Manager)安装一个特定版本的Ruby，再安装sass。**\n\n\n\n> 以下步骤都在Terminal(终端)中完成!\n\n## 1. 安装Homebrew\n\n    /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n\n## 2. 安装gpg\n安装RVM之前需要gpg，先别管它是什么。\n\n它是 **mpapis public key** 公钥用于验证安装包以确保安全。\n\n如果你想知道它到底是什么，点击这里[GNU-wiki百科](https://en.wikipedia.org/wiki/GNU_Privacy_Guard)。\n\n    brew install gnupg\n## 3. 安装gpg密钥\n\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n\n\n## 4. 安装RVM\n\n    \\curl -sSL https://get.rvm.io | bash -s stable --ruby\n\n## 5. 开始使用RVM\n\n### 1. 查看已有Ruby版本:\n\n```\n    rvm list\n```\n> 如果出现警告，如：\n> “Warning! PATH is not properly set up...” ，\n> 这是未添加RVM环境变量，请[参考解决方案](https://stackoverflow.com/questions/18276701/getting-warning-path-is-not-properly-set-up-when-doing-rvm-use-2-0-0-defaul).\n> 或者你直接Copy下面的指令：\n> \n```\n    [[ -s \"$HOME/.rvm/scripts/rvm\" ]] && source \"$HOME/.rvm/scripts/rvm\"\n```\n\n### 2. 检查Ruby版本列表：\n**不必输入下面的代码，这是输入`rvm list`后的结果！**\n```\nrvm rubies\n\n=* ruby-2.2.0 [ x86_64 ]\n\n# => - current\n# =* - current && default\n#  * - default\n```\n\n### 3. 安装特定版本Ruby：\n\n    rvm use ruby --default\n\n检查ruby位置：\n\n    which ruby\n如果显示了一行目录，则表示安装成功。\n\n    ruby -v\n\n## 6. 安装sass\n\n    gem install sass\n    \n    \n## 7. 安装完成！\n\n> 参考文章：[Ruby on Mac OSX with RVM](http://usabilityetc.com/articles/ruby-on-mac-os-x-with-rvm/)\n\n","source":"_posts/2017-06-07 Mac安装Sass万能方法.md","raw":"---\ntitle: Mac安装Sass万能方法\ncategories: 笔记\ndate: 2017-06-07 \ntags: 指南 笔记 Mac\n---\n\n\n# Mac OSX系统下使用RVM修复安装Sass的错误\n\n这个万金油方法能解决大多数的gem安装问题。\n\n<!--more-->\n如果你使用通用的` gem install sass` 出现错误：\n\n```\nERROR:  While executing gem ... (Errno::EACCES)\n    Permission denied - /var/lib/gems\n```\n那么这篇文章也许能解决你的问题。\n    \n这个错误说明Ruby的权限有问题，要解决这个权限问题很麻烦，不过有一个方法可以跳过这个坑：\n\n**使用RVM(Ruby Version Manager)安装一个特定版本的Ruby，再安装sass。**\n\n\n\n> 以下步骤都在Terminal(终端)中完成!\n\n## 1. 安装Homebrew\n\n    /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n\n## 2. 安装gpg\n安装RVM之前需要gpg，先别管它是什么。\n\n它是 **mpapis public key** 公钥用于验证安装包以确保安全。\n\n如果你想知道它到底是什么，点击这里[GNU-wiki百科](https://en.wikipedia.org/wiki/GNU_Privacy_Guard)。\n\n    brew install gnupg\n## 3. 安装gpg密钥\n\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n\n\n## 4. 安装RVM\n\n    \\curl -sSL https://get.rvm.io | bash -s stable --ruby\n\n## 5. 开始使用RVM\n\n### 1. 查看已有Ruby版本:\n\n```\n    rvm list\n```\n> 如果出现警告，如：\n> “Warning! PATH is not properly set up...” ，\n> 这是未添加RVM环境变量，请[参考解决方案](https://stackoverflow.com/questions/18276701/getting-warning-path-is-not-properly-set-up-when-doing-rvm-use-2-0-0-defaul).\n> 或者你直接Copy下面的指令：\n> \n```\n    [[ -s \"$HOME/.rvm/scripts/rvm\" ]] && source \"$HOME/.rvm/scripts/rvm\"\n```\n\n### 2. 检查Ruby版本列表：\n**不必输入下面的代码，这是输入`rvm list`后的结果！**\n```\nrvm rubies\n\n=* ruby-2.2.0 [ x86_64 ]\n\n# => - current\n# =* - current && default\n#  * - default\n```\n\n### 3. 安装特定版本Ruby：\n\n    rvm use ruby --default\n\n检查ruby位置：\n\n    which ruby\n如果显示了一行目录，则表示安装成功。\n\n    ruby -v\n\n## 6. 安装sass\n\n    gem install sass\n    \n    \n## 7. 安装完成！\n\n> 参考文章：[Ruby on Mac OSX with RVM](http://usabilityetc.com/articles/ruby-on-mac-os-x-with-rvm/)\n\n","slug":"2017-06-07 Mac安装Sass万能方法","published":1,"updated":"2018-12-21T12:20:34.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7q000jjts4a7zbteea","content":"<h1 id=\"Mac-OSX系统下使用RVM修复安装Sass的错误\"><a href=\"#Mac-OSX系统下使用RVM修复安装Sass的错误\" class=\"headerlink\" title=\"Mac OSX系统下使用RVM修复安装Sass的错误\"></a>Mac OSX系统下使用RVM修复安装Sass的错误</h1><p>这个万金油方法能解决大多数的gem安装问题。</p>\n<a id=\"more\"></a>\n<p>如果你使用通用的<code>gem install sass</code> 出现错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR:  While executing gem ... (Errno::EACCES)</span><br><span class=\"line\">    Permission denied - /var/lib/gems</span><br></pre></td></tr></table></figure>\n<p>那么这篇文章也许能解决你的问题。</p>\n<p>这个错误说明Ruby的权限有问题，要解决这个权限问题很麻烦，不过有一个方法可以跳过这个坑：</p>\n<p><strong>使用RVM(Ruby Version Manager)安装一个特定版本的Ruby，再安装sass。</strong></p>\n<blockquote>\n<p>以下步骤都在Terminal(终端)中完成!</p>\n</blockquote>\n<h2 id=\"1-安装Homebrew\"><a href=\"#1-安装Homebrew\" class=\"headerlink\" title=\"1. 安装Homebrew\"></a>1. 安装Homebrew</h2><pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n</code></pre><h2 id=\"2-安装gpg\"><a href=\"#2-安装gpg\" class=\"headerlink\" title=\"2. 安装gpg\"></a>2. 安装gpg</h2><p>安装RVM之前需要gpg，先别管它是什么。</p>\n<p>它是 <strong>mpapis public key</strong> 公钥用于验证安装包以确保安全。</p>\n<p>如果你想知道它到底是什么，点击这里<a href=\"https://en.wikipedia.org/wiki/GNU_Privacy_Guard\" target=\"_blank\" rel=\"noopener\">GNU-wiki百科</a>。</p>\n<pre><code>brew install gnupg\n</code></pre><h2 id=\"3-安装gpg密钥\"><a href=\"#3-安装gpg密钥\" class=\"headerlink\" title=\"3. 安装gpg密钥\"></a>3. 安装gpg密钥</h2><pre><code>gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n</code></pre><h2 id=\"4-安装RVM\"><a href=\"#4-安装RVM\" class=\"headerlink\" title=\"4. 安装RVM\"></a>4. 安装RVM</h2><pre><code>\\curl -sSL https://get.rvm.io | bash -s stable --ruby\n</code></pre><h2 id=\"5-开始使用RVM\"><a href=\"#5-开始使用RVM\" class=\"headerlink\" title=\"5. 开始使用RVM\"></a>5. 开始使用RVM</h2><h3 id=\"1-查看已有Ruby版本\"><a href=\"#1-查看已有Ruby版本\" class=\"headerlink\" title=\"1. 查看已有Ruby版本:\"></a>1. 查看已有Ruby版本:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果出现警告，如：<br>“Warning! PATH is not properly set up…” ，<br>这是未添加RVM环境变量，请<a href=\"https://stackoverflow.com/questions/18276701/getting-warning-path-is-not-properly-set-up-when-doing-rvm-use-2-0-0-defaul\" target=\"_blank\" rel=\"noopener\">参考解决方案</a>.<br>或者你直接Copy下面的指令：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-检查Ruby版本列表：\"><a href=\"#2-检查Ruby版本列表：\" class=\"headerlink\" title=\"2. 检查Ruby版本列表：\"></a>2. 检查Ruby版本列表：</h3><p><strong>不必输入下面的代码，这是输入<code>rvm list</code>后的结果！</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm rubies</span><br><span class=\"line\"></span><br><span class=\"line\">=* ruby-2.2.0 [ x86_64 ]</span><br><span class=\"line\"></span><br><span class=\"line\"># =&gt; - current</span><br><span class=\"line\"># =* - current &amp;&amp; default</span><br><span class=\"line\">#  * - default</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-安装特定版本Ruby：\"><a href=\"#3-安装特定版本Ruby：\" class=\"headerlink\" title=\"3. 安装特定版本Ruby：\"></a>3. 安装特定版本Ruby：</h3><pre><code>rvm use ruby --default\n</code></pre><p>检查ruby位置：</p>\n<pre><code>which ruby\n</code></pre><p>如果显示了一行目录，则表示安装成功。</p>\n<pre><code>ruby -v\n</code></pre><h2 id=\"6-安装sass\"><a href=\"#6-安装sass\" class=\"headerlink\" title=\"6. 安装sass\"></a>6. 安装sass</h2><pre><code>gem install sass\n</code></pre><h2 id=\"7-安装完成！\"><a href=\"#7-安装完成！\" class=\"headerlink\" title=\"7. 安装完成！\"></a>7. 安装完成！</h2><blockquote>\n<p>参考文章：<a href=\"http://usabilityetc.com/articles/ruby-on-mac-os-x-with-rvm/\" target=\"_blank\" rel=\"noopener\">Ruby on Mac OSX with RVM</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Mac-OSX系统下使用RVM修复安装Sass的错误\"><a href=\"#Mac-OSX系统下使用RVM修复安装Sass的错误\" class=\"headerlink\" title=\"Mac OSX系统下使用RVM修复安装Sass的错误\"></a>Mac OSX系统下使用RVM修复安装Sass的错误</h1><p>这个万金油方法能解决大多数的gem安装问题。</p>","more":"<p>如果你使用通用的<code>gem install sass</code> 出现错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR:  While executing gem ... (Errno::EACCES)</span><br><span class=\"line\">    Permission denied - /var/lib/gems</span><br></pre></td></tr></table></figure>\n<p>那么这篇文章也许能解决你的问题。</p>\n<p>这个错误说明Ruby的权限有问题，要解决这个权限问题很麻烦，不过有一个方法可以跳过这个坑：</p>\n<p><strong>使用RVM(Ruby Version Manager)安装一个特定版本的Ruby，再安装sass。</strong></p>\n<blockquote>\n<p>以下步骤都在Terminal(终端)中完成!</p>\n</blockquote>\n<h2 id=\"1-安装Homebrew\"><a href=\"#1-安装Homebrew\" class=\"headerlink\" title=\"1. 安装Homebrew\"></a>1. 安装Homebrew</h2><pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n</code></pre><h2 id=\"2-安装gpg\"><a href=\"#2-安装gpg\" class=\"headerlink\" title=\"2. 安装gpg\"></a>2. 安装gpg</h2><p>安装RVM之前需要gpg，先别管它是什么。</p>\n<p>它是 <strong>mpapis public key</strong> 公钥用于验证安装包以确保安全。</p>\n<p>如果你想知道它到底是什么，点击这里<a href=\"https://en.wikipedia.org/wiki/GNU_Privacy_Guard\" target=\"_blank\" rel=\"noopener\">GNU-wiki百科</a>。</p>\n<pre><code>brew install gnupg\n</code></pre><h2 id=\"3-安装gpg密钥\"><a href=\"#3-安装gpg密钥\" class=\"headerlink\" title=\"3. 安装gpg密钥\"></a>3. 安装gpg密钥</h2><pre><code>gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n</code></pre><h2 id=\"4-安装RVM\"><a href=\"#4-安装RVM\" class=\"headerlink\" title=\"4. 安装RVM\"></a>4. 安装RVM</h2><pre><code>\\curl -sSL https://get.rvm.io | bash -s stable --ruby\n</code></pre><h2 id=\"5-开始使用RVM\"><a href=\"#5-开始使用RVM\" class=\"headerlink\" title=\"5. 开始使用RVM\"></a>5. 开始使用RVM</h2><h3 id=\"1-查看已有Ruby版本\"><a href=\"#1-查看已有Ruby版本\" class=\"headerlink\" title=\"1. 查看已有Ruby版本:\"></a>1. 查看已有Ruby版本:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果出现警告，如：<br>“Warning! PATH is not properly set up…” ，<br>这是未添加RVM环境变量，请<a href=\"https://stackoverflow.com/questions/18276701/getting-warning-path-is-not-properly-set-up-when-doing-rvm-use-2-0-0-defaul\" target=\"_blank\" rel=\"noopener\">参考解决方案</a>.<br>或者你直接Copy下面的指令：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-检查Ruby版本列表：\"><a href=\"#2-检查Ruby版本列表：\" class=\"headerlink\" title=\"2. 检查Ruby版本列表：\"></a>2. 检查Ruby版本列表：</h3><p><strong>不必输入下面的代码，这是输入<code>rvm list</code>后的结果！</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm rubies</span><br><span class=\"line\"></span><br><span class=\"line\">=* ruby-2.2.0 [ x86_64 ]</span><br><span class=\"line\"></span><br><span class=\"line\"># =&gt; - current</span><br><span class=\"line\"># =* - current &amp;&amp; default</span><br><span class=\"line\">#  * - default</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-安装特定版本Ruby：\"><a href=\"#3-安装特定版本Ruby：\" class=\"headerlink\" title=\"3. 安装特定版本Ruby：\"></a>3. 安装特定版本Ruby：</h3><pre><code>rvm use ruby --default\n</code></pre><p>检查ruby位置：</p>\n<pre><code>which ruby\n</code></pre><p>如果显示了一行目录，则表示安装成功。</p>\n<pre><code>ruby -v\n</code></pre><h2 id=\"6-安装sass\"><a href=\"#6-安装sass\" class=\"headerlink\" title=\"6. 安装sass\"></a>6. 安装sass</h2><pre><code>gem install sass\n</code></pre><h2 id=\"7-安装完成！\"><a href=\"#7-安装完成！\" class=\"headerlink\" title=\"7. 安装完成！\"></a>7. 安装完成！</h2><blockquote>\n<p>参考文章：<a href=\"http://usabilityetc.com/articles/ruby-on-mac-os-x-with-rvm/\" target=\"_blank\" rel=\"noopener\">Ruby on Mac OSX with RVM</a></p>\n</blockquote>"},{"title":"2017-07-22-工作日志","date":"2017-07-22T14:38:55.000Z","_content":"\n今天是大暑，热的一逼。\n<!--more-->\n\n把俄罗斯方块的网页做完了，真的佩服老外。\n\n巩固了CSS中BFC的原理，理解了清除浮动和边距重叠的原理。\n\n下午太热了，莫名其妙又装了一个Ubuntu系统进硬盘，现在我集齐了三个系统Mac+Windows+Linux。在过程中顺带看完了一部电影《天才少女》，引起了对儿童教育的反思。\n\n","source":"_posts/2017-07-22 工作日志.md","raw":"---\ntitle: 2017-07-22-工作日志\ndate: 2017-07-22 22:38:55\ncategories: 日志\n---\n\n今天是大暑，热的一逼。\n<!--more-->\n\n把俄罗斯方块的网页做完了，真的佩服老外。\n\n巩固了CSS中BFC的原理，理解了清除浮动和边距重叠的原理。\n\n下午太热了，莫名其妙又装了一个Ubuntu系统进硬盘，现在我集齐了三个系统Mac+Windows+Linux。在过程中顺带看完了一部电影《天才少女》，引起了对儿童教育的反思。\n\n","slug":"2017-07-22 工作日志","published":1,"updated":"2018-12-21T12:26:57.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7s000ojts4inwqetx5","content":"<p>今天是大暑，热的一逼。<br><a id=\"more\"></a></p>\n<p>把俄罗斯方块的网页做完了，真的佩服老外。</p>\n<p>巩固了CSS中BFC的原理，理解了清除浮动和边距重叠的原理。</p>\n<p>下午太热了，莫名其妙又装了一个Ubuntu系统进硬盘，现在我集齐了三个系统Mac+Windows+Linux。在过程中顺带看完了一部电影《天才少女》，引起了对儿童教育的反思。</p>\n","site":{"data":{}},"excerpt":"<p>今天是大暑，热的一逼。<br>","more":"</p>\n<p>把俄罗斯方块的网页做完了，真的佩服老外。</p>\n<p>巩固了CSS中BFC的原理，理解了清除浮动和边距重叠的原理。</p>\n<p>下午太热了，莫名其妙又装了一个Ubuntu系统进硬盘，现在我集齐了三个系统Mac+Windows+Linux。在过程中顺带看完了一部电影《天才少女》，引起了对儿童教育的反思。</p>"},{"title":"更好用的border-box","date":"2017-10-22T16:00:00.000Z","_content":"\n英文原文来自CSS-tricks: [Inheriting box-sizing Probably Slightly Better Best-Practice](https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/)\n\n我是把`box-sizing`重置为`border-box`的忠实粉丝，甚至于我们有一个“年度特别日子”。但是这里有一个细小的调整，而且看起来是个不错的思路。\n<!--more-->\n这是微调的版本：\n``` css\n    html{\n\t    box-sizing: border-box;\n\t}\n\t*, *:before, *:after{\n\t\tbox-sizing:inherit;\n\t}\t\n```\n\n感谢[Job Neal的继承思想](http://blog.teamtreehouse.com/box-sizing-secret-simple-css-layouts#comment-50223)，他说：\n> This will give you the same result ,and make it easier to change the box-sizing in plugins or other components that leverage other behavior.\n> 这会给你同样的结果，而且使得在插件中或其他组件中更容易改变 box-sizing 的值，而不会影响别的表现。\n\n进一步解释，打个比方，你有一个组件，它本被设计为默认的`box-sizing` 为 `content-box`. 你只想要使用，又不搞砸它。\n\n``` css\n\t.component{\n\t\t/*旨在以默认的box-sizing工作*/\n\t\t/*在你的页面中， 你可以把它重置为normal */\n\t\tbox-sizing: content-box;\n\t}\t\n```\n\n但问题是，这样实际上并不重置整个组件。也许在组件内部有一个`<header>`，期望它在一个`content-box`中。如果这个选择器在你的CSS中，老办法就是做一个 box-sizing **reset**...\n\n```css\n*{\n\tbox-sizing: border-box;\n}\n```\n\n然后这个header不是你想要的`content-box`, 而是 `border-box`. 就像：\n```html\n<div class= \"component\"> <!-- I'm content box -->\n\t<header> <!-- I'm border-box still>\n\t</header>\n</div>\t\n```\n为了更简单直观地做到**reset**，你可以使用文章顶部的继承的代码段，继承的值就会被保留。\n``` css\n    html{\n\t    box-sizing: border-box;\n\t}\n\t*, *:before, *:after{\n\t\tbox-sizing:inherit;\n\t}\t\n```\n\n---\n这并不是一个很庞大的东西。你可能已经在使用 box-sizing reset 的老办法，并且从没踩到这个坑。但是，只要我们推广一个“最佳实践”风格的片段，我们也可以慢慢把它变成最好的。\n","source":"_posts/2017-10-23 更好用的border-box.md","raw":"---\ntitle: 更好用的border-box\ndate: 2017-10-23\ncategories: 技术\ntags: [前端,CSS]\n---\n\n英文原文来自CSS-tricks: [Inheriting box-sizing Probably Slightly Better Best-Practice](https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/)\n\n我是把`box-sizing`重置为`border-box`的忠实粉丝，甚至于我们有一个“年度特别日子”。但是这里有一个细小的调整，而且看起来是个不错的思路。\n<!--more-->\n这是微调的版本：\n``` css\n    html{\n\t    box-sizing: border-box;\n\t}\n\t*, *:before, *:after{\n\t\tbox-sizing:inherit;\n\t}\t\n```\n\n感谢[Job Neal的继承思想](http://blog.teamtreehouse.com/box-sizing-secret-simple-css-layouts#comment-50223)，他说：\n> This will give you the same result ,and make it easier to change the box-sizing in plugins or other components that leverage other behavior.\n> 这会给你同样的结果，而且使得在插件中或其他组件中更容易改变 box-sizing 的值，而不会影响别的表现。\n\n进一步解释，打个比方，你有一个组件，它本被设计为默认的`box-sizing` 为 `content-box`. 你只想要使用，又不搞砸它。\n\n``` css\n\t.component{\n\t\t/*旨在以默认的box-sizing工作*/\n\t\t/*在你的页面中， 你可以把它重置为normal */\n\t\tbox-sizing: content-box;\n\t}\t\n```\n\n但问题是，这样实际上并不重置整个组件。也许在组件内部有一个`<header>`，期望它在一个`content-box`中。如果这个选择器在你的CSS中，老办法就是做一个 box-sizing **reset**...\n\n```css\n*{\n\tbox-sizing: border-box;\n}\n```\n\n然后这个header不是你想要的`content-box`, 而是 `border-box`. 就像：\n```html\n<div class= \"component\"> <!-- I'm content box -->\n\t<header> <!-- I'm border-box still>\n\t</header>\n</div>\t\n```\n为了更简单直观地做到**reset**，你可以使用文章顶部的继承的代码段，继承的值就会被保留。\n``` css\n    html{\n\t    box-sizing: border-box;\n\t}\n\t*, *:before, *:after{\n\t\tbox-sizing:inherit;\n\t}\t\n```\n\n---\n这并不是一个很庞大的东西。你可能已经在使用 box-sizing reset 的老办法，并且从没踩到这个坑。但是，只要我们推广一个“最佳实践”风格的片段，我们也可以慢慢把它变成最好的。\n","slug":"2017-10-23 更好用的border-box","published":1,"updated":"2018-12-21T12:27:54.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7t000qjts45uh9vmd8","content":"<p>英文原文来自CSS-tricks: <a href=\"https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/\" target=\"_blank\" rel=\"noopener\">Inheriting box-sizing Probably Slightly Better Best-Practice</a></p>\n<p>我是把<code>box-sizing</code>重置为<code>border-box</code>的忠实粉丝，甚至于我们有一个“年度特别日子”。但是这里有一个细小的调整，而且看起来是个不错的思路。<br><a id=\"more\"></a><br>这是微调的版本：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"selector-tag\">html</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*, *<span class=\"selector-pseudo\">:before</span>, *<span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>:inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>感谢<a href=\"http://blog.teamtreehouse.com/box-sizing-secret-simple-css-layouts#comment-50223\" target=\"_blank\" rel=\"noopener\">Job Neal的继承思想</a>，他说：</p>\n<blockquote>\n<p>This will give you the same result ,and make it easier to change the box-sizing in plugins or other components that leverage other behavior.<br>这会给你同样的结果，而且使得在插件中或其他组件中更容易改变 box-sizing 的值，而不会影响别的表现。</p>\n</blockquote>\n<p>进一步解释，打个比方，你有一个组件，它本被设计为默认的<code>box-sizing</code> 为 <code>content-box</code>. 你只想要使用，又不搞砸它。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.component</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*旨在以默认的box-sizing工作*/</span></span><br><span class=\"line\">\t<span class=\"comment\">/*在你的页面中， 你可以把它重置为normal */</span></span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但问题是，这样实际上并不重置整个组件。也许在组件内部有一个<code>&lt;header&gt;</code>，期望它在一个<code>content-box</code>中。如果这个选择器在你的CSS中，老办法就是做一个 box-sizing <strong>reset</strong>…</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后这个header不是你想要的<code>content-box</code>, 而是 <code>border-box</code>. 就像：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>= <span class=\"string\">\"component\"</span>&gt;</span> <span class=\"comment\">&lt;!-- I'm content box --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span> <span class=\"comment\">&lt;!-- I'm border-box still&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t&lt;/header&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>为了更简单直观地做到<strong>reset</strong>，你可以使用文章顶部的继承的代码段，继承的值就会被保留。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"selector-tag\">html</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*, *<span class=\"selector-pseudo\">:before</span>, *<span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>:inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>这并不是一个很庞大的东西。你可能已经在使用 box-sizing reset 的老办法，并且从没踩到这个坑。但是，只要我们推广一个“最佳实践”风格的片段，我们也可以慢慢把它变成最好的。</p>\n","site":{"data":{}},"excerpt":"<p>英文原文来自CSS-tricks: <a href=\"https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/\" target=\"_blank\" rel=\"noopener\">Inheriting box-sizing Probably Slightly Better Best-Practice</a></p>\n<p>我是把<code>box-sizing</code>重置为<code>border-box</code>的忠实粉丝，甚至于我们有一个“年度特别日子”。但是这里有一个细小的调整，而且看起来是个不错的思路。<br>","more":"<br>这是微调的版本：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"selector-tag\">html</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*, *<span class=\"selector-pseudo\">:before</span>, *<span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>:inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>感谢<a href=\"http://blog.teamtreehouse.com/box-sizing-secret-simple-css-layouts#comment-50223\" target=\"_blank\" rel=\"noopener\">Job Neal的继承思想</a>，他说：</p>\n<blockquote>\n<p>This will give you the same result ,and make it easier to change the box-sizing in plugins or other components that leverage other behavior.<br>这会给你同样的结果，而且使得在插件中或其他组件中更容易改变 box-sizing 的值，而不会影响别的表现。</p>\n</blockquote>\n<p>进一步解释，打个比方，你有一个组件，它本被设计为默认的<code>box-sizing</code> 为 <code>content-box</code>. 你只想要使用，又不搞砸它。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.component</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*旨在以默认的box-sizing工作*/</span></span><br><span class=\"line\">\t<span class=\"comment\">/*在你的页面中， 你可以把它重置为normal */</span></span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但问题是，这样实际上并不重置整个组件。也许在组件内部有一个<code>&lt;header&gt;</code>，期望它在一个<code>content-box</code>中。如果这个选择器在你的CSS中，老办法就是做一个 box-sizing <strong>reset</strong>…</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后这个header不是你想要的<code>content-box</code>, 而是 <code>border-box</code>. 就像：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>= <span class=\"string\">\"component\"</span>&gt;</span> <span class=\"comment\">&lt;!-- I'm content box --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span> <span class=\"comment\">&lt;!-- I'm border-box still&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t&lt;/header&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>为了更简单直观地做到<strong>reset</strong>，你可以使用文章顶部的继承的代码段，继承的值就会被保留。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"selector-tag\">html</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*, *<span class=\"selector-pseudo\">:before</span>, *<span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>:inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>这并不是一个很庞大的东西。你可能已经在使用 box-sizing reset 的老办法，并且从没踩到这个坑。但是，只要我们推广一个“最佳实践”风格的片段，我们也可以慢慢把它变成最好的。</p>"},{"title":"2017-12-03 日记：村上春树的文摘","date":"2017-07-22T14:38:55.000Z","_content":"\n# 2017-12-03 日记\n村上春树，从29岁开始写作，从33岁开始坚持跑步。\n\n人生哪有那么多太晚，都是懒惰和恐惧的借口罢了。\n\n今天天气多好啊，我赖在床上，阳光从落地窗的窗帘边缘钻进来，整个房间阳光明媚。\n\n我侧身躺着，看了村上春树的《当我谈跑步时，我谈些什么》,我喜欢他的文风。\n\n> 一些人不努力便得不到的东西，有些人却勿需努力便唾手可得。\n\n> 在学校里，我们学到的最重要的东西，就是“最重要的东西在学校里学不到”这个真理。\n","source":"_posts/2017-12-03 随笔-人生哪有那么多太晚，都是懒惰和恐惧的借口罢了.md","raw":"---\ntitle: 2017-12-03 日记：村上春树的文摘\ndate: 2017-07-22 22:38:55\ncategories: 随笔\ntags: 随笔\n---\n\n# 2017-12-03 日记\n村上春树，从29岁开始写作，从33岁开始坚持跑步。\n\n人生哪有那么多太晚，都是懒惰和恐惧的借口罢了。\n\n今天天气多好啊，我赖在床上，阳光从落地窗的窗帘边缘钻进来，整个房间阳光明媚。\n\n我侧身躺着，看了村上春树的《当我谈跑步时，我谈些什么》,我喜欢他的文风。\n\n> 一些人不努力便得不到的东西，有些人却勿需努力便唾手可得。\n\n> 在学校里，我们学到的最重要的东西，就是“最重要的东西在学校里学不到”这个真理。\n","slug":"2017-12-03 随笔-人生哪有那么多太晚，都是懒惰和恐惧的借口罢了","published":1,"updated":"2018-12-21T12:24:16.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7w000ujts4z2o0aljb","content":"<h1 id=\"2017-12-03-日记\"><a href=\"#2017-12-03-日记\" class=\"headerlink\" title=\"2017-12-03 日记\"></a>2017-12-03 日记</h1><p>村上春树，从29岁开始写作，从33岁开始坚持跑步。</p>\n<p>人生哪有那么多太晚，都是懒惰和恐惧的借口罢了。</p>\n<p>今天天气多好啊，我赖在床上，阳光从落地窗的窗帘边缘钻进来，整个房间阳光明媚。</p>\n<p>我侧身躺着，看了村上春树的《当我谈跑步时，我谈些什么》,我喜欢他的文风。</p>\n<blockquote>\n<p>一些人不努力便得不到的东西，有些人却勿需努力便唾手可得。</p>\n</blockquote>\n<blockquote>\n<p>在学校里，我们学到的最重要的东西，就是“最重要的东西在学校里学不到”这个真理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2017-12-03-日记\"><a href=\"#2017-12-03-日记\" class=\"headerlink\" title=\"2017-12-03 日记\"></a>2017-12-03 日记</h1><p>村上春树，从29岁开始写作，从33岁开始坚持跑步。</p>\n<p>人生哪有那么多太晚，都是懒惰和恐惧的借口罢了。</p>\n<p>今天天气多好啊，我赖在床上，阳光从落地窗的窗帘边缘钻进来，整个房间阳光明媚。</p>\n<p>我侧身躺着，看了村上春树的《当我谈跑步时，我谈些什么》,我喜欢他的文风。</p>\n<blockquote>\n<p>一些人不努力便得不到的东西，有些人却勿需努力便唾手可得。</p>\n</blockquote>\n<blockquote>\n<p>在学校里，我们学到的最重要的东西，就是“最重要的东西在学校里学不到”这个真理。</p>\n</blockquote>\n"},{"title":"2017-09-05-翻译了第一篇英文文档","date":"2017-09-05T12:10:33.000Z","_content":"\n9月4日翻译了MDN上的一篇英文文档，这是第一次尝试翻译，尝到了成就感.\n<!--more-->\n\nMDN是Web开发者的参考文档的官方网站——[MDN Web 文档](https://developer.mozilla.org/zh-CN/)，有大量开发者不断贡献和更新文档和教程。\n## 做了什么\n最近，在对JavaScript中this关键字的细节整理中，查阅MDN的中文文档，有些语句翻译的不错，但是还是存在部分疏漏。\n\n仔细一番MDN的一些中文文档，少数文档的部分语句有明显的语义和内容上的毛病。\n\n索性去看英文文档，豁然开朗，遂决定更新中文翻译文档。\n\n在9月4日翻译了MDN上JavaScript的this关键字的英文文档：[原版英文文档](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/this)。\n\n1. 保留了部分原有翻译，纠正了大部分语义措辞漏洞，并更新了关于箭头函数的this指向。\n2. 部分语句参考了谷歌翻译，我承认谷歌翻译真的很NB。\n\n## 有什么总结\n\n1. 要彻底弄懂this的机制，首先你要准备好面向对象的基础，理解OOP的重要概念：\n - [JavaScript面向对象编程](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)\n2. 然后记住，this是一个变量，它是一个指针，指向一个对象。再看我的文档:\n - [this关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\n3. 在过程中看不懂时，及时查阅相关API的文档:\n - [箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n - [Function.prototype.call()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\n - [Function.prototype.apply()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n - [Function.prototype.bind()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n\n\n## 写在结尾\n在英文文档末尾的参考链接，有一篇写得非常精彩的博客：\n[Gentle-explanation-of-this-in-JavaScript, 温和解释JS中的this](https://rainsoft.io/gentle-explanation-of-this-in-javascript/)\n\n计划在不久将来，我会挤出时间认真翻译这篇英文博客。\n\nThe end.\n","source":"_posts/2017-09-05 第一次翻译MDN文档.md","raw":"---\ntitle: 2017-09-05-翻译了第一篇英文文档\ndate: 2017-09-05 20:10:33\ntags: 日志\ncategories: 日志\n---\n\n9月4日翻译了MDN上的一篇英文文档，这是第一次尝试翻译，尝到了成就感.\n<!--more-->\n\nMDN是Web开发者的参考文档的官方网站——[MDN Web 文档](https://developer.mozilla.org/zh-CN/)，有大量开发者不断贡献和更新文档和教程。\n## 做了什么\n最近，在对JavaScript中this关键字的细节整理中，查阅MDN的中文文档，有些语句翻译的不错，但是还是存在部分疏漏。\n\n仔细一番MDN的一些中文文档，少数文档的部分语句有明显的语义和内容上的毛病。\n\n索性去看英文文档，豁然开朗，遂决定更新中文翻译文档。\n\n在9月4日翻译了MDN上JavaScript的this关键字的英文文档：[原版英文文档](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/this)。\n\n1. 保留了部分原有翻译，纠正了大部分语义措辞漏洞，并更新了关于箭头函数的this指向。\n2. 部分语句参考了谷歌翻译，我承认谷歌翻译真的很NB。\n\n## 有什么总结\n\n1. 要彻底弄懂this的机制，首先你要准备好面向对象的基础，理解OOP的重要概念：\n - [JavaScript面向对象编程](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)\n2. 然后记住，this是一个变量，它是一个指针，指向一个对象。再看我的文档:\n - [this关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\n3. 在过程中看不懂时，及时查阅相关API的文档:\n - [箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n - [Function.prototype.call()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\n - [Function.prototype.apply()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n - [Function.prototype.bind()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n\n\n## 写在结尾\n在英文文档末尾的参考链接，有一篇写得非常精彩的博客：\n[Gentle-explanation-of-this-in-JavaScript, 温和解释JS中的this](https://rainsoft.io/gentle-explanation-of-this-in-javascript/)\n\n计划在不久将来，我会挤出时间认真翻译这篇英文博客。\n\nThe end.\n","slug":"2017-09-05 第一次翻译MDN文档","published":1,"updated":"2018-12-21T12:24:38.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm7y000xjts40f0r6dm1","content":"<p>9月4日翻译了MDN上的一篇英文文档，这是第一次尝试翻译，尝到了成就感.<br><a id=\"more\"></a></p>\n<p>MDN是Web开发者的参考文档的官方网站——<a href=\"https://developer.mozilla.org/zh-CN/\" target=\"_blank\" rel=\"noopener\">MDN Web 文档</a>，有大量开发者不断贡献和更新文档和教程。</p>\n<h2 id=\"做了什么\"><a href=\"#做了什么\" class=\"headerlink\" title=\"做了什么\"></a>做了什么</h2><p>最近，在对JavaScript中this关键字的细节整理中，查阅MDN的中文文档，有些语句翻译的不错，但是还是存在部分疏漏。</p>\n<p>仔细一番MDN的一些中文文档，少数文档的部分语句有明显的语义和内容上的毛病。</p>\n<p>索性去看英文文档，豁然开朗，遂决定更新中文翻译文档。</p>\n<p>在9月4日翻译了MDN上JavaScript的this关键字的英文文档：<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"noopener\">原版英文文档</a>。</p>\n<ol>\n<li>保留了部分原有翻译，纠正了大部分语义措辞漏洞，并更新了关于箭头函数的this指向。</li>\n<li>部分语句参考了谷歌翻译，我承认谷歌翻译真的很NB。</li>\n</ol>\n<h2 id=\"有什么总结\"><a href=\"#有什么总结\" class=\"headerlink\" title=\"有什么总结\"></a>有什么总结</h2><ol>\n<li>要彻底弄懂this的机制，首先你要准备好面向对象的基础，理解OOP的重要概念：<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript\" target=\"_blank\" rel=\"noopener\">JavaScript面向对象编程</a></li>\n</ul>\n</li>\n<li>然后记住，this是一个变量，它是一个指针，指向一个对象。再看我的文档:<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"noopener\">this关键字</a></li>\n</ul>\n</li>\n<li>在过程中看不懂时，及时查阅相关API的文档:<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">箭头函数</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\">Function.prototype.call()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">Function.prototype.apply()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">Function.prototype.bind()</a></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"写在结尾\"><a href=\"#写在结尾\" class=\"headerlink\" title=\"写在结尾\"></a>写在结尾</h2><p>在英文文档末尾的参考链接，有一篇写得非常精彩的博客：<br><a href=\"https://rainsoft.io/gentle-explanation-of-this-in-javascript/\" target=\"_blank\" rel=\"noopener\">Gentle-explanation-of-this-in-JavaScript, 温和解释JS中的this</a></p>\n<p>计划在不久将来，我会挤出时间认真翻译这篇英文博客。</p>\n<p>The end.</p>\n","site":{"data":{}},"excerpt":"<p>9月4日翻译了MDN上的一篇英文文档，这是第一次尝试翻译，尝到了成就感.<br>","more":"</p>\n<p>MDN是Web开发者的参考文档的官方网站——<a href=\"https://developer.mozilla.org/zh-CN/\" target=\"_blank\" rel=\"noopener\">MDN Web 文档</a>，有大量开发者不断贡献和更新文档和教程。</p>\n<h2 id=\"做了什么\"><a href=\"#做了什么\" class=\"headerlink\" title=\"做了什么\"></a>做了什么</h2><p>最近，在对JavaScript中this关键字的细节整理中，查阅MDN的中文文档，有些语句翻译的不错，但是还是存在部分疏漏。</p>\n<p>仔细一番MDN的一些中文文档，少数文档的部分语句有明显的语义和内容上的毛病。</p>\n<p>索性去看英文文档，豁然开朗，遂决定更新中文翻译文档。</p>\n<p>在9月4日翻译了MDN上JavaScript的this关键字的英文文档：<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"noopener\">原版英文文档</a>。</p>\n<ol>\n<li>保留了部分原有翻译，纠正了大部分语义措辞漏洞，并更新了关于箭头函数的this指向。</li>\n<li>部分语句参考了谷歌翻译，我承认谷歌翻译真的很NB。</li>\n</ol>\n<h2 id=\"有什么总结\"><a href=\"#有什么总结\" class=\"headerlink\" title=\"有什么总结\"></a>有什么总结</h2><ol>\n<li>要彻底弄懂this的机制，首先你要准备好面向对象的基础，理解OOP的重要概念：<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript\" target=\"_blank\" rel=\"noopener\">JavaScript面向对象编程</a></li>\n</ul>\n</li>\n<li>然后记住，this是一个变量，它是一个指针，指向一个对象。再看我的文档:<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"noopener\">this关键字</a></li>\n</ul>\n</li>\n<li>在过程中看不懂时，及时查阅相关API的文档:<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">箭头函数</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\">Function.prototype.call()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">Function.prototype.apply()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">Function.prototype.bind()</a></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"写在结尾\"><a href=\"#写在结尾\" class=\"headerlink\" title=\"写在结尾\"></a>写在结尾</h2><p>在英文文档末尾的参考链接，有一篇写得非常精彩的博客：<br><a href=\"https://rainsoft.io/gentle-explanation-of-this-in-javascript/\" target=\"_blank\" rel=\"noopener\">Gentle-explanation-of-this-in-JavaScript, 温和解释JS中的this</a></p>\n<p>计划在不久将来，我会挤出时间认真翻译这篇英文博客。</p>\n<p>The end.</p>"},{"title":"Array.prototype.sort()的高级用法","date":"2018-01-27T16:00:00.000Z","update":"2018-04-17T16:00:00.000Z","_content":"\n# Array.prototype.sort()\n## 一、基本操作\n`sort()`方法的默认排序顺序是根据串Unicode码点。\n<!-- more -->\n\n```\nvar fruit = ['cherries', 'apples', 'bananas'];\nfruit.sort();\n//['apples', 'bananas', 'cherries']\n\nvar scores = [1, 10, 21, 2];\nscores.sort();\n//[1, 10, 2, 21]\n//这里的10竟然在2之前，因为在Unicode指针顺序中 '10' 在 '2' 之前。\n```\n\n## 二、进阶操作（compareFunction）\n这时我们需要一个比较函数，来得到我们所需要的排序。\n如果指明了`compareFunction`,那么数组会按照调用**该函数的返回值**排序。即a和b是两个将要被比较的元素：\n\n### 2.0 字符串排序\n```\nvar str_arr = ['cherries', 'apples', 'bananas'];\nfunction compareStr(a, b){\n\tif(a<b){\n\t\treturn -1;\n\t}\n\tif(a>b){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nstr_arr.sort(compareStr);\n// ['apples', 'bananas', 'cherries']\n```\n### 2.1 数字排序\n- 如果compareFunction(a, b)小于0，那么a会排到b之前；\n- 如果compareFunction(a, b)等于0 ,  那么位置不变；\n- 如果compareFunction(a, b)大于0，那么b会排到a之前；\n```\nfunction compareNumbers(a, b){\n\treturn a - b;\n}\n\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort(function(a, b){\n\treturn a - b;\n});\nconsole.log(numbers);\n\n//也可以写成：\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);\n\n//输出：[1, 2, 3, 4, 5]\n``` \n### 2.2 对象按照某个属性排序\n```\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic' },\n  { name: 'Zeros', value: 37 }\n];\n\n//按value值排序\nitems.sort(function (a,b){\n\treturn (a,.value - b.value)\n});\n\n//按name值排序\nitems.sort(function(a, b){\n\tvar nameA = a.name.toUpperCase();\n\tvar nameB = b.name.toUpperCase();\n\tif(nameA < nameB){\n\t\treturn -1;\n\t}\n\tif(nameA > nameB){\n\t\treturn 1;\n\t}\n\treturn 0;\n});\n```\n\n## 三、高级操作：使用映射改善排序\n`compareFunction`可能需要对元素做多次映射以实现排序，尤其当compareFunction较为复杂，且元素较多的时候，某些compareFunction 可能会导致很高的负载。使用map辅助排序将会是个好主意。\n\n基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。\n\n```\n// 需要被排序的数组\nvar list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];\n\n// 对需要排序的数字和位置的临时存储, mapped为临时容器\nvar mapped = list.map(function(el, i) {\n  return { index: i, value: el.toLowerCase() };\n})\n\n// 按照多个值排序数组\nmapped.sort(function(a, b) {\n  return +(a.value > b.value) || +(a.value === b.value) - 1;\n});\n\n// 根据索引得到排序的结果\nvar result = mapped.map(function(el){\n  return list[el.index];\n});\n//result : [\"alpha\", \"bravo\", \"CHARLIE\", \"Delta\"]\n```\n\n<br><br><br><br><br><br><br><br><br><br><br>\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2018-01-28 Array.prototype.sort的高级用法.md","raw":"---\n\ntitle: Array.prototype.sort()的高级用法\ncategories: 技术\ndate: 2018-01-28 \nupdate: 2018-04-18\ntags: JavaScript\n\n---\n\n# Array.prototype.sort()\n## 一、基本操作\n`sort()`方法的默认排序顺序是根据串Unicode码点。\n<!-- more -->\n\n```\nvar fruit = ['cherries', 'apples', 'bananas'];\nfruit.sort();\n//['apples', 'bananas', 'cherries']\n\nvar scores = [1, 10, 21, 2];\nscores.sort();\n//[1, 10, 2, 21]\n//这里的10竟然在2之前，因为在Unicode指针顺序中 '10' 在 '2' 之前。\n```\n\n## 二、进阶操作（compareFunction）\n这时我们需要一个比较函数，来得到我们所需要的排序。\n如果指明了`compareFunction`,那么数组会按照调用**该函数的返回值**排序。即a和b是两个将要被比较的元素：\n\n### 2.0 字符串排序\n```\nvar str_arr = ['cherries', 'apples', 'bananas'];\nfunction compareStr(a, b){\n\tif(a<b){\n\t\treturn -1;\n\t}\n\tif(a>b){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nstr_arr.sort(compareStr);\n// ['apples', 'bananas', 'cherries']\n```\n### 2.1 数字排序\n- 如果compareFunction(a, b)小于0，那么a会排到b之前；\n- 如果compareFunction(a, b)等于0 ,  那么位置不变；\n- 如果compareFunction(a, b)大于0，那么b会排到a之前；\n```\nfunction compareNumbers(a, b){\n\treturn a - b;\n}\n\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort(function(a, b){\n\treturn a - b;\n});\nconsole.log(numbers);\n\n//也可以写成：\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);\n\n//输出：[1, 2, 3, 4, 5]\n``` \n### 2.2 对象按照某个属性排序\n```\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic' },\n  { name: 'Zeros', value: 37 }\n];\n\n//按value值排序\nitems.sort(function (a,b){\n\treturn (a,.value - b.value)\n});\n\n//按name值排序\nitems.sort(function(a, b){\n\tvar nameA = a.name.toUpperCase();\n\tvar nameB = b.name.toUpperCase();\n\tif(nameA < nameB){\n\t\treturn -1;\n\t}\n\tif(nameA > nameB){\n\t\treturn 1;\n\t}\n\treturn 0;\n});\n```\n\n## 三、高级操作：使用映射改善排序\n`compareFunction`可能需要对元素做多次映射以实现排序，尤其当compareFunction较为复杂，且元素较多的时候，某些compareFunction 可能会导致很高的负载。使用map辅助排序将会是个好主意。\n\n基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。\n\n```\n// 需要被排序的数组\nvar list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];\n\n// 对需要排序的数字和位置的临时存储, mapped为临时容器\nvar mapped = list.map(function(el, i) {\n  return { index: i, value: el.toLowerCase() };\n})\n\n// 按照多个值排序数组\nmapped.sort(function(a, b) {\n  return +(a.value > b.value) || +(a.value === b.value) - 1;\n});\n\n// 根据索引得到排序的结果\nvar result = mapped.map(function(el){\n  return list[el.index];\n});\n//result : [\"alpha\", \"bravo\", \"CHARLIE\", \"Delta\"]\n```\n\n<br><br><br><br><br><br><br><br><br><br><br>\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2018-01-28 Array.prototype.sort的高级用法","published":1,"updated":"2018-12-24T08:03:50.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq21cm820012jts4ylo3c2m3","content":"<h1 id=\"Array-prototype-sort\"><a href=\"#Array-prototype-sort\" class=\"headerlink\" title=\"Array.prototype.sort()\"></a>Array.prototype.sort()</h1><h2 id=\"一、基本操作\"><a href=\"#一、基本操作\" class=\"headerlink\" title=\"一、基本操作\"></a>一、基本操作</h2><p><code>sort()</code>方法的默认排序顺序是根据串Unicode码点。<br><a id=\"more\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fruit = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];</span><br><span class=\"line\">fruit.sort();</span><br><span class=\"line\">//[&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">var scores = [1, 10, 21, 2];</span><br><span class=\"line\">scores.sort();</span><br><span class=\"line\">//[1, 10, 2, 21]</span><br><span class=\"line\">//这里的10竟然在2之前，因为在Unicode指针顺序中 &apos;10&apos; 在 &apos;2&apos; 之前。</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、进阶操作（compareFunction）\"><a href=\"#二、进阶操作（compareFunction）\" class=\"headerlink\" title=\"二、进阶操作（compareFunction）\"></a>二、进阶操作（compareFunction）</h2><p>这时我们需要一个比较函数，来得到我们所需要的排序。<br>如果指明了<code>compareFunction</code>,那么数组会按照调用<strong>该函数的返回值</strong>排序。即a和b是两个将要被比较的元素：</p>\n<h3 id=\"2-0-字符串排序\"><a href=\"#2-0-字符串排序\" class=\"headerlink\" title=\"2.0 字符串排序\"></a>2.0 字符串排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str_arr = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];</span><br><span class=\"line\">function compareStr(a, b)&#123;</span><br><span class=\"line\">\tif(a&lt;b)&#123;</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(a&gt;b)&#123;</span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">str_arr.sort(compareStr);</span><br><span class=\"line\">// [&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-数字排序\"><a href=\"#2-1-数字排序\" class=\"headerlink\" title=\"2.1 数字排序\"></a>2.1 数字排序</h3><ul>\n<li>如果compareFunction(a, b)小于0，那么a会排到b之前；</li>\n<li>如果compareFunction(a, b)等于0 ,  那么位置不变；</li>\n<li>如果compareFunction(a, b)大于0，那么b会排到a之前；<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function compareNumbers(a, b)&#123;</span><br><span class=\"line\">\treturn a - b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var numbers = [4, 2, 5, 1, 3];</span><br><span class=\"line\">numbers.sort(function(a, b)&#123;</span><br><span class=\"line\">\treturn a - b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(numbers);</span><br><span class=\"line\"></span><br><span class=\"line\">//也可以写成：</span><br><span class=\"line\">var numbers = [4, 2, 5, 1, 3];</span><br><span class=\"line\">numbers.sort((a, b) =&gt; a - b);</span><br><span class=\"line\">console.log(numbers);</span><br><span class=\"line\"></span><br><span class=\"line\">//输出：[1, 2, 3, 4, 5]</span><br><span class=\"line\">``` </span><br><span class=\"line\">### 2.2 对象按照某个属性排序</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>var items = [<br>  { name: ‘Edward’, value: 21 },<br>  { name: ‘Sharpe’, value: 37 },<br>  { name: ‘And’, value: 45 },<br>  { name: ‘The’, value: -12 },<br>  { name: ‘Magnetic’ },<br>  { name: ‘Zeros’, value: 37 }<br>];</p>\n<p>//按value值排序<br>items.sort(function (a,b){<br>    return (a,.value - b.value)<br>});</p>\n<p>//按name值排序<br>items.sort(function(a, b){<br>    var nameA = a.name.toUpperCase();<br>    var nameB = b.name.toUpperCase();<br>    if(nameA &lt; nameB){<br>        return -1;<br>    }<br>    if(nameA &gt; nameB){<br>        return 1;<br>    }<br>    return 0;<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 三、高级操作：使用映射改善排序</span><br><span class=\"line\">`compareFunction`可能需要对元素做多次映射以实现排序，尤其当compareFunction较为复杂，且元素较多的时候，某些compareFunction 可能会导致很高的负载。使用map辅助排序将会是个好主意。</span><br><span class=\"line\"></span><br><span class=\"line\">基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。</span><br></pre></td></tr></table></figure></p>\n<p>// 需要被排序的数组<br>var list = [‘Delta’, ‘alpha’, ‘CHARLIE’, ‘bravo’];</p>\n<p>// 对需要排序的数字和位置的临时存储, mapped为临时容器<br>var mapped = list.map(function(el, i) {<br>  return { index: i, value: el.toLowerCase() };<br>})</p>\n<p>// 按照多个值排序数组<br>mapped.sort(function(a, b) {<br>  return +(a.value &gt; b.value) || +(a.value === b.value) - 1;<br>});</p>\n<p>// 根据索引得到排序的结果<br>var result = mapped.map(function(el){<br>  return list[el.index];<br>});<br>//result : [“alpha”, “bravo”, “CHARLIE”, “Delta”]<br><code>`</code></p>\n<p><br><br><br><br><br><br><br><br><br><br><br></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Array-prototype-sort\"><a href=\"#Array-prototype-sort\" class=\"headerlink\" title=\"Array.prototype.sort()\"></a>Array.prototype.sort()</h1><h2 id=\"一、基本操作\"><a href=\"#一、基本操作\" class=\"headerlink\" title=\"一、基本操作\"></a>一、基本操作</h2><p><code>sort()</code>方法的默认排序顺序是根据串Unicode码点。<br>","more":"</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fruit = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];</span><br><span class=\"line\">fruit.sort();</span><br><span class=\"line\">//[&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">var scores = [1, 10, 21, 2];</span><br><span class=\"line\">scores.sort();</span><br><span class=\"line\">//[1, 10, 2, 21]</span><br><span class=\"line\">//这里的10竟然在2之前，因为在Unicode指针顺序中 &apos;10&apos; 在 &apos;2&apos; 之前。</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、进阶操作（compareFunction）\"><a href=\"#二、进阶操作（compareFunction）\" class=\"headerlink\" title=\"二、进阶操作（compareFunction）\"></a>二、进阶操作（compareFunction）</h2><p>这时我们需要一个比较函数，来得到我们所需要的排序。<br>如果指明了<code>compareFunction</code>,那么数组会按照调用<strong>该函数的返回值</strong>排序。即a和b是两个将要被比较的元素：</p>\n<h3 id=\"2-0-字符串排序\"><a href=\"#2-0-字符串排序\" class=\"headerlink\" title=\"2.0 字符串排序\"></a>2.0 字符串排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str_arr = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];</span><br><span class=\"line\">function compareStr(a, b)&#123;</span><br><span class=\"line\">\tif(a&lt;b)&#123;</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(a&gt;b)&#123;</span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">str_arr.sort(compareStr);</span><br><span class=\"line\">// [&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-数字排序\"><a href=\"#2-1-数字排序\" class=\"headerlink\" title=\"2.1 数字排序\"></a>2.1 数字排序</h3><ul>\n<li>如果compareFunction(a, b)小于0，那么a会排到b之前；</li>\n<li>如果compareFunction(a, b)等于0 ,  那么位置不变；</li>\n<li>如果compareFunction(a, b)大于0，那么b会排到a之前；<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function compareNumbers(a, b)&#123;</span><br><span class=\"line\">\treturn a - b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var numbers = [4, 2, 5, 1, 3];</span><br><span class=\"line\">numbers.sort(function(a, b)&#123;</span><br><span class=\"line\">\treturn a - b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(numbers);</span><br><span class=\"line\"></span><br><span class=\"line\">//也可以写成：</span><br><span class=\"line\">var numbers = [4, 2, 5, 1, 3];</span><br><span class=\"line\">numbers.sort((a, b) =&gt; a - b);</span><br><span class=\"line\">console.log(numbers);</span><br><span class=\"line\"></span><br><span class=\"line\">//输出：[1, 2, 3, 4, 5]</span><br><span class=\"line\">``` </span><br><span class=\"line\">### 2.2 对象按照某个属性排序</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>var items = [<br>  { name: ‘Edward’, value: 21 },<br>  { name: ‘Sharpe’, value: 37 },<br>  { name: ‘And’, value: 45 },<br>  { name: ‘The’, value: -12 },<br>  { name: ‘Magnetic’ },<br>  { name: ‘Zeros’, value: 37 }<br>];</p>\n<p>//按value值排序<br>items.sort(function (a,b){<br>    return (a,.value - b.value)<br>});</p>\n<p>//按name值排序<br>items.sort(function(a, b){<br>    var nameA = a.name.toUpperCase();<br>    var nameB = b.name.toUpperCase();<br>    if(nameA &lt; nameB){<br>        return -1;<br>    }<br>    if(nameA &gt; nameB){<br>        return 1;<br>    }<br>    return 0;<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 三、高级操作：使用映射改善排序</span><br><span class=\"line\">`compareFunction`可能需要对元素做多次映射以实现排序，尤其当compareFunction较为复杂，且元素较多的时候，某些compareFunction 可能会导致很高的负载。使用map辅助排序将会是个好主意。</span><br><span class=\"line\"></span><br><span class=\"line\">基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。</span><br></pre></td></tr></table></figure></p>\n<p>// 需要被排序的数组<br>var list = [‘Delta’, ‘alpha’, ‘CHARLIE’, ‘bravo’];</p>\n<p>// 对需要排序的数字和位置的临时存储, mapped为临时容器<br>var mapped = list.map(function(el, i) {<br>  return { index: i, value: el.toLowerCase() };<br>})</p>\n<p>// 按照多个值排序数组<br>mapped.sort(function(a, b) {<br>  return +(a.value &gt; b.value) || +(a.value === b.value) - 1;<br>});</p>\n<p>// 根据索引得到排序的结果<br>var result = mapped.map(function(el){<br>  return list[el.index];<br>});<br>//result : [“alpha”, “bravo”, “CHARLIE”, “Delta”]<br><code>`</code></p>\n<p><br><br><br><br><br><br><br><br><br><br><br></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjq21cm7c0005jts4d888hhx9","category_id":"cjq21cm770002jts4dk8c45d0","_id":"cjq21cm7n000djts41s8ozv31"},{"post_id":"cjq21cm6y0000jts4ihnsrpwz","category_id":"cjq21cm770002jts4dk8c45d0","_id":"cjq21cm7p000hjts43dh3v27q"},{"post_id":"cjq21cm7h0006jts463eo8v01","category_id":"cjq21cm770002jts4dk8c45d0","_id":"cjq21cm7r000kjts4gte59kco"},{"post_id":"cjq21cm7l000ajts4qo8ardtp","category_id":"cjq21cm770002jts4dk8c45d0","_id":"cjq21cm7t000pjts4w1iav39o"},{"post_id":"cjq21cm730001jts48jexsktj","category_id":"cjq21cm770002jts4dk8c45d0","_id":"cjq21cm7u000rjts47nzicjc4"},{"post_id":"cjq21cm7p000gjts4xe2g8vsf","category_id":"cjq21cm770002jts4dk8c45d0","_id":"cjq21cm7y000vjts4frwtzuts"},{"post_id":"cjq21cm7a0004jts48rhald30","category_id":"cjq21cm770002jts4dk8c45d0","_id":"cjq21cm80000yjts4uuqzcpy6"},{"post_id":"cjq21cm7m000cjts4jrs2tbbj","category_id":"cjq21cm7r000ljts4b5b3scvx","_id":"cjq21cm830013jts4u1jdl22u"},{"post_id":"cjq21cm7t000qjts45uh9vmd8","category_id":"cjq21cm770002jts4dk8c45d0","_id":"cjq21cm850015jts4pgl5fzed"},{"post_id":"cjq21cm7q000jjts4a7zbteea","category_id":"cjq21cm7r000ljts4b5b3scvx","_id":"cjq21cm870019jts4oss9nbe1"},{"post_id":"cjq21cm820012jts4ylo3c2m3","category_id":"cjq21cm770002jts4dk8c45d0","_id":"cjq21cm88001bjts4hiy67xow"},{"post_id":"cjq21cm7s000ojts4inwqetx5","category_id":"cjq21cm80000zjts4o09cowjy","_id":"cjq21cm8a001ejts4hzz8lo3u"},{"post_id":"cjq21cm7w000ujts4z2o0aljb","category_id":"cjq21cm870016jts4n8sdbu81","_id":"cjq21cm8e001hjts4326y7iky"},{"post_id":"cjq21cm7y000xjts40f0r6dm1","category_id":"cjq21cm80000zjts4o09cowjy","_id":"cjq21cm8e001kjts4malrecy6"}],"PostTag":[{"post_id":"cjq21cm7c0005jts4d888hhx9","tag_id":"cjq21cm7a0003jts4h6eatfio","_id":"cjq21cm7k0009jts47i40p95a"},{"post_id":"cjq21cm7h0006jts463eo8v01","tag_id":"cjq21cm7a0003jts4h6eatfio","_id":"cjq21cm7m000bjts4j24bcc67"},{"post_id":"cjq21cm6y0000jts4ihnsrpwz","tag_id":"cjq21cm7a0003jts4h6eatfio","_id":"cjq21cm7q000ijts4bi83se9a"},{"post_id":"cjq21cm6y0000jts4ihnsrpwz","tag_id":"cjq21cm7i0008jts4ib9v3phw","_id":"cjq21cm7r000mjts4nskgxwqp"},{"post_id":"cjq21cm730001jts48jexsktj","tag_id":"cjq21cm7a0003jts4h6eatfio","_id":"cjq21cm7y000wjts4mov1xtwy"},{"post_id":"cjq21cm730001jts48jexsktj","tag_id":"cjq21cm7r000njts4ce2gjjrt","_id":"cjq21cm810010jts4ej118ug6"},{"post_id":"cjq21cm7a0004jts48rhald30","tag_id":"cjq21cm7a0003jts4h6eatfio","_id":"cjq21cm840014jts4b54k7tkj"},{"post_id":"cjq21cm820012jts4ylo3c2m3","tag_id":"cjq21cm7a0003jts4h6eatfio","_id":"cjq21cm870017jts4qx6it8z2"},{"post_id":"cjq21cm7l000ajts4qo8ardtp","tag_id":"cjq21cm7i0008jts4ib9v3phw","_id":"cjq21cm87001ajts4lcynbrz8"},{"post_id":"cjq21cm7l000ajts4qo8ardtp","tag_id":"cjq21cm810011jts4cttci6lh","_id":"cjq21cm89001cjts4cunp01fl"},{"post_id":"cjq21cm7m000cjts4jrs2tbbj","tag_id":"cjq21cm870018jts4tbbyq9ar","_id":"cjq21cm8e001gjts4hohti3wz"},{"post_id":"cjq21cm7q000jjts4a7zbteea","tag_id":"cjq21cm8b001fjts4hmxwggpp","_id":"cjq21cm8e001jjts4ilwbwb1l"},{"post_id":"cjq21cm7t000qjts45uh9vmd8","tag_id":"cjq21cm7i0008jts4ib9v3phw","_id":"cjq21cm8f001mjts43f0aop44"},{"post_id":"cjq21cm7t000qjts45uh9vmd8","tag_id":"cjq21cm8e001ijts4l6xwbj4u","_id":"cjq21cm8f001njts4cd4onrk6"},{"post_id":"cjq21cm7w000ujts4z2o0aljb","tag_id":"cjq21cm8f001ljts4myldodxh","_id":"cjq21cm8g001pjts4iquvls7y"},{"post_id":"cjq21cm7y000xjts40f0r6dm1","tag_id":"cjq21cm8g001ojts4ernvhqrr","_id":"cjq21cm8g001qjts4cgepsf4t"}],"Tag":[{"name":"JavaScript","_id":"cjq21cm7a0003jts4h6eatfio"},{"name":"前端","_id":"cjq21cm7i0008jts4ib9v3phw"},{"name":"算法","_id":"cjq21cm7r000njts4ce2gjjrt"},{"name":"安全","_id":"cjq21cm810011jts4cttci6lh"},{"name":"学习笔记","_id":"cjq21cm870018jts4tbbyq9ar"},{"name":"指南 笔记 Mac","_id":"cjq21cm8b001fjts4hmxwggpp"},{"name":"CSS","_id":"cjq21cm8e001ijts4l6xwbj4u"},{"name":"随笔","_id":"cjq21cm8f001ljts4myldodxh"},{"name":"日志","_id":"cjq21cm8g001ojts4ernvhqrr"}]}}