<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript 事件处理摘要</title>
    <url>/2017/01/27/2017-01-27%20%E5%89%8D%E7%AB%AF-JavaScript%20Events%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="JavaScript-事件处理"><a href="#JavaScript-事件处理" class="headerlink" title="JavaScript 事件处理"></a>JavaScript 事件处理</h2><hr>
<h3 id="一、-事件处理："><a href="#一、-事件处理：" class="headerlink" title="一、 事件处理："></a>一、 事件处理：</h3><h4 id="1-嵌入式事件处理器（强烈不建议）"><a href="#1-嵌入式事件处理器（强烈不建议）" class="headerlink" title="1.嵌入式事件处理器（强烈不建议）:"></a>1.嵌入式事件处理器（强烈不建议）:</h4><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*比如*/</span></span><br><span class="line">      &lt;form <span class="attr">action=</span> <span class="string">&quot;#&quot;</span> <span class="attr">method</span> = <span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span> = <span class="string">&quot;validataForm();&quot;</span>&gt;</span><br><span class="line">      <span class="comment">/*或者*/</span></span><br><span class="line">   	&lt;a <span class="attr">href</span> = <span class="string">&quot;somepage.html&quot;</span> <span class="attr">onclick</span> = <span class="string">&quot;doSomething();&quot;</span>&gt;Some link&lt;/a&gt; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="2-传统事件处理方法-不建议-："><a href="#2-传统事件处理方法-不建议-：" class="headerlink" title="2.传统事件处理方法(不建议)："></a>2.传统事件处理方法(不建议)：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下传统方法不建议使用 */</span></span><br><span class="line"><span class="built_in">window</span>.onload = init; <span class="comment">//易用，可靠，属性名必须全小写。</span></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//匿名函数方法</span></span><br><span class="line"><span class="comment">//Do whatever.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原因：<br>        1. 一次只能指定一个时间处理器；<br>        2. 较后的函数会覆盖较前的；</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;theForm&#x27;</span>).onsubmit = progress;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;theForm&#x27;</span>).onsubmit = calculate; <span class="comment">// 呃!有问题.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓解方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;theForm&#x27;</span>).onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	progress();  <span class="comment">//当然你也可以这样解决，但是这样的代码很丑陋。</span></span><br><span class="line">	calculate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-W3C事件处理-建议"><a href="#3-W3C事件处理-建议" class="headerlink" title="3.W3C事件处理(建议)"></a>3.W3C事件处理(建议)</h4><ol>
<li><p>接受三个参数：事件类型，事件发生时调用的函数，表示事件阶段的布尔值。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">add<span class="constructor">EventListener(&#x27;<span class="params">load</span>&#x27;, <span class="params">init</span> , <span class="params">false</span>)</span>;  <span class="comment">//可以为相同元素添加多个事件监听器；`</span></span><br><span class="line">remove<span class="constructor">EventListener()</span>(&#x27;load&#x27;, process , <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>IE&lt;9的事件处理(事件名称前缀多了”on”)</p>
<pre><code> 1. attachEvent(&#39;onload&#39; , init);
 2. detachEvent(&#39;onload&#39; , init);
</code></pre>
</li>
<li><p>创建一个事件分配器</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params"> obj , type , fn</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(obj &amp;&amp; objEventListener)&#123;          <span class="comment">//W3c</span></span><br><span class="line">          obj.addEventListener(type, fn , <span class="literal">false</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj &amp;&amp; obj.attachEvent)&#123;     <span class="comment">//IE&lt;9</span></span><br><span class="line">          obj.attachEvent(<span class="string">&quot;on&quot;</span> + type, fn);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="4-范例：创建一个实用程序库"><a href="#4-范例：创建一个实用程序库" class="headerlink" title="4. 范例：创建一个实用程序库"></a>4. <strong>范例：创建一个实用程序库</strong></h4></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有函数都定义在全局对象U中，避免多个新函数污染全局命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新对象U （Utility的缩写）</span></span><br><span class="line"><span class="keyword">var</span> U = &#123;</span><br><span class="line">      <span class="comment">//定义$()方法</span></span><br><span class="line">      $: <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line"><span class="meta">           &#x27;use strict&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">typeof</span> id == <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="comment">//定义setText 方法，两个参数：要更新的元素id和消息本身</span></span><br><span class="line">      setText: <span class="function"><span class="keyword">function</span>(<span class="params">id, message</span>)</span>&#123;</span><br><span class="line"><span class="meta">      	&#x27;use strict&#x27;</span>;</span><br><span class="line">      	<span class="keyword">if</span>( (<span class="keyword">typeof</span> id == <span class="string">&#x27;string&#x27;</span>) &amp;&amp; (<span class="keyword">typeof</span> message == <span class="string">&#x27;string&#x27;</span>))&#123;</span><br><span class="line">      		<span class="keyword">var</span> output = <span class="built_in">this</span>.$(id);</span><br><span class="line">      		<span class="keyword">if</span> (!output) &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;;	<span class="comment">//获取id的元素失败</span></span><br><span class="line">      		<span class="keyword">if</span>(output.textContext !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">      			output.textContext = message;</span><br><span class="line">      		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      			output.innerText = message;</span><br><span class="line">      		&#125;</span><br><span class="line">      		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      	&#125;	<span class="comment">//End of main IF.</span></span><br><span class="line">      &#125;, 	<span class="comment">//End of setText() function.</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//封装一个‘添加事件监听器’ 函数</span></span><br><span class="line">      addEvent: <span class="function"><span class="keyword">function</span>(<span class="params"> obj , type , fn</span>)</span>&#123;</span><br><span class="line"><span class="meta">      		&#x27;use strict&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(obj &amp;&amp; obj.removeEventListener)&#123;</span><br><span class="line">            	obj.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (obj &amp;&amp; obj.detachEvent)&#123;</span><br><span class="line">            	obj.attachEvent(<span class="string">&#x27;on&#x27;</span> + type , fn);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,   	<span class="comment">//End of addEvent() function</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//封装一个‘移除事件监听器’函数</span></span><br><span class="line">      removeEvent: <span class="function"><span class="keyword">function</span>(<span class="params"> obj , type , fn</span>)</span>&#123;</span><br><span class="line"><span class="meta">      		&#x27;use strict&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(obj &amp;&amp; obj.removeEventListener)&#123;</span><br><span class="line">            	obj.removeEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (obj &amp;&amp; obj.detachEvent)&#123;</span><br><span class="line">            	obj.detachEvent(<span class="string">&#x27;on&#x27;</span> + type , fn);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;   	<span class="comment">//End of removeEvent() function</span></span><br><span class="line"> &#125;;	<span class="comment">//End of U declaration.</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二、事件类型"><a href="#二、事件类型" class="headerlink" title="二、事件类型"></a>二、事件类型</h3><p><strong>事件类型分为4类：</strong></p>
<ul>
<li><strong>输入设备</strong></li>
<li><strong>键盘</strong></li>
<li><strong>浏览器</strong></li>
<li><strong>表单</strong> </li>
</ul>
<h4 id="1-输入设备事件"><a href="#1-输入设备事件" class="headerlink" title="1.输入设备事件"></a>1.输入设备事件</h4><h5 id="1-输入按钮事件："><a href="#1-输入按钮事件：" class="headerlink" title="1. 输入按钮事件："></a>1. 输入按钮事件：</h5><pre><code>    1. click 事件；
    2. dblclick 事件；
    3. contextmenu 事件(罕见)；
</code></pre>
<h5 id="2-输入移动事件："><a href="#2-输入移动事件：" class="headerlink" title="2. 输入移动事件："></a>2. 输入移动事件：</h5><pre><code>    1.  mouseout 鼠标移出;
    2.  mouseover 鼠标移过;
    3.  mousemove 鼠标移动（持续监视鼠标，消耗性能）;
</code></pre>
<h5 id="3-键盘事件："><a href="#3-键盘事件：" class="headerlink" title="3. 键盘事件："></a>3. 键盘事件：</h5><pre><code>    1.   keydown (按下);
    2.   keyup (释放); 
    3.   keypress (按键，前二者组合);
</code></pre>
<h5 id="4-浏览器事件："><a href="#4-浏览器事件：" class="headerlink" title="4. 浏览器事件："></a>4. 浏览器事件：</h5><pre><code>    1. load (加载完成);
    2. unload (卸载);
    3. resize (改变浏览器窗口大小);
    4. scroll (滚动事件);
    5. copy;
    6. cut;
    7. paste;  
</code></pre>
<h5 id="5-表单事件："><a href="#5-表单事件：" class="headerlink" title="5. 表单事件："></a>5. 表单事件：</h5><p>   – <strong>reset</strong>：表单重置(点击重置html按钮)时触发，用户很少有重置表单的需要；若要使用此事件，可以添加监视：     </p>
<pre><code>        <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addEvent(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;theForm&#x27;</span>), <span class="string">&#x27;reset&#x27;</span> , <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> confirm(<span class="string">&quot;您确定想要重置表单吗？&quot;</span>);		</span><br><span class="line">&#125;);</span><br><span class="line">         </span><br></pre></td></tr></table></figure>
</code></pre>
<p><img src="http://img.blog.csdn.net/20161210172136724?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="重置表单提醒"></p>
<p>– <strong>select</strong>: 文本输入域和文本区域的文本内容被选中时；</p>
<p>– <strong>change</strong>: 元素值变化时；</p>
<p>– <strong>focus</strong>: 单击或Tab键到文本输入域时；</p>
<p>– <strong>blur</strong>: 光标或选择项的移动时；</p>
<hr>
<h3 id="三、事件可访问性-Accessibility"><a href="#三、事件可访问性-Accessibility" class="headerlink" title="三、事件可访问性(Accessibility)"></a>三、事件可访问性(Accessibility)</h3><h4 id="1-配对事件-Pairing-events"><a href="#1-配对事件-Pairing-events" class="headerlink" title="1. 配对事件(Pairing events):"></a>1. 配对事件(Pairing events):</h4><blockquote>
<p>使用同一个函数处理相同元素的类似事件。</p>
</blockquote>
<h4 id="2-可访问性-Accessibility"><a href="#2-可访问性-Accessibility" class="headerlink" title="2. 可访问性(Accessibility):"></a>2. 可访问性(Accessibility):</h4><p>在移动设备和其他非标准浏览器上，对于不使用输入设备的浏览器，mouseover和mouseout事件毫无意义，因为它们永远不会发生。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href &#x3D; &quot;somepage.html&quot; id &#x3D; &quot;link&quot; &gt; Some Text &lt;&#x2F;a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">addEvent(document.getElementById(&#39;link&#39;), &#39;mouseover&#39;,handleLinkMouseOver);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码中，事件只能通过鼠标触发。<br>但是还是有缓解方法。<br>如果浏览器仅由键盘控制，那么它是可以监视<strong>focus</strong>事件的(Tab键)。<br>因此，<strong>增强可访问性</strong>的事件处理方法是创建两个事件监听器：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href &#x3D; &quot;somepage.html&quot; id &#x3D; &quot;link&quot;&gt;some Text&lt;&#x2F;a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;配对事件</span><br><span class="line">addEvent(document.getElementById(&#39;link&#39;), &#39;mouseover&#39;, doSomething);</span><br><span class="line">addEvent(document.getElementById(&#39;link&#39;), &#39;focus&#39;, doSomething);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-事件和渐进增强"><a href="#3-事件和渐进增强" class="headerlink" title="3.事件和渐进增强"></a>3.事件和渐进增强</h4><ul>
<li>渐进增强的真正原则： <blockquote>
<p>使用JavaScript( 和CSS )改进<strong>基本功能</strong>，使得用户不管使用何种设备，都不会被抛弃(忽略)。</p>
</blockquote>
<ul>
<li>只有在开发者有意识的<strong>忽略</strong>一些用户时，JavaScript才是有必要的。</li>
<li>但是在很多情况下，<strong>JavaScript是没有必要的</strong>：比如表单的提交应该在有无JavaScript的情况下都能进行(在服务端都能验证)。</li>
<li>将<strong>渐进增强的思想</strong>应用到事件处理中，向已经有默认事件行为的元素添加事件时必须小心。例如：表单提交时，表单的数据发送给服务器端脚本。为表单添加提交事件，为其添加其他功能，在逻辑上是毫无意义的。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、高级事件处理"><a href="#四、高级事件处理" class="headerlink" title="四、高级事件处理"></a>四、高级事件处理</h3><ul>
<li>引用事件</li>
<li>事件属性</li>
<li>检查按键</li>
<li>阻止默认事件行为</li>
<li>事件的两个阶段：捕捉和冒泡</li>
<li>委派事件处理 </li>
</ul>
<h4 id="1-引用事件"><a href="#1-引用事件" class="headerlink" title="1.引用事件"></a>1.引用事件</h4><blockquote>
<p>当事件处理程序用于多个元素上的相同事件（或者相同元素上的不同事件）时，事件处理程序就必须考虑其灵活性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someEventHandler</span>(<span class="params">e</span>)</span>&#123;  <span class="comment">//e就是引用事件，代表发生的事件</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> e == <span class="string">&quot;undefined&quot;</span>)&#123;</span><br><span class="line">		e = <span class="built_in">window</span>.event;      <span class="comment">//考虑IE8及更早</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-事件属性"><a href="#2-事件属性" class="headerlink" title="2.事件属性"></a>2.事件属性</h4><blockquote>
<p>事件对象通过各种属性提供信息，但是不同浏览器支持的属性有所差异。(这里不深究，后续补充。)</p>
</blockquote>
<h4 id="3-检查按键"><a href="#3-检查按键" class="headerlink" title="3.检查按键"></a>3.检查按键</h4><blockquote>
<p>当键盘事件触发时，可以通过事件对象确定按下的具体键。这个问题有点复杂，在这里稍微带过。</p>
</blockquote>
<p>示例代码：以一致的方式获得字符：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> charCode = <span class="keyword">e</span>.<span class="keyword">which</span> || <span class="keyword">e</span>.keyCode;	<span class="comment">//IE中不支持which</span></span><br><span class="line"><span class="comment">// 或者更准确的</span></span><br><span class="line"><span class="keyword">var</span> charCode = (<span class="keyword">typeof</span> <span class="keyword">e</span>.<span class="keyword">which</span> == &#x27;number&#x27;)?<span class="keyword">e</span>.<span class="keyword">which</span> : <span class="keyword">e</span>.keyCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得与字符代码相对应的实际字符:</span></span><br><span class="line">String.fromCharCode(charcode);</span><br></pre></td></tr></table></figure>

<h4 id="4-阻止事件默认行为"><a href="#4-阻止事件默认行为" class="headerlink" title="4.阻止事件默认行为"></a>4.阻止事件默认行为</h4><blockquote>
<p>一些与基本浏览器相关的JS事件： 单击链接、提交表单等。在事件处理器存在时，事件发生会调用对应的函数，<strong>在函数运行之后，浏览器仍然继续进行它通常应该进行的事件处理。</strong><br>例如：提交表单时，提交事件处理器可能执行客户端验证。<strong>如果发生了错误，应该阻止表单提交到服务器端脚本，让客户有机会改正错误。</strong><br>方法：<strong>从事件处理器中返回false</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅在传统方法注册事件处理器时可靠工作，不建议。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleForm</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//Do whatever.</span></span><br><span class="line">	<span class="keyword">if</span>(errors)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是跨浏览器的兼容方法，调用事件对象的preventDefault();</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> e == <span class="string">&#x27;undefined&#x27;</span>) &#123;e = <span class="built_in">window</span>.event;&#125;</span><br><span class="line"><span class="keyword">if</span>(e.preventDefault)&#123;</span><br><span class="line">	e.preventDefault();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	e.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//额外的预防措施。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用PreventDefault()或设置returnValue的另一个好处就是：<strong>可以在函数开始时执行，使后续的函数代码仍然运行。</strong></p>
</blockquote>
<h4 id="5-事件的两个阶段：捕捉和冒泡"><a href="#5-事件的两个阶段：捕捉和冒泡" class="headerlink" title="5.事件的两个阶段：捕捉和冒泡"></a>5.事件的两个阶段：捕捉和冒泡</h4><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;h1&gt;This is a title&lt;&#x2F;h1&gt;</span><br><span class="line">	&lt;p&gt;This is a paragraph.</span><br><span class="line">		&lt;a href &#x3D; &quot;#&quot; id &#x3D; &quot;link&quot;&gt;This is a link.&lt;&#x2F;a&gt;</span><br><span class="line">	&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	&#x2F;&#x2F; U.$()方法与jquery获取DOM节点方法一致，只是在前文定义了一个新对象U.</span><br><span class="line">	addEvent(U.$(&#39;link&#39;), &#39;mouseover&#39; , doSomething);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**在上述代码中，包含关系：a&lt; p&lt; div&lt; html&lt; Document&lt; window。当鼠标悬停在链接之上，mouseover事件实际上经历了几个步骤，在两个不同的阶段到达和离开目标（链接）。</p>
<p><img src="http://img.blog.csdn.net/20161211094137004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lubmVyMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<blockquote>
<p>注意，事件传播一共有<strong>三个阶段</strong>：1.捕获阶段； 2.调用事件处理程序； 3.冒泡阶段。</p>
</blockquote>
<p>1.捕捉阶段：</p>
<blockquote>
<p>当你使用事件捕获时，由外向内，父级元素先触发，子级元素后触发；即div先触发，p后触发。</p>
</blockquote>
<p>2.事件处理：</p>
<blockquote>
<p>调用查找到的事件处理程序；</p>
</blockquote>
<p>3.冒泡阶段：</p>
<blockquote>
<p>事件冒泡<br>当你使用事件冒泡时，由内向外，子级元素先触发，父级元素后触发；即p先触发，div后触发。</p>
</blockquote>
<ul>
<li>W3C模型</li>
</ul>
<blockquote>
<p>在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。</p>
</blockquote>
<p>程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ele.add<span class="constructor">EventListener(&#x27;<span class="params">click</span>&#x27;,<span class="params">doSomething2</span>,<span class="params">true</span>)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>true=捕获 false=冒泡</p>
</blockquote>
<ul>
<li>传统绑定事件方式</li>
</ul>
<blockquote>
<p>在一个支持W3C DOM的浏览器中，像这样一般的绑定事件方式，是采用的事件冒泡方式。</p>
</blockquote>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ele.onclick</span> = doSomething2</span><br></pre></td></tr></table></figure>

<ul>
<li>IE浏览器</li>
</ul>
<blockquote>
<p>如上面所说，IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ele.attach<span class="constructor">Event(<span class="string">&quot;onclick&quot;</span>, <span class="params">doSomething2</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。</p>
<ul>
<li>事件的传播是可以阻止的：<br>• 在W3C中，使用stopPropagation（）方法<br>• 在IE下设置cancelBubble = true；</li>
</ul>
<blockquote>
<p>在捕获的过程中<code>stopPropagation（）;</code>后，后面的冒泡过程也不会发生了</p>
</blockquote>
<ul>
<li>阻止事件的默认行为<ul>
<li>例如click后的跳转:<br>• 在W3C中，使用preventDefault（）方法；<br>• 在IE下设置window.event.returnValue = false;</li>
</ul>
</li>
</ul>
<p>终于写完了，花了一天时间总结了”事件处理”，文末部分参考了网友的经验。</p>
<p>九月份看的《JS高级程序设计》，当时云里雾里，后来敲了很多代码半懂不懂，现在写完这篇博客才算明白过来。</p>
<p>在写的时候翻阅《JS权威指南》，里面有更深入的细节，有一部分事件类型已经被HTML5标准化。</p>
<h3 id="参考书籍："><a href="#参考书籍：" class="headerlink" title="参考书籍："></a>参考书籍：</h3><blockquote>
<p>《Modern JavaScript》(Larry Ullman 著);<br>《JavaScript高级程序设计》 (Nicholas C Zakas著).</p>
</blockquote>
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjk0MTU3NTgyXX0=
-->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基本概念(1)</title>
    <url>/2017/03/06/2017-03-06%20%E5%89%8D%E7%AB%AF-JavaScript%E7%B2%BE%E9%AB%93(1)/</url>
    <content><![CDATA[<h1 id="1-JavaScript的基本数据类型"><a href="#1-JavaScript的基本数据类型" class="headerlink" title="1. JavaScript的基本数据类型"></a>1. JavaScript的基本数据类型</h1><ol>
<li>Undefined</li>
<li>Null</li>
<li>Number</li>
<li>Boolean</li>
<li>String</li>
<li>Symbol(ES2015新增)</li>
</ol>
<h1 id="2-JavaScript的内置对象"><a href="#2-JavaScript的内置对象" class="headerlink" title="2. JavaScript的内置对象"></a>2. JavaScript的内置对象</h1><ul>
<li>Object 是JS中所有对象的父对象</li>
<li>数据封装类对象：</li>
</ul>
<ol>
<li>Object</li>
<li>Array</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ol>
<ul>
<li>其他对象：<ol>
<li>Function</li>
<li>Arguments</li>
<li>Math</li>
<li>Date</li>
<li>RegExp</li>
<li>Error </li>
</ol>
</li>
</ul>
<blockquote>
<p>参考文档：<a href="http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html">文档链接</a></p>
</blockquote>
<h1 id="3-JavaScript-中有几种类型的值？"><a href="#3-JavaScript-中有几种类型的值？" class="headerlink" title="3. JavaScript 中有几种类型的值？"></a>3. JavaScript 中有几种类型的值？</h1><ul>
<li><p>栈(Stack)：原始(primitive)数据类型(Undefined, Null , Boolean, Number, String)</p>
</li>
<li><p>堆(Heap)：合成(complex)数据类型(Object, Array, Function)</p>
</li>
<li><p>两种类型的区别是： <strong>存储位置不同</strong></p>
</li>
<li><p>原始数据类型：直接存储在<strong>栈</strong>中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据，所以放入栈中存储；</p>
</li>
<li><p>引用数据类型：存储在堆(Heap)中的对象，占据空间大，大小不固定。如果存储在栈中，则会影响程序的性能。</p>
<blockquote>
<p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后，从堆中获得实体。</p>
</blockquote>
</li>
<li><p>内存图：<br><img src="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" alt="enter image description here"></p>
</li>
</ul>
<h1 id="4-null和undefined的区别"><a href="#4-null和undefined的区别" class="headerlink" title="4. null和undefined的区别"></a>4. null和undefined的区别</h1><ul>
<li><p>null 表示”没有对象”，即该处不应该有值，典型用法：</p>
<blockquote>
<ol>
<li>作为函数的参数，表示该函数的参数不是对象。</li>
<li>作为对象原型链的终点。 </li>
</ol>
</blockquote>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>undefined 表示“缺少值”，即此处应该有值，但是没有被赋值，典型用法：</p>
<blockquote>
<ol>
<li>变量被声明了，但是没有赋值，默认等于undefined。</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
<li>对象没有赋值的属性，该属性默认值为undefined。</li>
<li>函数没有返回值时，默认返回undefined。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i  <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</span><br><span class="line">f() <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = f();</span><br><span class="line">x <span class="comment">//undefinde</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二者的测试</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> == <span class="string">&quot;undefined&quot;</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> == <span class="string">&quot;object&quot;</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)  <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注意：<br> 在验证null时，一定要使用 <code>===</code>,因为 <code>==</code> 无法分辨null和undefined：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
<li>打个比方： </li>
</ol>
<ul>
<li>null<ul>
<li>Q: 有张三这个人吗？</li>
<li>A:  有！</li>
<li>Q: 张三有房子吗？</li>
<li>A: 没有！</li>
</ul>
</li>
<li>undefined<ul>
<li>Q: 有张三这个人吗？</li>
<li>A: 有！</li>
<li>Q: 张三多少岁了？</li>
<li>A: 不知道（没有被告诉）</li>
</ul>
</li>
</ul>
<h1 id="5-JavaScript的this"><a href="#5-JavaScript的this" class="headerlink" title="5. JavaScript的this"></a>5. JavaScript的this</h1><ul>
<li>this是一个指针</li>
<li>this的指向：<ol>
<li>函数直接调用时：this指向函数的直接调用者；</li>
<li>通过new关键字，this指向new产生的新对象；</li>
<li>通过call/apply/bind的绑定，this指向绑定对象。</li>
<li>在JS事件中，this指向触发这个事件的对象，但是在IE中，attachEvent中的this总是指向全局对象Window。</li>
</ol>
</li>
</ul>
<h1 id="6-JavaScript的作用域链"><a href="#6-JavaScript的作用域链" class="headerlink" title="6.JavaScript的作用域链"></a>6.JavaScript的作用域链</h1><p>全局函数无法查看局部函数的内部细节，但局部函数刻意查看上层函数的细节，直至全局细节。</p>
<p>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</p>
<h1 id="7-JavaScript原型和原型链"><a href="#7-JavaScript原型和原型链" class="headerlink" title="7. JavaScript原型和原型链"></a>7. JavaScript原型和原型链</h1><ul>
<li><p>原型：每个对象都会在其内部初始化一个属性，就是prototype(原型)。换句话说，<strong>所有对象都是以对象为模板创建实例的。</strong></p>
</li>
<li><p>原型链：当我们访问一个对象的属性A时，如果属性A不存在于该对象中，那么我们会去prototype里查找A，而这个prototype又会有自己的prototype，于是就如此查找下去，就形成了一个原型链。这个原型链表示的是一种连带关系。</p>
</li>
<li><p>关系：<code>instance.constructor.prototype = instance.__proto__</code></p>
</li>
<li><p>特点：JS对象是通过<strong>引用传递</strong>的（对比于值传递），我们创建的每一个新对象实体中，并没有一份属于自己的原型副本。当我们修改了原型，与之相关的对象也会<strong>继承</strong>这些变化。</p>
</li>
<li><p>终点：原型链的顶端，是<code>Object.prototype</code>, 它的<code>__proto__</code>指向<code>null</code>.</p>
</li>
</ul>
<h1 id="8-JavaScript的闭包"><a href="#8-JavaScript的闭包" class="headerlink" title="8.JavaScript的闭包"></a>8.JavaScript的闭包</h1><ol>
<li><p>概念<br>闭包是一种手段，一个有权访问另一个函数作用域中变量的函数，记住闭包也是函数。</p>
</li>
<li><p>创建闭包<br>最常见的方式，就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量(相当于一个对外的接口)。</p>
</li>
<li><p>作用<br>利用闭包可以突破作用域链，将函数内部的变量方法传递到外部。</p>
</li>
<li><p>特性</p>
<pre><code> 1. 函数内再嵌套函数
 2. 内部函数可以引用外层的参数和变量
 3. 参数和变量不会被垃圾回收机制回收
</code></pre>
</li>
</ol>
<h1 id="9-new操作符到底干了什么？"><a href="#9-new操作符到底干了什么？" class="headerlink" title="9. new操作符到底干了什么？"></a>9. new操作符到底干了什么？</h1><ol>
<li><p>创建一个空对象，将this指针指向该对象，同时继承该函数的原型。</p>
</li>
<li><p>属性和方法被添加到this指向的对象中。</p>
</li>
<li><p>新创建的对象由this所应用，并且最后隐式的返回this 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="10-JavaScript开发的基本规范"><a href="#10-JavaScript开发的基本规范" class="headerlink" title="10. JavaScript开发的基本规范"></a>10. JavaScript开发的基本规范</h1><ol>
<li>不要在同一行声明多个变量；</li>
<li>请使用 ===/!==来比较布尔值或者数值；</li>
<li>使用对象字面量替代 new Array这种形式；</li>
<li>不要使用全局函数；</li>
<li>Switch语句必须带有default分支；</li>
<li>函数应该有返回值；</li>
<li>For循环必须使用大括号；</li>
<li>if语句必须使用大括号；</li>
<li>for-in循环中的变量应该使用let 关键字明确限定作用域，避免命名空间污染。<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMyNjgwOTE5Nyw4MDc3MDE4MzZdfQ==</li>
</ol>
<p>–&gt;</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 核心特性(2)</title>
    <url>/2017/03/07/2017-03-07%20%E5%89%8D%E7%AB%AF-JavaScript%E7%B2%BE%E9%AB%93(2)/</url>
    <content><![CDATA[<h1 id="1-JavaScript继承的实现方式"><a href="#1-JavaScript继承的实现方式" class="headerlink" title="1. JavaScript继承的实现方式"></a>1. JavaScript继承的实现方式</h1><ol>
<li>构造继承</li>
<li>原型继承</li>
<li>实例继承</li>
<li>拷贝继承</li>
</ol>
<p> <strong>原型prototype机制或者apply/call方法较简单，建议使用<code>构造函数与原型混合方式</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&#x27;wang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.age = <span class="number">28</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();	<span class="comment">//通过prototype，继承Parent	</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Child();</span><br><span class="line">alert(demo.age);</span><br><span class="line">alert(demo.name);	<span class="comment">//得到继承的属性</span></span><br></pre></td></tr></table></figure>



<h1 id="2-DOM操作——添加、移除、移动、复制、创建和查找节点"><a href="#2-DOM操作——添加、移除、移动、复制、创建和查找节点" class="headerlink" title="2. DOM操作——添加、移除、移动、复制、创建和查找节点"></a>2. DOM操作——添加、移除、移动、复制、创建和查找节点</h1><ol start="3">
<li><p>创建新节点</p>
</li>
<li><p>createDocumentFragment()</p>
</li>
<li><p>createElement()</p>
</li>
<li><p>createTextNode()</p>
</li>
<li><p>添加、移除、替换、插入</p>
</li>
<li><p>appendChild()</p>
</li>
<li><p>removeChild()</p>
</li>
<li><p>replaceChild()</p>
</li>
<li><p>insertBefore()</p>
</li>
<li><p>查找</p>
</li>
<li><p>getElementsByTagName()</p>
</li>
<li><p>getElementsByName()</p>
</li>
<li><p>getElementById()</p>
<h1 id="3-Ajax的概念和用法"><a href="#3-Ajax的概念和用法" class="headerlink" title="3. Ajax的概念和用法"></a>3. Ajax的概念和用法</h1></li>
<li><p>AJAX的全称： Asynchronous JavaScript And XML.</p>
</li>
<li><p>异步的概念：向服务器发送请求时，不必等待结果，而可以同时做其他事情。</p>
</li>
<li><p>Ajax用法：</p>
<ol>
<li>创建XMLHttpRequest对象，也就是创建一个异步调用对象，</li>
<li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL和验证信息，</li>
<li>设置响应HTTP请求状态变化的函数，</li>
<li>发送HTTP请求，</li>
<li>获取异步调用返回的数据，</li>
<li>使用JavaScript和DOM实现局部刷新 。</li>
</ol>
<h1 id="4-document-write-和-innerHTML的区别"><a href="#4-document-write-和-innerHTML的区别" class="headerlink" title="4. document.write 和 innerHTML的区别"></a>4. document.write 和 innerHTML的区别</h1></li>
<li><p>document.write只能重绘<strong>整个页面</strong></p>
</li>
<li><p>innerHTML可以只重绘<strong>页面的一部分</strong></p>
</li>
</ol>
<h1 id="5-window对象和document对象"><a href="#5-window对象和document对象" class="headerlink" title="5. window对象和document对象"></a>5. window对象和document对象</h1><ul>
<li>window对象：指的是浏览器打开的窗口</li>
<li>document对象：Document对象的一个只读引用，它是window对象的一个属性。</li>
</ul>
<h1 id="6-通用的事件侦听器函数"><a href="#6-通用的事件侦听器函数" class="headerlink" title="6. 通用的事件侦听器函数"></a>6. 通用的事件侦听器函数</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event工具集，参考来源：github.com/markyun</span></span><br><span class="line">markyun.Event = &#123;</span><br><span class="line">	readyEvent : <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(fn==<span class="literal">null</span>)&#123;</span><br><span class="line">			fn = <span class="built_in">document</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">window</span>.onload = fn;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				oldonolad():</span><br><span class="line">				fn();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//根据能力分别使用DOM 0级 || DOM 2级 || IE方式，来绑定事件</span></span><br><span class="line">	<span class="comment">//参数：操作元素，事件名称，事件处理函数</span></span><br><span class="line">	addEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">			<span class="comment">//事件类型，需要执行的函数，是否捕捉</span></span><br><span class="line">			element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">			element.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			handler.call(element);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			element[<span class="string">&#x27;on&#x27;</span> + type ] = handler;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//移除事件</span></span><br><span class="line">	removeEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(element.removeEventListener)&#123;</span><br><span class="line">			element.removeEventListener(type,handler,<span class="literal">false</span>);	</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent)&#123;</span><br><span class="line">			element.detachEvent(<span class="string">&#x27;on&#x27;</span> + type, handler);			</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			element[<span class="string">&#x27;on&#x27;</span> + type] = <span class="literal">null</span>;	</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;, <span class="comment">//End removeEvent</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//阻止事件(主要是事件冒泡， 因为IE不支持事件捕获)</span></span><br><span class="line">	stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ev.stopPropagation)&#123;</span><br><span class="line">				ev.stopPropagation();</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ev.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//取消事件的默认行为</span></span><br><span class="line">	preventDefault : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(event.preventDefault)&#123;</span><br><span class="line">			event.preventDefault();</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			event.returnValue = <span class="literal">false</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取事件目标</span></span><br><span class="line">	getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></span><br><span class="line">	getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> ev = e || <span class="built_in">window</span>.event;</span><br><span class="line">		<span class="keyword">if</span>(!ev)&#123;</span><br><span class="line">			<span class="keyword">var</span> c = <span class="built_in">this</span>.getEvent.caller;</span><br><span class="line">			<span class="keyword">while</span>(c)&#123;</span><br><span class="line">				ev = c.arguments[<span class="number">0</span>];</span><br><span class="line">				<span class="keyword">if</span>(ev &amp;&amp; Event == ev.constructor)&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				c = c.caller;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ev;	</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125; <span class="comment">//End</span></span><br></pre></td></tr></table></figure>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzNjI1MDY2MjhdfQ==
-->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 对象数组排序</title>
    <url>/2017/05/07/2017-05-07%20%E5%89%8D%E7%AB%AF-JavaScript%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h1><hr>
<h2 id="一、按照对象的属性排序"><a href="#一、按照对象的属性排序" class="headerlink" title="一、按照对象的属性排序"></a>一、按照对象的属性排序</h2><p>我要一个函数，传入要对比的key，就能以这个key，把对象数组进行排序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> by = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> a, b;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> p === <span class="string">&#x27;object&#x27;</span> &amp;&amp; o &amp;&amp; p) &#123;</span><br><span class="line">			a = o[key];</span><br><span class="line">			b = p[key];</span><br><span class="line">			<span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="keyword">typeof</span> b) &#123;</span><br><span class="line">				<span class="keyword">return</span> a &lt; b ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果a,b所属类型不同，则按类型的英文字符排序，比如&#x27;function&#x27;排在&#x27;object&#x27;前面。</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">typeof</span> a &lt; <span class="keyword">typeof</span> b ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> employees=[]</span><br><span class="line">employees[<span class="number">0</span>]=&#123;<span class="attr">name</span>:<span class="string">&quot;George&quot;</span>, <span class="attr">age</span>:<span class="number">32</span>, <span class="attr">retiredate</span>:<span class="string">&quot;March 12, 2014&quot;</span>&#125;</span><br><span class="line">employees[<span class="number">1</span>]=&#123;<span class="attr">name</span>:<span class="string">&quot;Edward&quot;</span>, <span class="attr">age</span>:<span class="number">17</span>, <span class="attr">retiredate</span>:<span class="string">&quot;June 2, 2023&quot;</span>&#125;</span><br><span class="line">employees[<span class="number">2</span>]=&#123;<span class="attr">name</span>:<span class="string">&quot;Christine&quot;</span>, <span class="attr">age</span>:<span class="number">58</span>, <span class="attr">retiredate</span>:<span class="string">&quot;December 20, 2036&quot;</span>&#125;</span><br><span class="line">employees[<span class="number">3</span>]=&#123;<span class="attr">name</span>:<span class="string">&quot;Sarah&quot;</span>, <span class="attr">age</span>:<span class="number">62</span>, <span class="attr">retiredate</span>:<span class="string">&quot;April 30, 2020&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">employees.sort(by(<span class="string">&#x27;age&#x27;</span>));</span><br><span class="line"><span class="comment">//得到根据age属性排序的数组。</span></span><br><span class="line"><span class="comment">//[&#123;name:&quot;Edward&quot;, age:17, retiredate:&quot;June 2, 2023&quot;&#125;,</span></span><br><span class="line"><span class="comment">//&#123;name:&quot;George&quot;, age:32, retiredate:&quot;March 12, 2014&quot;&#125;,</span></span><br><span class="line"><span class="comment">//&#123;name:&quot;Christine&quot;, age:58, retiredate:&quot;December 20, 2036&quot;&#125;,</span></span><br><span class="line"><span class="comment">//&#123;name:&quot;Sarah&quot;, age:62, retiredate:&quot;April 30, 2020&quot;&#125;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二、高级by-函数"><a href="#二、高级by-函数" class="headerlink" title="二、高级by()函数"></a>二、高级by()函数</h2><p>当主要的键值产生一个匹配的时候，另一个compare方法（第二个参数）将被调用以决出高下。<br>举个例子，在比较两个对象的age属性时，age的值相等，现在我想要age相等的人，按照别的属性进行排序。于是我想增强<code>by()</code> ，现在我这样使用：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">//注意外层<span class="keyword">by</span>函数内有俩个参数，第二个参数就是备用的比较函数。</span><br><span class="line">employees<span class="built_in">.sort</span>(<span class="keyword">by</span>(<span class="string">&#x27;age&#x27;</span>,<span class="keyword">by</span>(<span class="string">&#x27;name&#x27;</span>)));</span><br></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> by = <span class="function"><span class="keyword">function</span><span class="params">(name,minor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(o,p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a,b;</span><br><span class="line">        <span class="keyword">if</span>(o &amp;&amp; p &amp;&amp; <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> p ===<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            a = o[name];</span><br><span class="line">            b = p[name];</span><br><span class="line">            <span class="keyword">if</span>(a === b)&#123;</span><br><span class="line">	            <span class="comment">//如果前后元素相同时，用minor函数比较。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">typeof</span> minor === <span class="string">&#x27;function&#x27;</span> ? minor(o,p):<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> a === <span class="keyword">typeof</span> b)&#123;</span><br><span class="line">                <span class="keyword">return</span> a &lt;b ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> a &lt; <span class="keyword">typeof</span> b ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQxNDgxNDY3NV19
-->]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 观察者模式的通用实现</title>
    <url>/2017/05/07/2017-05-07%20%E5%89%8D%E7%AB%AF-JavaScript%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装观察者模式，放进一个对象中，可复用。</span></span><br><span class="line"><span class="keyword">var</span> event = &#123;</span><br><span class="line">	clientList:[],</span><br><span class="line">	<span class="comment">//订阅的消息添加进缓存列表</span></span><br><span class="line">	listen: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>( !<span class="built_in">this</span>.clientList[key])&#123;</span><br><span class="line">			<span class="built_in">this</span>.clientList[key] = [];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.clientList[key].push(fn);</span><br><span class="line">	&#125;,</span><br><span class="line">	trigger: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>),</span><br><span class="line">			fns = <span class="built_in">this</span>.clientList[key];</span><br><span class="line">		<span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[i++];)&#123;</span><br><span class="line">			fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;，</span><br><span class="line">	remove: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> fns = ClientList[key];</span><br><span class="line">		<span class="keyword">if</span>( !fns )&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!fn)&#123;</span><br><span class="line">			fns &amp;&amp; fns.length = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> len = fns.length-<span class="number">1</span>; len&gt;=<span class="number">0</span>; len--)&#123;</span><br><span class="line">				<span class="keyword">var</span> _fn = fns[len&#125;;</span><br><span class="line">				<span class="keyword">if</span>(_fn === fn)&#123;</span><br><span class="line">					fns.splice(len, <span class="number">1</span>);</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有对象都能动态安装 ‘观察者模式’</span></span><br><span class="line"><span class="keyword">var</span> installEvent = <span class="keyword">function</span>(obj)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i in <span class="keyword">event</span>)&#123;</span><br><span class="line">		obj[i] = <span class="keyword">event</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>测试</span><br><span class="line">var salesOffices = &#123;&#125;;</span><br><span class="line">installEvent(salesOffices);</span><br><span class="line">	<span class="regexp">//</span>订阅</span><br><span class="line">salesOffices.listen(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="keyword">function</span>(price)&#123;</span><br><span class="line">	console.log(<span class="string">&#x27;88平方米的价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.listen(<span class="string">&#x27;squareMeter110&#x27;</span>,<span class="keyword">function</span>(price)&#123;</span><br><span class="line">	console.log(<span class="string">&#x27;110平方米的价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line">	<span class="regexp">//</span>发布</span><br><span class="line">salesOffices.trigger(<span class="string">&#x27;squareMeter88&#x27;</span>,<span class="number">2000000</span>);	<span class="regexp">//</span>输出：<span class="string">&quot;88平方米的价格=2000000&quot;</span></span><br><span class="line">salesOffices.trigger(<span class="string">&#x27;squareMeter110&#x27;</span>,<span class="number">3000000</span>);	<span class="regexp">//</span>输出：<span class="string">&quot;110平方米的价格=3000000&quot;</span>	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY1NjY3NTEyNF19
-->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何应对CSRF攻击</title>
    <url>/2017/05/23/2017-05-23%20%E6%8A%80%E6%9C%AF-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6CSRF/</url>
    <content><![CDATA[<h1 id="CSRF攻击的应对之道"><a href="#CSRF攻击的应对之道" class="headerlink" title="CSRF攻击的应对之道"></a>CSRF攻击的应对之道</h1><h1 id="一、CSRF的来龙去脉"><a href="#一、CSRF的来龙去脉" class="headerlink" title="一、CSRF的来龙去脉"></a>一、CSRF的来龙去脉</h1><h2 id="1-什么是CSRF？"><a href="#1-什么是CSRF？" class="headerlink" title="1. 什么是CSRF？"></a>1. 什么是CSRF？</h2><p>CSRF（Cross Site Request Forgery, <strong>跨站域请求伪造</strong>）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。<br>其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。</p>
<hr>
<h2 id="2-CSRF攻击实例"><a href="#2-CSRF攻击实例" class="headerlink" title="2. CSRF攻击实例"></a>2. CSRF攻击实例</h2><p>CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。</p>
<p>比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求</p>
<blockquote>
<p> <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a></p>
</blockquote>
<p> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。</p>
<p>通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p>
<p>Mallory 可以自己发送一个请求给银行：</p>
<blockquote>
<p><a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a></p>
</blockquote>
<p>但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p>
<blockquote>
<p> src=”<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”</p>
</blockquote>
<p>并且通过广告等<strong>诱使 Bob 来访问他的网站</strong>。</p>
<p>当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而<strong>这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器</strong>。</p>
<p>大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。</p>
<p>但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 <strong>session 尚未过期</strong>，浏览器的 cookie 之中含有 Bob 的认证信息。</p>
<p>这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时<strong>毫不知情</strong>。</p>
<p>等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p>
<h2 id="3-CSRF攻击的对象"><a href="#3-CSRF攻击的对象" class="headerlink" title="3. CSRF攻击的对象"></a>3. CSRF攻击的对象</h2><p>在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。</p>
<p>从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。</p>
<blockquote>
<p>因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p>
</blockquote>
<p>所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。</p>
<p>比如银行系统中<strong>转账</strong>的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。</p>
<h1 id="二、防御-CSRF-的几种策略"><a href="#二、防御-CSRF-的几种策略" class="headerlink" title="二、防御 CSRF 的几种策略"></a>二、防御 CSRF 的几种策略</h1><p>在业界目前防御 CSRF 攻击主要有三种策略：</p>
<ul>
<li>验证 HTTP Referer 字段；</li>
<li>在请求地址中添加 token 并验证；</li>
<li>在 HTTP 头中自定义属性并验证。</li>
</ul>
<h2 id="1-验证-HTTP-Referer-字段"><a href="#1-验证-HTTP-Referer-字段" class="headerlink" title="1. 验证 HTTP Referer 字段"></a>1. 验证 HTTP Referer 字段</h2><h3 id="1-1-什么是Referer？"><a href="#1-1-什么是Referer？" class="headerlink" title="1.1 什么是Referer？"></a>1.1 什么是Referer？</h3><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 <strong>Referer</strong>，它记录了该 <strong>HTTP 请求的来源地址</strong>。</p>
<p>在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问</p>
<blockquote>
<p><a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a></p>
</blockquote>
<p>用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。</p>
<p>这时，该转帐请求的 Referer 值就会是<strong>转账按钮所在的页面的 URL</strong>，通常是以 bank.example 域名开头的地址。</p>
<p>而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。</p>
<h3 id="1-2-如何验证Referer？"><a href="#1-2-如何验证Referer？" class="headerlink" title="1.2 如何验证Referer？"></a>1.2 如何验证Referer？</h3><p>因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<h3 id="1-3-Referer验证的优缺点"><a href="#1-3-Referer验证的优缺点" class="headerlink" title="1.3 Referer验证的优缺点"></a>1.3 Referer验证的优缺点</h3><p>优点：这种方法简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一<strong>增加一个拦截器来检查 Referer 的值</strong>就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>缺点：</p>
<ol>
<li><p>Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。</p>
<blockquote>
<p>使用验证值的方法，<strong>就是把安全性都依赖于第三方（即浏览器）来保障</strong>，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行CSRF 攻击。</p>
</blockquote>
</li>
<li><p>如果用户为了保护隐私，而设置浏览器使其在发送请求时<strong>不再提供 Referer</strong>。当他们正常访问银行网站时，网站会因为请求Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
</li>
</ol>
<h2 id="2-在请求地址中添加-token-并验证"><a href="#2-在请求地址中添加-token-并验证" class="headerlink" title="2. 在请求地址中添加 token 并验证"></a>2. 在请求地址中添加 token 并验证</h2><h3 id="2-1-黑客总是能找到漏洞"><a href="#2-1-黑客总是能找到漏洞" class="headerlink" title="2.1 黑客总是能找到漏洞"></a>2.1 黑客总是能找到漏洞</h3><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。</p>
<h3 id="2-2-那我们就加一把钥匙"><a href="#2-2-那我们就加一把钥匙" class="headerlink" title="2.2 那我们就加一把钥匙"></a>2.2 那我们就加一把钥匙</h3><p>要抵御 CSRF，关键在于<strong>在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。</strong>可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。</p>
<p>但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>，这样就把 token 以参数的形式加入请求了。</p>
<h3 id="2-3-使用token的缺点："><a href="#2-3-使用token的缺点：" class="headerlink" title="2.3 使用token的缺点："></a>2.3 使用token的缺点：</h3><p>①. 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是<strong>对于在页面加载之后动态生成的 html 代码，这种方法就没有作用</strong>，还需要程序员在编码时手动添加 token。</p>
<p>②. 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。</p>
<p>为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<h2 id="3-在-HTTP-头中自定义属性并验证"><a href="#3-在-HTTP-头中自定义属性并验证" class="headerlink" title="3. 在 HTTP 头中自定义属性并验证"></a>3. 在 HTTP 头中自定义属性并验证</h2><h3 id="3-1-把密钥放到HTTP请求头中"><a href="#3-1-把密钥放到HTTP请求头中" class="headerlink" title="3.1 把密钥放到HTTP请求头中"></a>3.1 把密钥放到HTTP请求头中</h3><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。</p>
<p>通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。</p>
<p>这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
<h3 id="3-2-缺点："><a href="#3-2-缺点：" class="headerlink" title="3.2 缺点："></a>3.2 缺点：</h3><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
<hr>
<h1 id="三、代码实例-java-："><a href="#三、代码实例-java-：" class="headerlink" title="三、代码实例(java)："></a>三、代码实例(java)：</h1><h2 id="1-使用Filter验证Referer"><a href="#1-使用Filter验证Referer" class="headerlink" title="1. 使用Filter验证Referer"></a>1. 使用Filter验证Referer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从HTTP头部取得Referer值</span></span><br><span class="line"> String referer = request.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line"> <span class="comment">//判断Referer是否以bank.example开头</span></span><br><span class="line"> <span class="keyword">if</span>((refirer != <span class="keyword">null</span>) &amp;&amp; (referer.trim().startsWith(<span class="string">&quot;bank.example&quot;</span>)))&#123;</span><br><span class="line"> vhain.doFilter(request, response);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;error.jsp&quot;</span>).forward(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码先取得Referer值，然后进行判断，当其非空并以bank.example开头时，则继续请求，否则的话可能是CSRF攻击，转到error.jsp页面。</p>
<h2 id="2-进一步验证请求中的token"><a href="#2-进一步验证请求中的token" class="headerlink" title="2.进一步验证请求中的token"></a>2.进一步验证请求中的token</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServletRequest req = (HttpServletRequest)request;</span><br><span class="line">HttpSession s = req.getSession();</span><br><span class="line"><span class="comment">//从session中，得到csrftoken属性</span></span><br><span class="line">String sToken = (String)s.getAttribute(<span class="string">&quot;csrftoken&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(sToken == <span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="comment">//产生新的token放入session中</span></span><br><span class="line">	sToken = generateToken();</span><br><span class="line">	s.setAttribute(<span class="string">&quot;csrftoken&quot;</span>, sToken);</span><br><span class="line">	chain.doFilter(request, response);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">//从HTTP头中取得csrftoken</span></span><br><span class="line">	String xhrToken = req.getHeader(<span class="string">&quot;csrftoken&quot;</span>);</span><br><span class="line">	<span class="comment">//从请求参数中取得csrftoken</span></span><br><span class="line">	String pToken = req.getParameter(<span class="string">&quot;csrftoken&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(sToken != <span class="keyword">null</span> &amp;&amp; xhrToken != <span class="keyword">null</span> &amp;&amp; sToken.equals(xhrToken))&#123;</span><br><span class="line">		chain.doFilter(request, response);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	request.getRequestDispatcher(<span class="string">&quot;error.jsp&quot;</span>).forward(request,response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-在客户端对请求附加token"><a href="#3-在客户端对请求附加token" class="headerlink" title="3.在客户端对请求附加token"></a>3.在客户端对请求附加token</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendTOken</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	updateForms();</span><br><span class="line">	updateTags();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateForms</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//获取所有form元素</span></span><br><span class="line">	<span class="keyword">var</span> forms = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; forms.length; i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> url = forms[i].action;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果这个form的action值为空，则不附加csrftoken</span></span><br><span class="line">		<span class="keyword">if</span>(url == <span class="literal">null</span> || url == <span class="string">&quot;&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//动态生成input元素，加到 form 之后</span></span><br><span class="line">		<span class="keyword">var</span> e = docement.createElement(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">		e.name = <span class="string">&quot;csrftoken&quot;</span>;</span><br><span class="line">		e.value = token;</span><br><span class="line">		e.type = <span class="string">&quot;hidden&quot;</span>;</span><br><span class="line">		forms[i].appendChild(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTags</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> all = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="keyword">var</span> len = all.length;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历所有a元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; len; i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> e = all[i];</span><br><span class="line">		updateTag(e, <span class="string">&quot;href&quot;</span> , token);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTag</span>(<span class="params">element, attr, token</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> location = element.getAttribute(attr);</span><br><span class="line">	<span class="keyword">if</span>(location != <span class="literal">null</span> &amp;&amp; location != <span class="string">&#x27;&#x27;</span> <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> fragmentIndex = location.indexOf(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> fragment = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(fragmentIndex != -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//url中含有#锚标记</span></span><br><span class="line">			fragment = location.substring(fragmentIndex);</span><br><span class="line">			location = location.substring(<span class="number">0</span>, fragmentIndex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> index = location.indexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(index !== -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//url中已含有其他参数</span></span><br><span class="line">			location = location + <span class="string">&#x27;&amp;csrftoken=&#x27;</span> + token;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//url中没有其他参数</span></span><br><span class="line">			location = location + <span class="string">&#x27;?csrftoken=&#x27;</span> + token;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(fragment != <span class="literal">null</span>)&#123;</span><br><span class="line">			location += fragment;</span><br><span class="line">		&#125;</span><br><span class="line">		element.setAttribute(attr, location);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端html中，主要有两个地方需要加上token，一个是表单form，另一个就是a标签。上面这段代码，首先遍历所有的form, 在form最后添加一段<strong>隐藏字段</strong>，把csrftoken放入其中。然后，代码遍历所有的a标签，在其href属性中加入csrftoken参数。 注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。</p>
<h2 id="4-在-HTTP-头中自定义属性"><a href="#4-在-HTTP-头中自定义属性" class="headerlink" title="4. 在 HTTP 头中自定义属性"></a>4. 在 HTTP 头中自定义属性</h2><pre><code> var plainXhr = dojo.xhr;

 // 重写 dojo.xhr 方法
 dojo.xhr = function(method,args,hasBody) &#123;
    // 确保 header 对象存在
    args.headers = args.header || &#123;&#125;;

    tokenValue = &#39;&lt;%=request.getSession(false).getAttribute(&quot;csrftoken&quot;)%&gt;&#39;;
    var token = dojo.getObject(&quot;tokenValue&quot;);

    // 把 csrftoken 属性放到头中
    args.headers[&quot;csrftoken&quot;] = (token) ? token : &quot;  &quot;;
    return plainXhr(method,args,hasBody);
 &#125;;
</code></pre>
<p>这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。</p>
<h1 id="四、如何选择CSRF防御方法？"><a href="#四、如何选择CSRF防御方法？" class="headerlink" title="四、如何选择CSRF防御方法？"></a>四、如何选择CSRF防御方法？</h1><p>目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。</p>
<p>如果网站是一个现有系统，想要<strong>在最短时间内获得一定程度的 CSRF 的保护</strong>，那么<strong>验证 Referer</strong> 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。</p>
<p>如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。<br>在这种情况下，你需要<strong>小心规划你网站提供的各种服务</strong>，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。</p>
<p>如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议<strong>对于重要的服务，可以尽量使用 XMLHttpRequest 来访问</strong>，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。</p>
<p>最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>可见，CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF 的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token 方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视 CSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低。</p>
<hr>
<blockquote>
<p> <a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/">引用：IBM的技术博客</a></p>
</blockquote>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI5MjIzOTMsMTU5NjI1MTcwXX0=
-->]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>从URL到页面，发生了什么事情？</title>
    <url>/2017/06/06/2017-06-06%20%E5%89%8D%E7%AB%AF-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？"><a href="#1-一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？" class="headerlink" title="1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？"></a>1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？</h1><h2 id="1-1-浏览器处理请求"><a href="#1-1-浏览器处理请求" class="headerlink" title="1.1 浏览器处理请求"></a>1.1 浏览器处理请求</h2><p>浏览器开启一个线程处理这个请求，对URL分析判断，如果是HTTP协议，就按Web方式处理。</p>
<h2 id="1-2-浏览器处理URL"><a href="#1-2-浏览器处理URL" class="headerlink" title="1.2 浏览器处理URL"></a>1.2 浏览器处理URL</h2><p>调用浏览器内核中的对应方法，比如WebView中的loadUrl方法。</p>
<h2 id="1-3-DNS解析"><a href="#1-3-DNS解析" class="headerlink" title="1.3 DNS解析"></a>1.3 DNS解析</h2><p>通过DNS解析，获取域名的IP地址，设置UA等信息发出第二个GET请求。</p>
<h2 id="1-4-建立连接"><a href="#1-4-建立连接" class="headerlink" title="1.4 建立连接"></a>1.4 建立连接</h2><p>进行HTTP协议回话，客户端发送报头（请求报头）；</p>
<h2 id="1-5-服务器系统响应"><a href="#1-5-服务器系统响应" class="headerlink" title="1.5 服务器系统响应"></a>1.5 服务器系统响应</h2><p>进入到Web服务器上的Web Server， 如Apache 、Tomcat 、 Node.JS 等服务器。</p>
<h2 id="1-6-服务器程序处理"><a href="#1-6-服务器程序处理" class="headerlink" title="1.6 服务器程序处理"></a>1.6 服务器程序处理</h2><p>进入部署好的后端应用，如PHP、Java、JavaScript、Python等，找到相应的请求处理。</p>
<h2 id="1-7-服务器处理完成，返回数据"><a href="#1-7-服务器处理完成，返回数据" class="headerlink" title="1.7 服务器处理完成，返回数据"></a>1.7 服务器处理完成，返回数据</h2><p>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，如果一致，则返回304.</p>
<h2 id="1-8-浏览器开始下载HTML"><a href="#1-8-浏览器开始下载HTML" class="headerlink" title="1.8 浏览器开始下载HTML"></a>1.8 浏览器开始下载HTML</h2><p>浏览器开始下载HTML文档(响应报头，状态码200)，同时使用缓存。</p>
<h2 id="1-9-DOM树建立，加载外部文件"><a href="#1-9-DOM树建立，加载外部文件" class="headerlink" title="1.9 DOM树建立，加载外部文件"></a>1.9 DOM树建立，加载外部文件</h2><p>文档树开始建立，根据标记请求所需指定MIME类型的文件（比如CSS，JS），同时设置Cookie。</p>
<h2 id="1-10-页面渲染"><a href="#1-10-页面渲染" class="headerlink" title="1.10 页面渲染"></a>1.10 页面渲染</h2><p>页面开始渲染DOM，JS根据DOM API操作DOM，执行事件绑定等，页面显示完成。</p>
<h1 id="2-HTTP状态码"><a href="#2-HTTP状态码" class="headerlink" title="2. HTTP状态码"></a>2. HTTP状态码</h1><ul>
<li><p>100  继续， 一般在发送post请求时， 已发送了http header之后，服务器将返回此信息，表示确认。</p>
</li>
<li><p>200 正常返回信息</p>
</li>
<li><p>201 请求成功并且服务器创建了新的资源</p>
</li>
<li><p>202 服务器已接受请求，但尚未处理</p>
</li>
<li><p>301 永久重定向</p>
</li>
<li><p>302 临时重定向</p>
</li>
<li><p>303 临时重定向，且总是使用GET请求新的URI</p>
</li>
<li><p>304 资源未修改，自从上次请求后，请求的网页未修改过。</p>
</li>
<li><p>400 请求格式错误，客户端不应当再犯同样的错误</p>
</li>
<li><p>401 请求未授权</p>
</li>
<li><p>403 禁止访问</p>
</li>
<li><p>404 找不到资源</p>
</li>
<li><p>500 服务器内部错误</p>
</li>
<li><p>502 网关错误</p>
</li>
<li><p>503 服务器暂时无法处理请求，可能是过载或者维护</p>
</li>
</ul>
<h1 id="3-前端性能优化"><a href="#3-前端性能优化" class="headerlink" title="3. 前端性能优化"></a>3. 前端性能优化</h1><h2 id="3-1-减少http请求次数"><a href="#3-1-减少http请求次数" class="headerlink" title="3.1 减少http请求次数"></a>3.1 减少http请求次数</h2><p>CSS雪碧图，JS、CSS代码压缩，图片压缩；</p>
<p>网页Gzip，CDN托管，data缓存，分离图片服务器。</p>
<h2 id="3-2-前端模板优化"><a href="#3-2-前端模板优化" class="headerlink" title="3.2 前端模板优化"></a>3.2 前端模板优化</h2><p>精简HTML标签，避免带宽浪费。</p>
<p>用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。</p>
<h2 id="3-3-DOM操作"><a href="#3-3-DOM操作" class="headerlink" title="3.3 DOM操作"></a>3.3 DOM操作</h2><p>用<code>innerHTML</code>代替DOM操作，减少DOM操作次数，优化JavaScript性能。</p>
<p>缓存DOM节点查找的结果，减少IO读取操作。</p>
<h2 id="3-4-避免直接操作style"><a href="#3-4-避免直接操作style" class="headerlink" title="3.4 避免直接操作style"></a>3.4 避免直接操作style</h2><p>当需要设置的样式很多时，设置className，而非直接操作style。</p>
<h2 id="3-5-少用全局变量"><a href="#3-5-少用全局变量" class="headerlink" title="3.5 少用全局变量"></a>3.5 少用全局变量</h2><p>不要给windows添加变量了，他已经很胖了！</p>
<hr>
<p>The End.</p>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzNzEwODE2MjJdfQ==
-->]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装Sass万能方法</title>
    <url>/2017/06/07/2017-06-07%20%E6%8A%80%E6%9C%AF-Mac%E5%AE%89%E8%A3%85Sass%E4%B8%87%E8%83%BD%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Mac-OSX系统下使用RVM修复安装Sass的错误"><a href="#Mac-OSX系统下使用RVM修复安装Sass的错误" class="headerlink" title="Mac OSX系统下使用RVM修复安装Sass的错误"></a>Mac OSX系统下使用RVM修复安装Sass的错误</h1><span id="more"></span>

<p>如果你使用通用的<code> gem install sass</code> 出现错误：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR:  </span>While executing gem ... (Errno::EACCES)</span><br><span class="line">    Permission denied - /var/lib/gems</span><br></pre></td></tr></table></figure>
<p>那么这篇文章也许能解决你的问题。</p>
<p>这个错误说明Ruby的权限有问题，要解决这个权限问题很麻烦，不过有一个方法可以跳过这个坑：</p>
<p><strong>使用RVM(Ruby Version Manager)安装一个特定版本的Ruby，再安装sass。</strong></p>
<blockquote>
<p>以下步骤都在Terminal(终端)中完成!</p>
</blockquote>
<h2 id="1-安装Homebrew"><a href="#1-安装Homebrew" class="headerlink" title="1. 安装Homebrew"></a>1. 安装Homebrew</h2><pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<h2 id="2-安装gpg"><a href="#2-安装gpg" class="headerlink" title="2. 安装gpg"></a>2. 安装gpg</h2><p>安装RVM之前需要gpg，先别管它是什么。</p>
<p>它是 <strong>mpapis public key</strong> 公钥用于验证安装包以确保安全。</p>
<p>如果你想知道它到底是什么，点击这里<a href="https://en.wikipedia.org/wiki/GNU_Privacy_Guard">GNU-wiki百科</a>。</p>
<pre><code>brew install gnupg
</code></pre>
<h2 id="3-安装gpg密钥"><a href="#3-安装gpg密钥" class="headerlink" title="3. 安装gpg密钥"></a>3. 安装gpg密钥</h2><pre><code>gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB
</code></pre>
<h2 id="4-安装RVM"><a href="#4-安装RVM" class="headerlink" title="4. 安装RVM"></a>4. 安装RVM</h2><pre><code>\curl -sSL https://get.rvm.io | bash -s stable --ruby
</code></pre>
<h2 id="5-开始使用RVM"><a href="#5-开始使用RVM" class="headerlink" title="5. 开始使用RVM"></a>5. 开始使用RVM</h2><h3 id="1-查看已有Ruby版本"><a href="#1-查看已有Ruby版本" class="headerlink" title="1. 查看已有Ruby版本:"></a>1. 查看已有Ruby版本:</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rvm list</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果出现警告，如：<br>“Warning! PATH is not properly set up…” ，<br>这是未添加RVM环境变量，请<a href="https://stackoverflow.com/questions/18276701/getting-warning-path-is-not-properly-set-up-when-doing-rvm-use-2-0-0-defaul">参考解决方案</a>.<br>或者你直接Copy下面的指令：</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]]</span> &amp;&amp; source <span class="string">&quot;$HOME/.rvm/scripts/rvm&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-检查Ruby版本列表："><a href="#2-检查Ruby版本列表：" class="headerlink" title="2. 检查Ruby版本列表："></a>2. 检查Ruby版本列表：</h3><p><strong>不必输入下面的代码，这是输入<code>rvm list</code>后的结果！</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">rvm rubies</span><br><span class="line"></span><br><span class="line">=* ruby-<span class="number">2.2</span>.<span class="number">0</span> [ x86_64 ]</span><br><span class="line"></span><br><span class="line"># =&gt; - current</span><br><span class="line"># =* - current &amp;&amp; default</span><br><span class="line">#  * - default</span><br></pre></td></tr></table></figure>

<h3 id="3-安装特定版本Ruby："><a href="#3-安装特定版本Ruby：" class="headerlink" title="3. 安装特定版本Ruby："></a>3. 安装特定版本Ruby：</h3><pre><code>rvm use ruby --default
</code></pre>
<p>检查ruby位置：</p>
<pre><code>which ruby
</code></pre>
<p>如果显示了一行目录，则表示安装成功。</p>
<pre><code>ruby -v
</code></pre>
<h2 id="6-安装sass"><a href="#6-安装sass" class="headerlink" title="6. 安装sass"></a>6. 安装sass</h2><pre><code>gem install sass
</code></pre>
<h2 id="7-安装完成！"><a href="#7-安装完成！" class="headerlink" title="7. 安装完成！"></a>7. 安装完成！</h2><blockquote>
<p>参考文章：<a href="http://usabilityetc.com/articles/ruby-on-mac-os-x-with-rvm/">Ruby on Mac OSX with RVM</a></p>
</blockquote>
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTMzNDg4NjMxXX0=
-->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>React项目中的高频ES6语法</title>
    <url>/2017/07/08/2017-07-08%20%E5%89%8D%E7%AB%AF-React%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%AB%98%E9%A2%91ES6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>在学习React过程中，注意到无论是GitHub上的Demo还是React相关文档，ES6语法都有大量使用。如果不了解其中一些语法，学习曲线就会越来越陡峭。但是要系统学习ES6，又会消耗大量时间。</p>
<p>在线练习ES6的工具：<a href="http://www.es6fiddle.net/">ES6 fiddle</a></p>
<hr>
<h2 id="1-let-amp-const"><a href="#1-let-amp-const" class="headerlink" title="1. let &amp; const"></a>1. let &amp; const</h2><p>ES6的两个新关键字，主要是引入了块级作用域，不存在变量提升，不允许重复定义等特性，减少了ES5中很容易踩到的地雷。const用来定义常量，不允许后期修改赋值。<br>参考文档：<a href="http://es6.ruanyifeng.com/#docs/let">阮一峰的博客</a></p>
<h2 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h2><ul>
<li>常规用法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; PropTypes &#125; = React</span><br></pre></td></tr></table></figure>
<p>这里是对象的解构赋值，等同于<code>let PropTypes = React.PropTypes</code></p>
<blockquote>
<p>这里其实包含了两步：</p>
<ol>
<li>声明变量PropTypes;</li>
<li>给其赋值为React.PropTypes。</li>
</ol>
</blockquote>
<p>所以等效于这样的写法：</p>
<pre><code><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let</span> PropTypes</span><br><span class="line">&#123; <span class="attribute">PropTypes</span> &#125; = React;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><p>可以同时写多个变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; PropTypes, Component &#125; = React;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想定义的变量名和属性名不一样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明x1变量，赋值为1. </span></span><br><span class="line"><span class="comment">//x是模式，不是变量也不会被赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span> : x1 &#125; = &#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>对象， 数组， 字符串等都有解构赋值的用法。</strong></p>
</li>
<li><p>参考文档：<a href="http://es6.ruanyifeng.com/#docs/destructuring">解构赋值</a></p>
</li>
</ul>
<h2 id="3-对象的拓展"><a href="#3-对象的拓展" class="headerlink" title="3.对象的拓展"></a>3.对象的拓展</h2><h3 id="3-1-属性的简洁表达式"><a href="#3-1-属性的简洁表达式" class="headerlink" title="3.1 属性的简洁表达式"></a>3.1 属性的简洁表达式</h3><pre><code>let x = &#39;123&#39;;
//等同于：let obj = &#123; x: x, y: &#39;33&#125;
let obj = &#123;x, y: &#39;33&#39; &#125;;
</code></pre>
<h3 id="3-2-方法名的简写"><a href="#3-2-方法名的简写" class="headerlink" title="3.2 方法名的简写"></a>3.2 方法名的简写</h3><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">User</span> = &#123;</span><br><span class="line"> <span class="keyword">method</span> ()&#123;   //等同于<span class="keyword">method</span>: function()<span class="meta">&#123;...&#125;</span></span><br><span class="line">  //...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3属性名表达式"><a href="#3-3属性名表达式" class="headerlink" title="3.3属性名表达式"></a>3.3属性名表达式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> key = <span class="string">&#x27;id&#x27;</span>;</span><br><span class="line">   <span class="keyword">let</span> obj = &#123;</span><br><span class="line">	    [key] : <span class="string">&#x27;1010&#x27;</span>, <span class="comment">//注意方括号</span></span><br><span class="line">	    [<span class="string">&#x27;use&#x27;</span> + <span class="string">&#x27;name&#x27;</span> ]: <span class="string">&#x27;x&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把表达式写在 [] 中， 表达式的值作为字段名称：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    id : <span class="string">&#x27;1010&#x27;</span>,</span><br><span class="line">    usename: <span class="string">&#x27;x&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：属性名表达式与属性名简写不能同时使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> key = <span class="string">&#x27;id&#x27;</span>;</span><br><span class="line">   <span class="keyword">let</span> id = <span class="string">&#x27;1010&#x27;</span>;</span><br><span class="line">   <span class="keyword">let</span> obj =&#123;</span><br><span class="line">    [key]</span><br><span class="line">&#125;  <span class="comment">//Error!</span></span><br></pre></td></tr></table></figure>

<h2 id="4-ES6-Class语法"><a href="#4-ES6-Class语法" class="headerlink" title="4. ES6 Class语法"></a>4. ES6 Class语法</h2><p>使用ES6语法定义一个React组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(props);</span><br><span class="line">		<span class="built_in">this</span>.state = &#123;<span class="attr">count</span>: props.initialCount&#125;;</span><br><span class="line">		<span class="built_in">this</span>.tick = <span class="built_in">this</span>.tick.bind(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">tick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (</span><br><span class="line">				&lt;div onClick = &#123;<span class="built_in">this</span>.tick&#125;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">			);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Counter.propTypes = &#123; <span class="attr">initialCount</span> : Reart.PropTypes.number &#125;;</span><br><span class="line"></span><br><span class="line">Counter.defaultProps = &#123; <span class="attr">initialCount</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>ES6的继承语法： extends关键字；</li>
<li>各个方法使用了方法简写，如tick(){}和render(){}, 方法之间不加 “,”；</li>
<li><code>constructor</code> 是构造函数， 可以替代getInitialState ； </li>
<li>构造函数内需要调用父类的构造函数：<code>super(props)</code> , 否则就会报错。因为子类没有自身的<code>this</code> 对象，需要从父类继承。</li>
<li><code>this.tick = this.tick.bind(this)</code>中， 使用<strong>bind</strong>来绑定执行作用域（使用React.createClass是自动绑定的), 也可以在render中监听事件的位置，使用bind(this): <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">    &lt;div onClick= &#123;<span class="built_in">this</span>.tick.bind(<span class="built_in">this</span>)&#125;&gt;</span><br><span class="line">	      Clicks: &#123;<span class="built_in">this</span>.state.count&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">	<span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string">**官方建议统一写在constructor中，这样子该方法就只需绑定一次。**</span></span><br><span class="line"><span class="string">6. 除了使用bind, 还可以使用箭头函数：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> jsx</span><br><span class="line">	&lt;div onClick = &#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.tick()&#125;&gt;</span><br><span class="line">		Clicks: &#123;<span class="built_in">this</span>.state.count&#125;</span><br><span class="line">	&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>箭头函数的特性：<br>函数体内的this就是定义是的对象， 而非调用时所在的对象。箭头函数的this指向是固定的， 而普通函数是可变的。</p>
</blockquote>
</li>
</ol>
<h2 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5. 箭头函数"></a>5. 箭头函数</h2><ul>
<li><p>ES6允许使用 <code>=&gt;</code> 来定义函数：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v+<span class="number">2</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v + <span class="number">2</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果有多个参数：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">x ,y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数有多条语句， 用大括号包装：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line">	x = x + <span class="number">11</span>;</span><br><span class="line">	y = y + <span class="number">33</span>;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>箭头函数的this指向能保持不变， 不是因为内部有绑定机制， 而是因为，<strong>箭头函数没有自己的this， 导致代码内的this就是外层代码块的this。</strong></p>
</blockquote>
<ul>
<li>参考文档： <a href="#">箭头函数</a></li>
</ul>
<h2 id="6-export-amp-import"><a href="#6-export-amp-import" class="headerlink" title="6. export &amp; import"></a>6. export &amp; import</h2><ul>
<li><p>export用于输出模块对外的接口， import用于导入其他模块提供的功能。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> client = <span class="string">&quot;App&quot;</span>	<span class="comment">//输出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">x, y</span>)</span>&#123;	<span class="comment">//输出函数</span></span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Toast</span>()</span>&#123;&#125;		<span class="comment">//输出类	</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以统一输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件名： Util.js</span></span><br><span class="line"><span class="keyword">let</span> client = <span class="string">&#x27;App&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span> (<span class="params">x , y</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; client, mul &#125;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>那么别的组件就要这样导入它：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;client, mul&#125; <span class="keyword">from</span> <span class="string">&#x27;./Util.js&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>还可以打包导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> U <span class="keyword">from</span> <span class="string">&#x27;./Util.js&#x27;</span></span><br><span class="line">U.client <span class="comment">//使用U</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用的 <code>export default</code> 命令， 用于输出默认的方法， 变量或类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;)	</span><br></pre></td></tr></table></figure></li>
<li><p>引入的时候就更方便， 可以随意指定名称：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Tab <span class="keyword">from</span> <span class="string">&#x27;tab&#x27;</span>; </span><br></pre></td></tr></table></figure></li>
<li><p>参考文档：<a href="#">export&amp;import</a></p>
</li>
</ul>
<h2 id="7-对象的拓展运算符-“…”"><a href="#7-对象的拓展运算符-“…”" class="headerlink" title="7. 对象的拓展运算符: “…”"></a>7. 对象的拓展运算符: “…”</h2><p>拓展运算符在Redux的示例Demo中很常见。</p>
<ul>
<li><p>拓展运算符可以用来合并两个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//state = &#123; name: &#x27;y&#x27; &#125;</span></span><br><span class="line"><span class="keyword">return</span> &#123;...state, <span class="attr">name</span>: <span class="string">&#x27;x&#x27;</span>, <span class="attr">id</span>: <span class="number">101</span> &#125;</span><br><span class="line"><span class="comment">//返回 &#123; name: &#x27;x&#x27;, id: 101 &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码有两个过程:1.去除state对象的所有可比案例属性， 拷贝到当前对象上；</p>
<pre><code>                2.如果自定义的属性在后面， 拓展运算符的同名属性会被覆盖。
</code></pre>
</blockquote>
</li>
<li><p>这种用法等同于 Object.assign:</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//assign字面意思为分配</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;<span class="attr">name</span>: <span class="string">&#x27;x&#x27;</span>, <span class="attr">id</span>:<span class="number">101</span>&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用拓展运算符需要安装<code>transform-object-rest-spread</code>插件， 然后在babel中配置。 配置如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">loader: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">query:&#123;</span><br><span class="line">    presets: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;es2015&#x27;</span>],</span><br><span class="line">    plugins: [<span class="string">&quot;transform-object-rest-spread&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参考文档：<a href="#">ES6拓展运算符</a></li>
</ul>
<hr>
<p>The End.</p>
<!--stackedit_data:
eyJoaXN0b3J5IjpbNjU1OTY4MjM0XX0=
-->]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>翻译：更好用的border-box</title>
    <url>/2017/10/23/2017-10-23%20%E5%89%8D%E7%AB%AF-%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84border-box/</url>
    <content><![CDATA[<h1 id="更好用的border-box"><a href="#更好用的border-box" class="headerlink" title="更好用的border-box"></a>更好用的border-box</h1><p>我是把<code>box-sizing</code>重置为<code>border-box</code>的忠实粉丝，甚至于我们有一个“年度特别日子”。但是这里有一个细小的调整，而且看起来是个不错的思路。</p>
<p>这是微调的版本：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">   <span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*, *:before, *:after&#123;</span><br><span class="line">	box-sizing:inherit;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>感谢<a href="http://blog.teamtreehouse.com/box-sizing-secret-simple-css-layouts#comment-50223">Job Neal的继承思想</a>，他说：</p>
<blockquote>
<p>This will give you the same result ,and make it easier to change the box-sizing in plugins or other components that leverage other behavior.<br>这会给你同样的结果，而且使得在插件中或其他组件中更容易改变 box-sizing 的值，而不会影响别的表现。</p>
</blockquote>
<p>进一步解释，打个比方，你有一个组件，它本被设计为默认的<code>box-sizing</code> 为 <code>content-box</code>. 你只想要使用，又不搞砸它。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.component</span>&#123;</span><br><span class="line">	<span class="comment">/*旨在以默认的box-sizing工作*/</span></span><br><span class="line">	<span class="comment">/*在你的页面中， 你可以把它重置为normal */</span></span><br><span class="line">	<span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>但问题是，这样实际上并不重置整个组件。也许在组件内部有一个<code>&lt;header&gt;</code>，期望它在一个<code>content-box</code>中。如果这个选择器在你的CSS中，老办法就是做一个 box-sizing <strong>reset</strong>…</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">	<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这个header不是你想要的<code>content-box</code>, 而是 <code>border-box</code>. 就像：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>= <span class="string">&quot;component&quot;</span>&gt;</span> <span class="comment">&lt;!-- I&#x27;m content box --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">header</span>&gt;</span> <span class="comment">&lt;!-- I&#x27;m border-box still&gt;</span></span><br><span class="line"><span class="comment">	&lt;/header&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;	</span></span><br></pre></td></tr></table></figure>
<p>为了更简单直观地做到<strong>reset</strong>，你可以使用文章顶部的继承的代码段，继承的值就会被保留。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">   <span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*, *:before, *:after&#123;</span><br><span class="line">	box-sizing:inherit;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<hr>
<p>这并不是一个很庞大的东西。你可能已经在使用 box-sizing reset 的老办法，并且从没踩到这个坑。但是，只要我们推广一个“最佳实践”风格的片段，我们也可以慢慢把它变成最好的。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>英文原文 ：<a href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/">Inheriting box-sizing Probably Slightly Better Best-Practice</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>人生没有那么多太晚</title>
    <url>/2017/07/22/2017-12-03%20%E9%9A%8F%E7%AC%94-%E4%BA%BA%E7%94%9F%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E5%A4%9A%E2%80%9C%E5%A4%AA%E6%99%9A%E2%80%9D/</url>
    <content><![CDATA[<p>村上春树，从29岁开始写作，从33岁开始坚持跑步。</p>
<p>人生哪有那么多太晚，都是懒惰和恐惧的借口罢了。</p>
<p>一些人不努力便得不到的东西，有些人却勿需努力便唾手可得。</p>
<p>在学校里，我们学到的最重要的东西，就是“最重要的东西在学校里学不到”这个真理。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
  <entry>
    <title>Array.prototype.sort()的高级用法</title>
    <url>/2018/01/28/2018-01-28%20%E5%89%8D%E7%AB%AF-Array.prototype.sort%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h1><h2 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h2><p><code>sort()</code>方法的默认排序顺序是根据串Unicode码点。</p>
<span id="more"></span>


<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var fruit = [<span class="string">&#x27;cherries&#x27;</span>, <span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>];</span><br><span class="line">fruit.sort();</span><br><span class="line"><span class="regexp">//</span>[<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>, <span class="string">&#x27;cherries&#x27;</span>]</span><br><span class="line"></span><br><span class="line">var scores = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">2</span>];</span><br><span class="line">scores.sort();</span><br><span class="line"><span class="regexp">//</span>[<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">21</span>]</span><br><span class="line"><span class="regexp">//</span>这里的<span class="number">10</span>竟然在<span class="number">2</span>之前，因为在Unicode指针顺序中 <span class="string">&#x27;10&#x27;</span> 在 <span class="string">&#x27;2&#x27;</span> 之前。</span><br></pre></td></tr></table></figure>

<h2 id="二、进阶操作（compareFunction）"><a href="#二、进阶操作（compareFunction）" class="headerlink" title="二、进阶操作（compareFunction）"></a>二、进阶操作（compareFunction）</h2><p>这时我们需要一个比较函数，来得到我们所需要的排序。<br>如果指明了<code>compareFunction</code>,那么数组会按照调用<strong>该函数的返回值</strong>排序。即a和b是两个将要被比较的元素：</p>
<h3 id="2-0-字符串排序"><a href="#2-0-字符串排序" class="headerlink" title="2.0 字符串排序"></a>2.0 字符串排序</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">var str_arr = [<span class="symbol">&#x27;cherries</span>&#x27;, <span class="symbol">&#x27;apples</span>&#x27;, <span class="symbol">&#x27;bananas</span>&#x27;];</span><br><span class="line"><span class="keyword">function</span> <span class="title">compareStr</span>(a, b)&#123;</span><br><span class="line">	if(a&lt;b)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">str_arr.sort(compareStr);</span><br><span class="line">// [<span class="symbol">&#x27;apples</span>&#x27;, <span class="symbol">&#x27;bananas</span>&#x27;, <span class="symbol">&#x27;cherries</span>&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="2-1-数字排序"><a href="#2-1-数字排序" class="headerlink" title="2.1 数字排序"></a>2.1 数字排序</h3><ul>
<li><p>如果compareFunction(a, b)小于0，那么a会排到b之前；</p>
</li>
<li><p>如果compareFunction(a, b)等于0 ,  那么位置不变；</p>
</li>
<li><p>如果compareFunction(a, b)大于0，那么b会排到a之前；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareNumbers</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以写成：</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-对象按照某个属性排序"><a href="#2-2-对象按照某个属性排序" class="headerlink" title="2.2 对象按照某个属性排序"></a>2.2 对象按照某个属性排序</h3></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Edward&#x27;</span>, <span class="attr">value</span>: <span class="number">21</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Sharpe&#x27;</span>, <span class="attr">value</span>: <span class="number">37</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;And&#x27;</span>, <span class="attr">value</span>: <span class="number">45</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;The&#x27;</span>, <span class="attr">value</span>: -<span class="number">12</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Magnetic&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Zeros&#x27;</span>, <span class="attr">value</span>: <span class="number">37</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//按value值排序</span></span><br><span class="line">items.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a,.value - b.value)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按name值排序</span></span><br><span class="line">items.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> nameA = a.name.toUpperCase();</span><br><span class="line">	<span class="keyword">var</span> nameB = b.name.toUpperCase();</span><br><span class="line">	<span class="keyword">if</span>(nameA &lt; nameB)&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nameA &gt; nameB)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="三、高级操作：使用映射改善排序"><a href="#三、高级操作：使用映射改善排序" class="headerlink" title="三、高级操作：使用映射改善排序"></a>三、高级操作：使用映射改善排序</h2><p><code>compareFunction</code>可能需要对元素做多次映射以实现排序，尤其当compareFunction较为复杂，且元素较多的时候，某些compareFunction 可能会导致很高的负载。使用map辅助排序将会是个好主意。</p>
<p>基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要被排序的数组</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="string">&#x27;Delta&#x27;</span>, <span class="string">&#x27;alpha&#x27;</span>, <span class="string">&#x27;CHARLIE&#x27;</span>, <span class="string">&#x27;bravo&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对需要排序的数字和位置的临时存储, mapped为临时容器</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">mapped</span> = list.map(<span class="function"><span class="keyword">function</span><span class="params">(el, i)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  return &#123; index: i, value: el.toLowerCase() &#125;</span>;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照多个值排序数组</span></span><br><span class="line"><span class="keyword">mapped</span>.sort(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  return +(a.value &gt; b.value) || +(a.value === b.value) - 1;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引得到排序的结果</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">result</span> = <span class="keyword">mapped</span>.map(<span class="function"><span class="keyword">function</span><span class="params">(el)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  return list[el.index];</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br><span class="line"><span class="comment">//result : [&quot;alpha&quot;, &quot;bravo&quot;, &quot;CHARLIE&quot;, &quot;Delta&quot;]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>探究 JavaScript 的深拷贝</title>
    <url>/2018/05/22/2018-05-22%20%E5%89%8D%E7%AB%AF-%E6%8E%A2%E7%A9%B6%20JavaScript%20%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="为什么要深拷贝？"><a href="#为什么要深拷贝？" class="headerlink" title="为什么要深拷贝？"></a>为什么要深拷贝？</h1><p>JS的值分为引用类型和原始类型，当我们在开发过程中需要拷贝一个对象时，希望生成一份完全独立的副本，这时候我们就需要深拷贝。</p>
<h1 id="最高效的深拷贝？"><a href="#最高效的深拷贝？" class="headerlink" title="最高效的深拷贝？"></a>最高效的深拷贝？</h1><h2 id="不要重复造轮子"><a href="#不要重复造轮子" class="headerlink" title="不要重复造轮子"></a>不要重复造轮子</h2><p>如果你的项目中依赖了第三方类库，并且它们提供了克隆方法，请使用它们的方法，不要重复造轮子！</p>
<p>比如：</p>
<ul>
<li>  lodash -  <a href="https://lodash.com/docs#cloneDeep"><code>cloneDeep</code></a>; 可以通过  <a href="https://www.npmjs.com/package/lodash.clonedeep">lodash.clonedeep</a> 独立引用。</li>
<li>  AngularJS -  <a href="https://docs.angularjs.org/api/ng/function/angular.copy"><code>angular.copy</code></a></li>
<li>  jQuery -  <a href="https://api.jquery.com/jquery.extend/#jQuery-extend-deep-target-object1-objectN"><code>jQuery.extend(true, &#123; &#125;, oldObject)</code></a>;  注意：<code>.clone()</code> 方法只复制了DOM对象。</li>
</ul>
<h2 id="简单的递归"><a href="#简单的递归" class="headerlink" title="简单的递归"></a>简单的递归</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> src) &#123;</span><br><span class="line">        ret[k] = <span class="keyword">typeof</span> src[k] ===<span class="string">&#x27;object&#x27;</span> ? deepCopy(src[k]) : src[k]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高速但是会丢数据：JSON-parse-stringify"><a href="#高速但是会丢数据：JSON-parse-stringify" class="headerlink" title="高速但是会丢数据：JSON.parse/stringify"></a>高速但是会丢数据：JSON.parse/stringify</h2><p>注意：这个方法很快，使用会丢失原型链，得到的是一个全新的对象。并且它只能复制简单的值，如果对象中有Date、函数等复杂类型的值，这个方法会丢失数据！</p>
<blockquote>
<p>If you do not use <code>Date</code>s, functions, <code>undefined</code>, <code>Infinity</code>, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays or other complex types within your object, you can use JSON.parse/stringify to clone your object.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="容易产生错觉的浅拷贝：-Object-assign"><a href="#容易产生错觉的浅拷贝：-Object-assign" class="headerlink" title="容易产生错觉的浅拷贝： Object.assign()"></a>容易产生错觉的浅拷贝： <code>Object.assign()</code></h2><p>Object.assign是ES6的新语法，对象的第一层是深拷贝，但是下面的全是浅拷贝！它只复制了属性名，却没有复制属性值。如果值是一个引用类型，那它只复制了引用值，即浅拷贝。</p>
<blockquote>
<p>引用MDN的解释：For deep cloning, we need to use other alternatives because <code>Object.assign()</code> copies property values. If the source value is a reference to an object, it only copies that reference value.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeDeepClone</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ES6还有一个浅拷贝-扩展运算符"><a href="#ES6还有一个浅拷贝-扩展运算符" class="headerlink" title="ES6还有一个浅拷贝: 扩展运算符"></a>ES6还有一个浅拷贝: 扩展运算符</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">Spread_syntax</a></p>
<blockquote>
<p>参考链接：<br><a href="https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript?page=1&tab=votes#tab-top">what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript</a></p>
</blockquote>
<hr>
<p>The End.</p>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTUwNjgyMjM0Ml19
-->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>培养阅读英文文档的习惯</title>
    <url>/2018/09/08/2018-09-08%20%E7%AC%94%E8%AE%B0-%E5%9F%B9%E5%85%BB%E9%98%85%E8%AF%BB%E8%8B%B1%E6%96%87%E6%96%87%E6%A1%A3%E7%9A%84%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[<h1 id="如何阅读英文技术文档"><a href="#如何阅读英文技术文档" class="headerlink" title="如何阅读英文技术文档"></a>如何阅读英文技术文档</h1><h2 id="为什么要读英文文档？"><a href="#为什么要读英文文档？" class="headerlink" title="为什么要读英文文档？"></a>为什么要读英文文档？</h2><ol>
<li>阅读英文文档是程序员的基础能力</li>
<li>很多技术都是国外开发者创造的，英文文档最接近作者的本意</li>
<li>中文社区鱼龙混杂，合格的中文文档需要时间和精力去搜寻</li>
<li>良性循环提高英文水平</li>
</ol>
<h2 id="找到文档"><a href="#找到文档" class="headerlink" title="找到文档"></a>找到文档</h2><ol>
<li><p>通过Google找到官方网站</p>
</li>
<li><p>在官方网站上，找到入门文档和详细的开发文档</p>
</li>
</ol>
<h2 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h2><ol>
<li><p>快速浏览目录、大纲</p>
</li>
<li><p>仔细阅读首页的文档说明</p>
</li>
<li><p>从入门介绍开始</p>
</li>
<li><p>明确自己的目标</p>
</li>
</ol>
<h2 id="克服障碍"><a href="#克服障碍" class="headerlink" title="克服障碍"></a>克服障碍</h2><ol>
<li><p>生词障碍</p>
</li>
<li><p>语义障碍</p>
</li>
<li><p>文档错误</p>
</li>
</ol>
<h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><ol>
<li><p>通过浏览器插件</p>
</li>
<li><p>通过笔记类应用程序</p>
</li>
<li><p>通过纸质笔记本</p>
</li>
</ol>
<h2 id="做标记"><a href="#做标记" class="headerlink" title="做标记"></a>做标记</h2><ol>
<li><p>阅读进度标记</p>
</li>
<li><p>常用页码标记</p>
</li>
<li><p>生词标记</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>阅读英文文档是一项很重要的能力</li>
<li>阅读能力决定于英文水平</li>
<li>英文水平和阅读能力是相辅相成的</li>
</ol>
<p>The end.</p>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>阅读</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Commit Message的最佳实践</title>
    <url>/2019/01/24/2019-01-24%20%E6%8A%80%E6%9C%AF-Git%20Commit%20Message%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h2 id="Commit-Message规范"><a href="#Commit-Message规范" class="headerlink" title="Commit Message规范"></a>Commit Message规范</h2><p>在<code>git</code>开发流程中，每次<code>git commit</code>，都需要对该次<code>commit</code>添加描述信息，描述此次<code>commit</code>的具体改动内容。规范的<code>commit message</code>格式，可以让团队成员对每次改动内容进行快速了解，也可以方便<code>git log</code>时的浏览和筛选。</p>
<p>目前社区使用最广的是 AngularJS 的规范：</p>
<ul>
<li><p><a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Google Docs 原文</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">阮一峰博客对于commit message的介绍</a></p>
</li>
</ul>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>一条完整的提交信息(<code>commit message</code>)一般来说包含<code>Header</code>和<code>Body</code>，其中<code>Header</code>是必须的，<code>Body</code>是可选的。</p>
<p>对于大部分可以简单描述清楚的改动，只需要一个<code>Header</code>即可。</p>
<p>而对于一些需要更详细说明、要分条列出的改动，我们在<code>Header</code>进行简述之外，还要在<code>Body</code>中详细描述。</p>
<p>一般而言，<code>Header</code>长度不应超过50个字符，如果超过的话则考虑添加<code>Body</code>进行详述。</p>
<p>我们通常使用的<code>git commit -m &quot;&lt;Commit Message Header&gt;&quot;</code>，就是只添加单行的<code>Header</code>信息。例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里只添加了Header</span></span><br><span class="line">git commit -m <span class="string">&quot;feat(官网主页): 将iOS的头部背景与Android统一，不再使用默认蓝色图片&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果需要添加<code>Body</code>详细信息，则使用<code>git commit</code>进入文本编辑器，再进行具体编辑。例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里既添加了Header，又添加了Body</span></span><br><span class="line">chore(构建优化): 解决构建流程几个问题</span><br><span class="line"></span><br><span class="line">- 每次构建chunkhash会改变的问题</span><br><span class="line">- 内联和外链样式重复问题</span><br><span class="line">- 图片md5错误问题</span><br><span class="line">- 提取项目公共vendor</span><br></pre></td></tr></table></figure>

<h3 id="具体规范"><a href="#具体规范" class="headerlink" title="具体规范"></a>具体规范</h3><p>从上面的示例可以看到，<code>Header</code>的格式为：<code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code>。</p>
<p><code>Header</code>主要由<code>type</code>, <code>scope</code>和<code>subject</code>三部分组成：</p>
<ul>
<li><code>type</code>用来描述这次提交属于哪一类修改，比如是<code>完成需求</code>还是<code>修复BUG</code>。<em>（必需）</em></li>
<li><code>scope</code>用来描述这次提交涉及的范围，比如是<code>详情页</code>还是<code>礼包页</code>。对于一些没有明确范围的改动，可以忽略。<em>（可选）</em></li>
<li><code>subject</code>是这次提交的简单描述，具体做了什么。如果50字符内不能描述清楚，建议添加<code>Body</code>继续描述。<em>（必需）</em></li>
</ul>
<h3 id="type类别"><a href="#type类别" class="headerlink" title="type类别"></a><code>type</code>类别</h3><p>常用：</p>
<ul>
<li><code>feat</code> - 新增需求、需求迭代、新功能等相关的提交</li>
<li><code>fix</code> - BUG修复提交</li>
<li><code>docs</code> - 文档相关的提交</li>
<li><code>refactor</code> - 技术优化类的代码重构，不影响具体需求和逻辑，也不涉及BUG修复的修改，如：测速优化、性能优化、模块拆分等</li>
<li><code>chore</code> - 代码维护相关的小改动，如：更新依赖库、构建工具及其配置的改动、代码格式调整等</li>
</ul>
<p>较不常用：</p>
<ul>
<li><code>workflow</code> - 开发工作流的改动，比如修改<code>package.json</code>中的<code>scripts</code>，比如增加或修改一些发布脚本</li>
<li><code>test</code> - 测试相关的修改，比如增加测试用例。</li>
</ul>
<h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p>在需要回滚某些改动的时候，使用<code>revert: &lt;reverted commit Header&gt;</code>格式，也就是将回滚的那一条提交的<code>Header</code>作为<code>revert</code>后的内容。</p>
<p>例如，之前进行了某些改动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fix(礼包页): 修复了礼包页展示不完全的bug</span><br></pre></td></tr></table></figure>

<p>之后发现这个改动会引起一些其他的bug，不得已需要回滚：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">revert: fix(礼包页): 修复了礼包页展示不完全的bug</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>scope</code>不是必须的，也没有具体的限定，但是有明显范围特征的尽量写上。（比如下面例子中的<code>(详情页)</code>）；</li>
<li>注意描述要清晰，要针对改动本身，让其他成员在没有任何上下文的情况下，也能看懂改动了什么。</li>
<li>不写废话（不过可以偶尔卖个萌😉）；</li>
<li><code>typo</code>修正、代码格式调整之类的，在AngularJS标准里另分到<code>style</code>类别，我们统一放在<code>chore</code>当中。这些很细小的改动，描述可以不用特别详细；</li>
<li>应保证<code>改动</code>和<code>commit</code>一一对应；</li>
<li>一个<code>commit</code>只对应一处改动、一个需求或一个BUG，不要把多个改动集中混在一起提交。在同时修改了多个文件时，不要直接<code>git add .</code>，应该挑选相关的文件进行<code>add</code>和<code>commit</code>，再挑选另一部分文件进行<code>add</code>和<code>commit</code>；</li>
<li>一处改动、一个需求或一个BUG，应尽量集中在同一个<code>commit</code>中，不要开发到中途先提交一次，开发完成再提交一次。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bad</span></span><br><span class="line">fix: bug修复</span><br><span class="line">fix: 修复了测试昨天发现的bug</span><br><span class="line">feat: 完成了今天排期的需求</span><br><span class="line"></span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line">chore: 修正了几处拼写错误</span><br><span class="line"></span><br><span class="line"><span class="comment"># Good</span></span><br><span class="line">feat: 在新的主页新增了一个关闭按钮</span><br><span class="line">fix(详情页): 修复展开活动的sid为string的bug</span><br></pre></td></tr></table></figure>

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTUxMTk4NDcyNiw2MTI0NDk4NCwtNTExOT
g0NzI2XX0=
-->]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>规范</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>读《远见》</title>
    <url>/2019/03/09/2019-03-09%20%E8%AF%BB%E3%80%8A%E8%BF%9C%E8%A7%81%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li><p>职业生涯至少长达45年，分为三个阶段</p>
<ol>
<li>加添燃料，强势开局。一般在38岁之前。</li>
<li>聚焦长板，达到高点。一般在53岁前。</li>
<li>优化长尾，持续发挥影响力。一般在68岁之前。</li>
</ol>
</li>
<li><p>职场燃料：走完职业生涯的基础</p>
<ol>
<li>可迁移技能</li>
<li>有意义的经验</li>
<li>持久的关系</li>
</ol>
</li>
<li><p>职场数学：使用数字和表格进行评估目前的职业</p>
<ol>
<li>对目前工作的4个黄金问题，评估分值</li>
<li>一周100小时测试，合理投资时间</li>
</ol>
</li>
<li><p>职场路径向导：做出正确的职业决策之前，需要回答三个问题：</p>
<ol>
<li>你的职业理想是什么？</li>
<li>你目前有哪些职场燃料？</li>
<li>你需要多少职场燃料才能实现它？</li>
</ol>
</li>
<li><p>快速成长才能获得长远成功。快速成长的工作特点：</p>
<ul>
<li>你周围都是比你聪明的人</li>
<li>你有失败的机会</li>
<li>公司有向让这样的人肩负重任的传统</li>
</ul>
</li>
<li><p>看一家公司里的人有多聪明，就看他<font color=red>招聘时的挑剔程度</font>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>git log 的几个骚操作</title>
    <url>/2019/04/17/2019-04-17%20%E6%8A%80%E6%9C%AF-git%20log%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<h2 id="原始命令，不好看"><a href="#原始命令，不好看" class="headerlink" title="原始命令，不好看"></a>原始命令，不好看</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>


<h2 id="单行log，好一点，但是不够"><a href="#单行log，好一点，但是不够" class="headerlink" title="单行log，好一点，但是不够"></a>单行log，好一点，但是不够</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="单行格式化，但是没有颜色，还是不够"><a href="#单行格式化，但是没有颜色，还是不够" class="headerlink" title="单行格式化，但是没有颜色，还是不够"></a>单行格式化，但是没有颜色，还是不够</h2><figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">git log --graph --pretty=format:&#x27;<span class="built_in">%Cred</span><span class="built_in">%h</span><span class="built_in">%Creset</span> -<span class="built_in">%C</span>(yellow)<span class="built_in">%d</span><span class="built_in">%Creset</span> <span class="built_in">%s</span> <span class="built_in">%Cgreen</span>(<span class="built_in">%cr</span>) <span class="built_in">%C</span>(bold blue)&lt;<span class="built_in">%an</span>&gt;<span class="built_in">%Creset</span>&#x27; --abbrev-commit</span><br></pre></td></tr></table></figure>


<h2 id="使用快捷方式，五颜六色好看多了"><a href="#使用快捷方式，五颜六色好看多了" class="headerlink" title="使用快捷方式，五颜六色好看多了"></a>使用快捷方式，五颜六色好看多了</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">git config --global alias.logline <span class="string">&quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br><span class="line"></span><br><span class="line">git logline</span><br></pre></td></tr></table></figure>


<h2 id="丢弃本地所有改动"><a href="#丢弃本地所有改动" class="headerlink" title="丢弃本地所有改动"></a>丢弃本地所有改动</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD</span><br><span class="line"></span><br><span class="line">git checkout -b origin/abc abc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>重命名 git 分支的三个方法</title>
    <url>/2019/05/03/2019-05-03%20%E6%8A%80%E6%9C%AF-git%E5%88%86%E6%94%AF%E7%9A%84%E9%87%8D%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<h1 id="如何重命名分支？"><a href="#如何重命名分支？" class="headerlink" title="如何重命名分支？"></a>如何重命名分支？</h1><h2 id="1-在当前分支上重命名"><a href="#1-在当前分支上重命名" class="headerlink" title="1. 在当前分支上重命名"></a>1. 在当前分支上重命名</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git branch -m new-name</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-对别的分支重命名"><a href="#2-对别的分支重命名" class="headerlink" title="2. 对别的分支重命名"></a>2. 对别的分支重命名</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git branch -m old-name new-name</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-重命名一个远程分支"><a href="#3-重命名一个远程分支" class="headerlink" title="3. 重命名一个远程分支"></a>3. 重命名一个远程分支</h2><p>删掉远程的旧分支，然后push命名后的新的分支。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git push origin<span class="keyword"> :old</span>-name new-name</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-重命名当前分支的远程分支"><a href="#4-重命名当前分支的远程分支" class="headerlink" title="4. 重命名当前分支的远程分支"></a>4. 重命名当前分支的远程分支</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">git push origin -u new-name</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接： <a href="https://multiplestates.wordpress.com/2015/02/05/rename-a-local-and-remote-branch-in-git/">https://multiplestates.wordpress.com/2015/02/05/rename-a-local-and-remote-branch-in-git/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】JavaScript作用域的通俗解读</title>
    <url>/2019/06/22/2019-06-22%20%E7%BF%BB%E8%AF%91-JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%80%9A%E4%BF%97%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="JavaScript作用域的通俗解读-（上篇）"><a href="#JavaScript作用域的通俗解读-（上篇）" class="headerlink" title="JavaScript作用域的通俗解读 （上篇）"></a>JavaScript作用域的通俗解读 （上篇）</h1><p>作用域是JavaScript语言的基础概念之一，也可能是我在编写复杂程序时最挣扎的一个概念。我已数不清多少次，在函数间传递控制时，丢失了<code>this</code>关键字的指向。我也经常发现自己经常以各种令人困惑的方式扭曲自己的代码，试图在我理解哪些变量可以访问哪些地方的时候，让我保持清醒。</p>
<p>这篇文章将正面解决问题，概述上下文和作用域的定义，检查两个允许我们修改上下文的JavaScript方法，并深入探讨我遇到的百分之九十的问题的有效解决方案。</p>
<blockquote>
<p>原文：<a href="http://www.digital-web.com/articles/scope_in_javascript/">http://www.digital-web.com/articles/scope_in_javascript/</a><br>原文发表于2006年11月11日。<br>译文发表于2019年6月22日。<br>译注单词表：<br>    - Scope : 作用域<br>    - Context：上下文<br>    - Scope Chain：作用域链<br>    - Execution context: 执行上下文</p>
</blockquote>
<h2 id="我在哪里？你是谁？"><a href="#我在哪里？你是谁？" class="headerlink" title="我在哪里？你是谁？"></a>我在哪里？你是谁？</h2><p>JavaScript程序的每一部分都在一个执行上下文中执行。你可以把这些上下文当作你的代码的邻居，告诉每一行代码它从哪来，还有它有哪些朋友和邻居。事实证明，这是重要的信息，因为JavaScript社会对谁可以与谁联系有着相当严格的规则；执行上下文更多地被认为是封闭社区，而不是开放式小区。</p>
<blockquote>
<p>译注：封闭社区(gated communities): 一个通过大门控制交通和人流进出的住宅区。</p>
</blockquote>
<p>我们通常可以将这些社会边界称为作用域，并且它们很重要，可以在每个社区的章程中编纂，我们将其称为上下文的作用域链。特定的相邻的代码只能访问其作用域链中列出的变量，并且相较于跟邻里之外的联系，代码更喜欢与本地变量的交互。</p>
<p>实际上说，评估一个函数的时候，会简历一个独特的执行上下文，将其本地作用域附加到其定义的范围链中。在一个特定上下文中，JavaScript通过作用域链的攀爬，从本地到全局地，解析标志符。这就意味着，同名的作用域链上更高的局部变量，优先级更高。这是有道理的：如果我的好朋友在一起讨论”Mike West”，很明显它们在谈论我，而不是同名的歌手或者教授，就算他们更加出名。</p>
<p>让我们通过一些实例代码来探讨其含义：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var ima_celebrity = <span class="string">&quot;Everyone can see me! I&#x27;m famous!&quot;</span>, <span class="regexp">//</span> 明星 </span><br><span class="line">the_president = <span class="string">&quot;I&#x27;m the decider!&quot;</span>;` <span class="regexp">//</span>  总统</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> pleasantville() &#123; <span class="regexp">//</span> 欢乐谷 </span><br><span class="line">	var the_mayor = “I rule Pleasantville with an iron fist!”, <span class="regexp">//</span> 市长</span><br><span class="line">	ima_celebrity = “All my neighbors know who I am!”;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">function</span> lonely_house() &#123; <span class="regexp">//</span> 山上的小屋</span><br><span class="line">		var agoraphobic = “I fear the day star!”, <span class="regexp">//</span> 广场恐惧症患者</span><br><span class="line">		a_cat = “Meow.”;  <span class="regexp">//</span> 猫</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们的明星<code>ima_celebrity</code>，每个人都认识她。她在政治上很活跃，经常和总统联系，并且非常友好；她会为遇到的任何人签名并回答问题。也就是说，她和她的粉丝没有很多个人接触。她很确定他们的存在，并且他们可能在某个地方有自己的生活，但她当然不知道他们在做什么，甚至不知道他们的名字。</p>
<p>在欢乐谷（pleasantville）中，市长是一个众所周知的面孔。她经常在城市的街道穿行，和她的选民谈话，握手，还有亲吻小孩子。因为欢乐谷是一个很大很重要的社区，所以她的办公室里又一个大大的红色电话，给她一条直连总统的线，一周七天，一天24小时无休。她看到过城郊小山上有一间孤独的小屋（lonely_house），但是从不去关心谁住在里面。</p>
<p>那间孤独的小屋对它自己来说就是一个世界。有个广场恐惧症患者（agoraphobic）大多数时间待在里面，玩纸牌，喂猫(a_cat)。他好几次打电话给市长询问关于本地噪音的法规，并且在本地新闻上看到明星(ima_celebrity)后，甚至还给她写过一些粉丝信。</p>
<h2 id="this-是什么东西？"><a href="#this-是什么东西？" class="headerlink" title="this? 是什么东西？"></a>this? 是什么东西？</h2><p>除了建立作用域链之外，每个执行上下文都提供了一个名为this的关键字。在大多数的用法中，<code>this</code>提供一个标志的功能，为我们的社区提供了一个引用自身的方式。然而，我们不能总是依赖这个行为：依赖于我们如何进入一个特定的社区，<code>this</code>可能代表着完全不同的东西。事实上，<em>我们如何访问社区</em>本身<code>this</code>通常所指的内容。有四个场景值得我们关注：</p>
<ul>
<li>调用一个对象的方法<br>在典型的面向对象语言中，我们需要一种识别和引用我们当前正在使用的对象的方法。<code>this</code>令人欣慰，为我们的对象提供了检查自己的能力，并指出了自己的属性。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deep_thought = &#123;</span><br><span class="line">	the_answer: <span class="number">42</span>,</span><br><span class="line">	ask_question: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.the_answer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> the_meaning = deep_thought.ask_question();</span><br></pre></td></tr></table></figure>

<p>这个例子新建了一个名为”deep_thought”的对象，将它的the_answer属性设置为42，并且创建了一个ask_question方法。当deep-thought.ask_question()执行了，JS为函数调用创建了一个执行上下文，将this设置为”.”之前引用的对象，在这个示例中就是deep_thought。这个方法通过this查看镜像以检查其自身的属性，并返回存储在this.the_answer中的值：42。</p>
<ul>
<li>调用构造函数<br>同样地，当定义一个要作为new关键字的构造器函数时，this可被用来指代正在创建的对象。让我们重写商民的例子来演示这个场景：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BigComputer</span>(<span class="params">answer</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.the_answer = answer;</span><br><span class="line">	<span class="built_in">this</span>.ask_question = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.the_answer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> deep_thought = <span class="keyword">new</span> BigComputer(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">var</span> the_meaning = deep_thought.ask_question(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>我们没有直接创建这个<code>deep_thought</code>对象，而是写了一个函数去创建BigComputer对象，并且通过new关键字，实例化了一个deep_thought实例变量。当 <code>new BigComputer()</code>执行的时候，在后台公开地创建了一个全新的对象。<code>BigComputer</code>被调用了，并且它的<code>this</code>关键字被设置为引用那个新对象。这个函数可以在<code>this</code>上设置属性和方法，在BigComputer执行结束时公开地返回。</p>
<p>但是请注意，deep_thought.the_question()仍然像以前一样工作。那里发生了什么？为什么this在the_question内部与BigComputer内部的意义不一样？简单来说，我们通过new 进入了BigComputer，所以this表示”新对象”。另一方面，我们通过deep_thought进入了the_question，所以当我们执行了那个方法，this意味着”deep_thought指向的任何值”。this不像其他变量一样，从作用域链中读取，而是在上下文的基础上重置。</p>
<ul>
<li>调用普通函数</li>
</ul>
<p>如果我们只是调用一个普通的日常的没有其他花样的函数呢？在这种场景中<code>this</code>又如何指向？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test_this</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i_wonder_what_this_is = test_this();</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们没有提供新的上下文，也没有给出一个背景形式的上下文来捎带。在这里，this可以引用最全局的东西：对于网页，就是window对象。</p>
<ul>
<li>事件处理器（<strong>Event Handler</strong>）<br>对于正常函数调用的更复杂的转换，假设我们正在使用函数来处理onclick事件。当事件出发我们的函数执行时，this指向哪里呢？不幸的是，这个问题没有简单的答案。如果我们内联地写一个事件处理函数，this指向全局的window对象：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">click_handler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>); <span class="comment">// alerts the window object</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// &lt;button id=&quot;thebutton&quot; onclick=&quot;click_handler()&quot;&gt;Click me!&lt;/button&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>然而，当我们通过JS来添加一个事件处理函数，this就指向了生成事件的DOM元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">click_handler</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">	alert(<span class="built_in">this</span>); <span class="comment">// alerts the button DOM node  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addhandler</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"><span class="built_in">document</span>.getElementById(‘thebutton’).onclick = click_handler;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = addhandler;</span><br></pre></td></tr></table></figure>


<h2 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h2><p>让我们在最后一个例子中运行一会儿。如果不是运行click_handler，我们每次点击按钮时都想”问deep_thought一个question”怎么办？代码看起来非常简单:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BigComputer</span>(<span class="params">answer</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.the_answer = answer;</span><br><span class="line">	<span class="built_in">this</span>.ask_question = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="built_in">this</span>.the_answer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addhandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> deep_thought = <span class="keyword">new</span> BigComputer(<span class="number">42</span>),</span><br><span class="line">	the_button = <span class="built_in">document</span>.getElementById(’thebutton‘);</span><br><span class="line">	the_button.onclick = deep_thought.ask_question;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = addhandler;</span><br></pre></td></tr></table></figure>

<p>很完美，对吧？我们点击了按钮，<code>deep_thought.ask_question</code>被执行了，然后我们得到”42”。那么为什么浏览器却给我们返回了 undefined？我们那里错了？</p>
<p>问题很简单：我们传递了对ask_question方法的引用，当作为事件处理程序执行时，该方法在与作为对象方法执行时不同的上下文中执行。简短来说，ask_question中的 this 关键字，指向了生成事件的DOM元素，而不是BigComputer对象。这个DOM元素没有the_answer属性，因此我们将返回undefined，而不是“42”。setTimeout 表现出类似的行为，延迟函数的执行，同时将其移动到了全局上下文中。</p>
<p>这个问题遍布在我们的程序中，如果没有仔细跟踪程序所有角落的情况，调试是一个非常困难的问题，特别是如果你的对象具有DOM元素上存在的属性或者window对象。</p>
<h2 id="使用-apply-和-call-修改上下文"><a href="#使用-apply-和-call-修改上下文" class="headerlink" title="使用.apply() 和 .call()修改上下文"></a>使用<code>.apply()</code> 和 <code>.call()</code>修改上下文</h2><p>我们很想在点击按钮的时候向<code>deep_thought</code>提一个问题，并且更一般地说，我们希望能够在响应事件和setTimeout调用之类的事情时在其本地上下文中调用对象方法。两个鲜为人知的JavaScript方法，<code>apply()</code>和<code>call()</code>，通过允许我们在执行函数调用时手动覆盖this的值，来间接启用这个功能。我们先来看<code>call</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first_object = &#123;  </span><br><span class="line">	num: <span class="number">42</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">var</span> second_object = &#123;  </span><br><span class="line">	num: <span class="number">24</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">mult</span>) </span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.num * mult;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply.call(first_object, <span class="number">5</span>); <span class="comment">// returns 42 * 5  </span></span><br><span class="line">multiply.call(second_object, <span class="number">5</span>); <span class="comment">// returns 24 * 5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>未完待续…<br>下一篇：《JavaScript作用域的通俗解读 （下篇）》</p>
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjk2MDAzMzkwLDcxNjYwODY4M119
-->]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>认真对待技术翻译</title>
    <url>/2019/08/01/2019-08-01%20%E9%9A%8F%E7%AC%94-%E8%AE%A4%E7%9C%9F%E5%AF%B9%E5%BE%85%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="技术翻译需要认真的态度"><a href="#技术翻译需要认真的态度" class="headerlink" title="技术翻译需要认真的态度"></a>技术翻译需要认真的态度</h1><p>译者首先要理解原文作者的语意和语气，然后通过自己对中文的文化理解，用中文翻译出来。既要保留原文的意义，又要符合中文读者的阅读习惯。这就是“意译”。</p>
<p>国内的技术翻译，质量良莠不齐。有精心校对的技术翻译组，也有凭着一脑子热情的独立译者。前者有审稿和校对，后者有热情。一般来说，前者质量高于后者。</p>
<p>独立译者又分为高水平的专家和普通水平的爱好者。专家会驾轻就熟地将一篇外文文章翻译成很流利的译文，他们经过了无数的练习，修订，核对，才练就一身高超的“译术”。普通爱好者往往半途而废，草草收尾后不再审稿和修订。</p>
<p>要把一篇文章翻译成一篇本土文风的文章，实属难事。</p>
<p>一个优秀的译者首先要有扎实的技术功底，然后要有优秀的中文文笔，再加上认真和谦卑的精神，才能不断打磨一篇文章，一本书。</p>
<p>认真翻译，不要做一个平庸的门外汉。</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary_of_translation#%E7%BF%BB%E8%AF%91%E8%A7%84%E8%8C%83">MDN 翻译规范</a></p>
</blockquote>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk1ODUyMDEyMF19
-->]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Event Loop in JavaScript</title>
    <url>/2019/09/24/2019-09-24%20%E5%BC%82%E6%AD%A5%E7%9A%84%E7%81%B5%E9%AD%82%EF%BC%9AJavaScript%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/</url>
    <content><![CDATA[<p>JavaScript是一门单线程的异步语言。我好奇事件轮询是怎么实现的，它又是如何跟其他几个核心功能进行协作的？比如 Call Stack, Callback Queue。</p>
<p>但是我在ECMA-262标准中，发现异步功能的实现不属于ECMAScript的范畴。在Google了一番后，我才知道，事件轮询 (Event Loop) 是JavaScript异步编程的基础，这个功能由宿主环境实现。如此核心底层的功能，在浏览器和Node中都有实现。</p>
<p>在Youtube上找到了两个很精彩的演讲，通俗地解释了事件轮询的工作原理。</p>
<iframe width="1440" height="620" src="https://www.youtube.com/embed/8aGhZQkoFbQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="1440" height="620" src="https://www.youtube.com/embed/cCOL7MC4Pl0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


<p>了解事件轮询的工作原理，就能克服JavaScript异步编程的难点。</p>
<p>参考文章：<a href="https://blog.csdn.net/cofecode/article/details/80840817">https://blog.csdn.net/cofecode/article/details/80840817</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】JavaScript的执行上下文和调用堆栈</title>
    <url>/2019/10/05/2019-10-05%20%E7%BF%BB%E8%AF%91-JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.valentinog.com/blog/context/">JavaScript: What Is The Execution Context? What Is The Call Stack?</a><br>原文更新日期：2019.5.14<br>译文更新日期：2019.10.5  </p>
</blockquote>
<p>正文：</p>
<hr>
<p><img src="https://user-images.githubusercontent.com/18462980/66252280-3e68bd00-e78c-11e9-82b4-facf99258546.png" alt="image">  </p>
<h1 id="JavaScript：什么是执行上下文？什么是调用堆栈？"><a href="#JavaScript：什么是执行上下文？什么是调用堆栈？" class="headerlink" title="JavaScript：什么是执行上下文？什么是调用堆栈？"></a>JavaScript：什么是执行上下文？什么是调用堆栈？</h1><p><strong>JavaScript中的执行上下文</strong>是什么？  </p>
<p>你应该不知道这个问题的答案。一门编程语言最基础的组件是什么？  </p>
<blockquote>
<p>更新：这里有一篇改进并扩展的博客文章：<a href="https://www.valentinog.com/blog/engines/">JavaScript引擎：它们是如何工作的？从调用堆栈到Promise，您需要知道的一切</a>  </p>
</blockquote>
<p>变量和函数对吗？每个人都可以学会这些基础的概念。但是，除了这些基础之外还有什么？  </p>
<p>在成为中高级JavaScript开发者之前，您应该掌握哪些<strong>JavaScript的核心概念</strong>？  </p>
<p>答案有许多：作用域，闭包，回调函数，原型等等。  </p>
<p>但是在深入理解这些概念之前，您至少应该知道<strong>JavaScript引擎如何工作？</strong>  </p>
<p>这篇文章，我们将介绍每个JavaScript引擎都具备的两个基本部分：<strong>执行上下文和调用堆栈</strong>  </p>
<h2 id="您将会学到哪些东西"><a href="#您将会学到哪些东西" class="headerlink" title="您将会学到哪些东西"></a>您将会学到哪些东西</h2><p>通过这篇文章，您将学到：  </p>
<ul>
<li><p>JavaScript引擎如何工作  </p>
</li>
<li><p>JavaScript的执行上下文  </p>
</li>
<li><p>调用堆栈是什么  </p>
</li>
<li><p>全局执行上下文和局部执行上下文之间的区别  </p>
<h2 id="JavaScript如何运行您的代码？"><a href="#JavaScript如何运行您的代码？" class="headerlink" title="JavaScript如何运行您的代码？"></a>JavaScript如何运行您的代码？</h2><p>如果您是一个高级开发者，您可能已经知道了答案。<br>如果您是新手，那我们一起来探索。  </p>
<p>现在，看看下面的代码：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">num</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> num * num  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>试着回答我：<strong>您认为浏览器会以什么顺序来执行这段代码？</strong>  </p>
<p>换句话说，如果<strong>您</strong>是浏览器，您会如何解读这段代码？  </p>
<p>这看起来好像很简单。  </p>
<p>大多数人认为：“嗯，浏览器先执行函数<code>pow</code>，返回了结果，然后把2赋值给num。”  </p>
<p>您想知道我的学生们的回答吗？  </p>
<blockquote>
<p><em>从上到下</em><br><em>浏览器会从函数pow开始，计算num*num</em><br><em>JS 引擎会一行一行地运行代码（好像是这样）</em>  </p>
</blockquote>
<p>我倒是希望那样。  </p>
<p>几年前我也说过同样的回答。  </p>
<p>在接下来的几个部分，您将了解这些<strong>貌似简单的几行代码</strong>背后的机制。  </p>
<h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><p>要理解JavaScript如何运行，我们首先要了解第一个可怕的东西：**执行上下文(execution context)**。  </p>
<p>JavaScript中的执行上下文是什么？  </p>
<p><strong>每次在浏览器（或者Node）中运行JavaScript时，JS引擎都会执行一系列步骤。</strong>  </p>
<p>如今有两个著名的JavaScript引擎：<a href="https://developers.google.com/v8/">Google V8</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey">SpiderMonkey</a>  </p>
<p>V8是Google开源的 JavaScript 引擎，被用于Chrome浏览器和 Node.js 中。  </p>
<p>SpiderMonkey 是Mozilla的JavaScript引擎， 被用于Firefox浏览器。  </p>
<p>到目前为止，我们已经有了JavaScript引擎和一个执行上下文。  </p>
<p>现在是时候了解它们是如何协同工作的了。  </p>
<h2 id="它是如何运作的？"><a href="#它是如何运作的？" class="headerlink" title="它是如何运作的？"></a>它是如何运作的？</h2><p>每次您运行JavaScript代码时，引擎就创建了一个全局执行上下文。  </p>
<p>执行上下文是描述JavaScript代码运行环境的漂亮词汇。  </p>
<blockquote>
<p>译者注：Execution Context被译作执行上下文，“上下文”一词对于一些初学者来说可能有些抽象，我们可以理解为 <strong>供代码执行的一个环境，一个容器</strong>。  </p>
</blockquote>
<p>很难想象这些抽象的东西，我理解您。  </p>
<p>现在，把 全局作用域 想象成一个盒子：<br><img src="https://user-images.githubusercontent.com/18462980/66252642-6e19c400-e790-11e9-94f4-381c56327ba8.png" alt="image">  </p>
<p>我们再看之前的代码：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">num</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> num * num;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>引擎会如何解读这些代码？  </p>
<p>这是一个简化的版本：  </p>
<p><strong>引擎</strong>：第一行。这里有一个变量！我们把它存到全局内存(Global Memory)里吧。<br><strong>引擎</strong>：第三行。我看到了一个函数声明。我们把它也存进全局内存吧！<br><strong>引擎</strong>：看起来我完事了。  </p>
<p>如果我再问您一次：浏览器怎么“看”这些代码，您会怎么回答？  </p>
<p>是的，它是自上而下的，但是…  </p>
<p>您能看到，引擎并没有执行函数<code>pow</code>！  </p>
<p>它是一个<strong>函数声明</strong>，不是函数调用。  </p>
<p>上面的代码将转换存储在<strong>全局内存</strong>中的一些值：一个函数声明和一个变量。  </p>
<p><strong>全局内存？</strong>  </p>
<p>老哥，我已经被执行上下文搞得晕头转向了，现在您又扔一个“全局内存”给我？  </p>
<p>是的。  </p>
<p>让我们来看看全局内存是啥玩意。  </p>
<h2 id="全局内存"><a href="#全局内存" class="headerlink" title="全局内存"></a>全局内存</h2><p><strong>JS引擎也有一个全局内存。</strong>  </p>
<p>全局内存包含了全局变量和函数声明，供以后使用。  </p>
<p>如果您读过 Kyle Simpson的 “<strong>Scope和Closures</strong>”，您会发现“全局内存”和“全局作用域”的概念重叠。  </p>
<p>实际上，它们是同一样东西。  </p>
<p>我扯这么远，是有原因的。  </p>
<p>这些都是很难理解的概念。  </p>
<p>但是您现在不必担心。  </p>
<p>我想要您理解两个重要的点。  </p>
<p>当JS引擎运行您的代码时，它创建了：  </p>
<ul>
<li><p>一个全局执行上下文  </p>
</li>
<li><p>一个全局内存（也叫做全局作用域或者全局变量环境）  </p>
<p>现在清楚了吗？  </p>
<p>如果我是您的话，我现在会这么做：  </p>
</li>
<li><p>写一些JavaScript代码  </p>
</li>
<li><p>把自己当作引擎，一步一步解析代码  </p>
</li>
<li><p>在执行过程中，用图形表示<strong>全局执行上下文和全局内存</strong>  </p>
<p>您可以在纸上或者原型工具上试试。  </p>
<p>对于我的小例子，图片看起来是这样的：  </p>
<p><img src="https://user-images.githubusercontent.com/18462980/66252961-12e9d080-e794-11e9-836d-c9515ca3727f.png" alt="image">  </p>
<p>在接下来的部分，我们将看到另一个可怕的东西：<strong>调用堆栈</strong>。  </p>
<h2 id="调用堆栈是什么？"><a href="#调用堆栈是什么？" class="headerlink" title="调用堆栈是什么？"></a>调用堆栈是什么？</h2><p>您是否清楚<strong>执行上下文</strong>、<strong>全局内存</strong>和<strong>Javascript引擎</strong>是如何配合的？  </p>
<p>如果没有，请花时间回看上一部分。  </p>
<p>我们将要介绍拼图中的另一块：<strong>调用堆栈</strong>。  </p>
<p>让我们首先重温一下，当JS引擎运行您的代码时，它创建了：  </p>
</li>
<li><p>一个全局执行上下文  </p>
</li>
<li><p>一个全局内存  </p>
<p>除此之外，在我们的例子中没有发生什么：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">num</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> num * num;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这段代码就是单纯的值分配。  </p>
<p>让我们走远一点。  </p>
<p>如果我调用函数，会发生什么？  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">num</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> num * num;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> res = pow(num);  </span><br></pre></td></tr></table></figure>

<p>有趣的问题。  </p>
<p>在JavaScript中<strong>调用函数</strong>的行为，<strong>会使引擎请求帮助</strong>。  </p>
<p>这个帮助来自JavaScript引擎的一个朋友： <strong>调用堆栈</strong>。  </p>
<p>这听起来可能不太明显，但是JavaScript引擎需要跟踪正在发生的事情。  </p>
<p>它依赖于调用堆栈。  </p>
<p>那在JavaScript中，调用堆栈到底是什么？  </p>
</li>
</ul>
<p><strong>调用堆栈类似于程序当前执行的日志。</strong>  </p>
<p>实际上，它是一个数据结构：一个<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈</a>。  </p>
<p>不出意外，它有两个方法：加入数据（英语：push）和移除数据（英语：pop）。  </p>
<p>加入数据就是<strong>把某些东西加入堆栈</strong>。  </p>
<p>也就是说，当您在JavaScript中执行一个函数，引擎会把函数加入调用堆栈中。  </p>
<p>每个函数都会被加入到调用堆栈中。  </p>
<p>第一个加入的是<code>main()</code>(或者<code>global()</code>)，执行JavaScript程序的主线程。  </p>
<p>现在，上面的图片将会是这样：  </p>
<p><img src="https://user-images.githubusercontent.com/18462980/66253168-69580e80-e796-11e9-8f75-ff6e8d4e5f1c.png" alt="image">  </p>
<p>当一个函数执行完毕，它将会从调用堆栈中移除。  </p>
<p>然后我们的调用堆栈就会这样：  </p>
<p><img src="https://user-images.githubusercontent.com/18462980/66253178-b6d47b80-e796-11e9-8e96-225062b6ebf7.png" alt="image">  </p>
<p>那么现在呢？您已经做好准备去掌握每一个JavaScript概念了。  </p>
<p>我没开玩笑。  </p>
<p>但是我们还没结束！进入下一节！  </p>
<h2 id="局部执行上下文"><a href="#局部执行上下文" class="headerlink" title="局部执行上下文"></a>局部执行上下文</h2><p>到目前为止一切似乎都很清楚。  </p>
<p>我们是不是遗漏了什么？  </p>
<p>我们知道，<strong>JavaScript引擎创建了一个全局执行上下文和一个全局内存</strong>。  </p>
<p>然后，当您在代码中调用一个函数时：  </p>
<ul>
<li><p>JS引擎求助  </p>
</li>
<li><p>JS引擎的朋友 调用堆栈 过来帮忙  </p>
</li>
<li><p>调用堆栈追踪代码中正在调用的函数  </p>
<p>当您在执行一个函数时，还会发生另外一件事情。  </p>
<p>首先，函数出现在了全局执行上下文。  </p>
<p>然后，另一个 迷您版的上下文出现在函数身边：  </p>
<p>那个小盒子叫做：<strong>局部执行上下文</strong>。  </p>
<p>啥？？  </p>
<p>如果您注意到了，在前一幅图中，全局内存中出现了一个新变量: <code>var res</code>。  </p>
<p>变量<code>res</code>最初的值为<code>undefined</code>。  </p>
<p>然后，一旦<code>pow</code><strong>出现在全局执行上下文中，函数执行，res获取到函数的返回值</strong>。  </p>
<p>在执行过程中，一个局部的执行上下文创建了，用于存储局部变量。  </p>
<p>多么强大的概念。  </p>
<p><img src="https://user-images.githubusercontent.com/18462980/66253275-29922680-e798-11e9-8384-91222c4fe9c8.png" alt="image">  </p>
<p>请记住这些概念。  </p>
<p>理解全局和本地执行上下文是掌握<a href="https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed">作用域和闭包</a>的关键。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>您能相信这四行代码背后是什么吗？  </p>
<p>Javascript引擎创建执行上下文、全局内存和调用堆栈。  </p>
<p>但是，一旦您调用了一个函数，引擎就会创建一个本地执行上下文，其中包含一个本地内存。  </p>
<p>在这篇文章的最后，您应该能够理解当您运行一些Javascript代码时发生了什么。  </p>
<p>Javascript的内部机制常常被新手视为神秘的东西，也常常被忽视。  </p>
<p>然而，它们是掌握高级Javascript概念的关键。  </p>
<p>如果您学习了执行上下文、全局内存和调用堆栈，那么<strong>作用域、闭包、回调和其他东西</strong>就会很容易了。  </p>
<p>特别是，理解调用堆栈是至关重要的。  </p>
<p>一旦您将它可视化，所有的Javascript将开始清晰: 您将最终理解为什么Javascript是异步的，为什么我们确实需要回调。  </p>
<p>您知道4行Javascript代码背后是什么吗？  </p>
<p>现在您知道了。  </p>
<p>感谢阅读，敬请关注！</p>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1MTc0NTA2OTRdfQ==</li>
<li><p>-&gt;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
</search>
