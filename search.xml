<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F01%2F2019-08-01%20%E9%9A%8F%E7%AC%94-%E5%9B%BD%E5%86%85%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[技术翻译也是一种写作。 译者首先要理解原文作者的语意和语气，然后通过自己对其中意义，通过自身翻译语言的文化理解，用另一门语言翻译出来。既要保留原文的意义，又要符合译文读者的阅读习惯。这就是“义译”。 国内的技术翻译，质量良莠不齐。有精心校对的技术翻译组，也有凭着一脑子热情的独立译者。前者有审稿和校对，后者有热情。一般来说，前者质量高于后者。 独立译者又分为高水平的专家和普通水平的爱好者。专家会驾轻就熟地将一篇外文文章翻译成很流利的译文，他们经过了无数的练习，修订，核对，才练就一身高超的“译术”。普通爱好者往往半途而废， 我认识的专家有翻译《JavaScript高级程序设计》的李松峰。 如果技术翻译没有审核和校对，]]></content>
  </entry>
  <entry>
    <title><![CDATA[随笔-陪伴是一件自豪的事]]></title>
    <url>%2F2019%2F07%2F27%2F2019-07-27%20%E9%9A%8F%E7%AC%94-%E9%99%AA%E4%BC%B4%E6%98%AF%E4%B8%80%E4%BB%B6%E8%87%AA%E8%B1%AA%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[陪伴是一件自豪的事。 陪伴是一件自豪的事我经常陪母亲逛街。 以前我总觉得跟着妈妈逛街是一件很“妈宝”的事情，跟她走在一起，会感到不安。 我怕同学看到我，说我娇生惯养，男人的好强让我自尊心高涨。 长大以后，我才领悟，太在意别人的想法，是一种非常幼稚的表现。 陪伴本来就是一件让人自豪的事。 我牵着母亲的手，搂着母亲的肩膀，像她陪我小时候那样，走在人群中，走在街道上。 她个子比我矮许多，她笑得也像个孩子，我们走在路上就像父女俩。 周围人投来异样的眼光，我不在意。 他们或许惊讶，或许羡慕，或许嫉妒，都与我无关。 我对母亲的爱，是母亲引以为豪的财富，她很高兴。 只要她开心，就足够了。 感谢阅读，祝您生活愉快！The End.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔-写博客的意义]]></title>
    <url>%2F2019%2F07%2F25%2F2019-07-25%20%E9%9A%8F%E7%AC%94-%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[写博客的意义在哪里？ 写博客的意义Hexo是一个简洁，高效的静态博客工具，在使用它的两年时间里，我养成了持续写作的习惯。 在写作的过程中，我思考，博客的意义在哪里？ 我们技术宅喜欢折腾各种工具，各种软件，往往忽略了折腾的本质是什么。 折腾静态博客，比如Hexo，你可以说是为了脱离各个平台的限制，为了更高效地创作，为了省下ECS的钱。 但是本质都是为了更舒服地创作。脱离了这个本质的努力，都是浅尝辄止的浪费时间罢了。 类比生活和工作，工作的目的是为了更好地生活，生活是目的，工作是手段。很多人在二者关系上没有领悟，于是陷入加班和贫困的恶性循环中。 而我写博客的初衷，在于记录生活，沉淀知识，学会思考和写作。这是一个过程和习惯，而不是目的和手段。 写博客，让人平静，让思想深邃，让生活更美好。 这就是博客的意义。 感谢阅读，祝您生活愉快！The End.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译-JavaScript作用域的通俗解读]]></title>
    <url>%2F2019%2F06%2F22%2F2019-06-22%20%E7%BF%BB%E8%AF%91-JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%80%9A%E4%BF%97%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[摘要：作用域是JavaScript语言的基础概念之一，也可能是我在编写复杂程序时最挣扎的一个概念。我已数不清多少次，在函数间传递控制时，丢失了this关键字的指向。我也经常发现自己经常以各种令人困惑的方式扭曲自己的代码，试图在我理解哪些变量可以访问哪些地方的时候，让我保持清醒。 JavaScript作用域的通俗解读 （上篇）作用域是JavaScript语言的基础概念之一，也可能是我在编写复杂程序时最挣扎的一个概念。我已数不清多少次，在函数间传递控制时，丢失了this关键字的指向。我也经常发现自己经常以各种令人困惑的方式扭曲自己的代码，试图在我理解哪些变量可以访问哪些地方的时候，让我保持清醒。 这篇文章将正面解决问题，概述上下文和作用域的定义，检查两个允许我们修改上下文的JavaScript方法，并深入探讨我遇到的百分之九十的问题的有效解决方案。 原文：http://www.digital-web.com/articles/scope_in_javascript/原文发表于2006年11月11日。译文发表于2019年6月22日。译注单词表： - Scope : 作用域 - Context：上下文 - Scope Chain：作用域链 - Execution context: 执行上下文 我在哪里？你是谁？JavaScript程序的每一部分都在一个执行上下文中执行。你可以把这些上下文当作你的代码的邻居，告诉每一行代码它从哪来，还有它有哪些朋友和邻居。事实证明，这是重要的信息，因为JavaScript社会对谁可以与谁联系有着相当严格的规则；执行上下文更多地被认为是封闭社区，而不是开放式小区。 译注：封闭社区(gated communities): 一个通过大门控制交通和人流进出的住宅区。 我们通常可以将这些社会边界称为作用域，并且它们很重要，可以在每个社区的章程中编纂，我们将其称为上下文的作用域链。特定的相邻的代码只能访问其作用域链中列出的变量，并且相较于跟邻里之外的联系，代码更喜欢与本地变量的交互。 实际上说，评估一个函数的时候，会简历一个独特的执行上下文，将其本地作用域附加到其定义的范围链中。在一个特定上下文中，JavaScript通过作用域链的攀爬，从本地到全局地，解析标志符。这就意味着，同名的作用域链上更高的局部变量，优先级更高。这是有道理的：如果我的好朋友在一起讨论”Mike West”，很明显它们在谈论我，而不是同名的歌手或者教授，就算他们更加出名。 让我们通过一些实例代码来探讨其含义： 12345678910111213var ima_celebrity = &quot;Everyone can see me! I&apos;m famous!&quot;, // 明星 the_president = &quot;I&apos;m the decider!&quot;;` // 总统function pleasantville() &#123; // 欢乐谷 var the_mayor = “I rule Pleasantville with an iron fist!”, // 市长 ima_celebrity = “All my neighbors know who I am!”; function lonely_house() &#123; // 山上的小屋 var agoraphobic = “I fear the day star!”, // 广场恐惧症患者 a_cat = “Meow.”; // 猫 &#125; &#125; 我们的明星ima_celebrity，每个人都认识她。她在政治上很活跃，经常和总统联系，并且非常友好；她会为遇到的任何人签名并回答问题。也就是说，她和她的粉丝没有很多个人接触。她很确定他们的存在，并且他们可能在某个地方有自己的生活，但她当然不知道他们在做什么，甚至不知道他们的名字。 在欢乐谷（pleasantville）中，市长是一个众所周知的面孔。她经常在城市的街道穿行，和她的选民谈话，握手，还有亲吻小孩子。因为欢乐谷是一个很大很重要的社区，所以她的办公室里又一个大大的红色电话，给她一条直连总统的线，一周七天，一天24小时无休。她看到过城郊小山上有一间孤独的小屋（lonely_house），但是从不去关心谁住在里面。 那间孤独的小屋对它自己来说就是一个世界。有个广场恐惧症患者（agoraphobic）大多数时间待在里面，玩纸牌，喂猫(a_cat)。他好几次打电话给市长询问关于本地噪音的法规，并且在本地新闻上看到明星(ima_celebrity)后，甚至还给她写过一些粉丝信。 this? 是什么东西？除了建立作用域链之外，每个执行上下文都提供了一个名为this的关键字。在大多数的用法中，this提供一个标志的功能，为我们的社区提供了一个引用自身的方式。然而，我们不能总是依赖这个行为：依赖于我们如何进入一个特定的社区，this可能代表着完全不同的东西。事实上，我们如何访问社区本身this通常所指的内容。有四个场景值得我们关注： 调用一个对象的方法在典型的面向对象语言中，我们需要一种识别和引用我们当前正在使用的对象的方法。this令人欣慰，为我们的对象提供了检查自己的能力，并指出了自己的属性。 12345678var deep_thought = &#123; the_answer: 42, ask_question: function()&#123; return this.the_answer; &#125;&#125;var the_meaning = deep_thought.ask_question(); 这个例子新建了一个名为”deep_thought”的对象，将它的the_answer属性设置为42，并且创建了一个ask_question方法。当deep-thought.ask_question()执行了，JS为函数调用创建了一个执行上下文，将this设置为”.”之前引用的对象，在这个示例中就是deep_thought。这个方法通过this查看镜像以检查其自身的属性，并返回存储在this.the_answer中的值：42。 调用构造函数同样地，当定义一个要作为new关键字的构造器函数时，this可被用来指代正在创建的对象。让我们重写商民的例子来演示这个场景： 12345678function BigComputer(answer)&#123; this.the_answer = answer; this.ask_question = function()&#123; return this.the_answer; &#125;&#125;var deep_thought = new BigComputer(42);var the_meaning = deep_thought.ask_question(); // 42 我们没有直接创建这个deep_thought对象，而是写了一个函数去创建BigComputer对象，并且通过new关键字，实例化了一个deep_thought实例变量。当 new BigComputer()执行的时候，在后台公开地创建了一个全新的对象。BigComputer被调用了，并且它的this关键字被设置为引用那个新对象。这个函数可以在this上设置属性和方法，在BigComputer执行结束时公开地返回。 但是请注意，deep_thought.the_question()仍然像以前一样工作。那里发生了什么？为什么this在the_question内部与BigComputer内部的意义不一样？简单来说，我们通过new 进入了BigComputer，所以this表示”新对象”。另一方面，我们通过deep_thought进入了the_question，所以当我们执行了那个方法，this意味着”deep_thought指向的任何值”。this不像其他变量一样，从作用域链中读取，而是在上下文的基础上重置。 调用普通函数 如果我们只是调用一个普通的日常的没有其他花样的函数呢？在这种场景中this又如何指向？ 1234function test_this()&#123; return this;&#125;var i_wonder_what_this_is = test_this(); 在这种情况下，我们没有提供新的上下文，也没有给出一个背景形式的上下文来捎带。在这里，this可以引用最全局的东西：对于网页，就是window对象。 事件处理器（Event Handler）对于正常函数调用的更复杂的转换，假设我们正在使用函数来处理onclick事件。当事件出发我们的函数执行时，this指向哪里呢？不幸的是，这个问题没有简单的答案。如果我们内联地写一个事件处理函数，this指向全局的window对象：12345function click_handler()&#123; alert(this); // alerts the window object&#125;// ...// &lt;button id="thebutton" onclick="click_handler()"&gt;Click me!&lt;/button&gt; 然而，当我们通过JS来添加一个事件处理函数，this就指向了生成事件的DOM元素。123456789function click_handler() &#123; alert(this); // alerts the button DOM node &#125;function addhandler() &#123; document.getElementById(‘thebutton’).onclick = click_handler; &#125;window.onload = addhandler; 难题让我们在最后一个例子中运行一会儿。如果不是运行click_handler，我们每次点击按钮时都想”问deep_thought一个question”怎么办？代码看起来非常简单:1234567891011121314function BigComputer(answer) &#123; this.the_answer = answer; this.ask_question = function () &#123; alert(this.the_answer); &#125;&#125;function addhandler() &#123; var deep_thought = new BigComputer(42), the_button = document.getElementById(’thebutton‘); the_button.onclick = deep_thought.ask_question;&#125;window.onload = addhandler; 很完美，对吧？我们点击了按钮，deep_thought.ask_question被执行了，然后我们得到”42”。那么为什么浏览器却给我们返回了 undefined？我们那里错了？ 问题很简单：我们传递了对ask_question方法的引用，当作为事件处理程序执行时，该方法在与作为对象方法执行时不同的上下文中执行。简短来说，ask_question中的 this 关键字，指向了生成事件的DOM元素，而不是BigComputer对象。这个DOM元素没有the_answer属性，因此我们将返回undefined，而不是“42”。setTimeout 表现出类似的行为，延迟函数的执行，同时将其移动到了全局上下文中。 这个问题遍布在我们的程序中，如果没有仔细跟踪程序所有角落的情况，调试是一个非常困难的问题，特别是如果你的对象具有DOM元素上存在的属性或者window对象。 使用.apply() 和 .call()修改上下文我们很想在点击按钮的时候向deep_thought提一个问题，并且更一般地说，我们希望能够在响应事件和setTimeout调用之类的事情时在其本地上下文中调用对象方法。两个鲜为人知的JavaScript方法，apply()和call()，通过允许我们在执行函数调用时手动覆盖this的值，来间接启用这个功能。我们先来看call:12345678910111213var first_object = &#123; num: 42 &#125;; var second_object = &#123; num: 24 &#125;;function multiply(mult) &#123; return this.num * mult; &#125;multiply.call(first_object, 5); // returns 42 * 5 multiply.call(second_object, 5); // returns 24 * 5 未完待续…下一篇：《JavaScript作用域的通俗解读 （下篇）》]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-LeetCode in JavaScript(1) Two Sum]]></title>
    <url>%2F2019%2F05%2F19%2F2019-05-19%20%E7%AE%97%E6%B3%95-leetcode-js-1-two-sum%2F</url>
    <content type="text"><![CDATA[LeetCode JavaScript (1): Two Sum 直达链接：https://leetcode.com/problems/two-sum/ 问题Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 示例 Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 目标给定一个数组nums和一个目标值target，数组nums中如果有两数之和等于target，那么返回包含这个两个值的坐标的数组[i,j]。 解法一：暴力遍历最简单暴力的方法，就是遍历整个数组，最坏的情况是两个结果分别位于两端，数组要遍历两边。时间复杂度：O(n^2)空间复杂度：O(1) 12345678910var twoSum = function(nums, target) &#123; var i,len = nums.length; for (i=0;i&lt;len-1;i++) &#123; for (j=i+1;j&lt;len;j++) &#123; if (nums[i] + nums[j] === target) &#123; return [i,j]; &#125; &#125; &#125;&#125;; 解法二：哈希表比较高效的一个方法就是，以JavaScript的对象作为哈希表，通过对象的键值查询快速判断。将js对象当做hashtable来使用，key是数组元素的值，value是数组元素的索引，只遍历一次数组，每次先查找哈希表中是否有匹配的元素，如果没有就将现有元素添加进哈希表中。 从头遍历数组，通过哈希表，查找第一个元素a1的匹配值，如果哈希表中没有，就先缓存当前元素，以此类推。 每个元素都要通过对象查到匹配值，JavaScript对于对象的取值有所优化，所以查询哈希表的方法很高效。 所以哈希表的方法看似还是在遍历两次，但是其中的第二次遍历是在哈希表中执行的。JavaScript的对象取值速度很快，远远快于数组遍历。这就是优势所在。 关于JavaScript的性能问题，我打算在后面的博客写一篇性能分析。这里我推荐《高性能JavaScript》这本书，里面有关于优化性能的措施和原理。 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */function twoSum(nums, target) &#123; let len = nums.length; let hash = &#123;&#125;; for (let i = 0; i &lt; len; i++)&#123; let j = target - nums[i]; // hash table 要找的值 if(hash[j] !== undefined)&#123; // hash table里面有这个值，说明这个数组中存在匹配nums[i]的另一个数nums[j] return [i, hash[j]]; &#125;else&#123; hash[nums[i]] = i // hash table没有这个值,就先把它加入哈希表中，缓存。 &#125; &#125;&#125;;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何做一个受欢迎的人？]]></title>
    <url>%2F2019%2F04%2F19%2F2019-04-19%20%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%9F%A5%E8%AF%86%E5%B0%B1%E6%98%AF%E5%8A%9B%E9%87%8F%E3%80%8B%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E4%BA%BA%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[“受欢迎”是每个人都需要的、都想要的，如何做一个受欢迎的人？ 受欢迎的必要性社会属性动物的天性这是人类天性决定的，人类时社会性动物。 每个人都需要，都想要“受欢迎”，这是人的个人价值体现。 你永远无法预知谁能在什么时候帮你一把！人生是一个无限游戏，无限游戏的特点就是不断扩展游戏的边界。人生的边界一直在扩展，你无法预知谁会在关键时刻，帮你一把。做一个受欢迎的人，就像买了保险一样，在关键时刻，会有人支持和帮助你。 如何受别人欢迎？1. 重视别人，尊重别人尊重每一个人，喜欢别人。 人的互惠天性导致会喜欢那些喜欢我们的人。 永远不要鄙视别人，否则将永远得不到原谅 2. 诚恳对人，用“无知之幕”忽略别人的背景尊重要落到实处，要真诚，尽量不假手于他人。 3. 找人帮忙，体现别人的价值找人帮忙，别人帮你一个忙，就会倾向于帮你一个更大的忙 4. 成为有价值的人有实力，有用处，能够提供交换价值，这也是人生的意义所在。 你的存在要能够改变一些东西的价值。 乡愿，德之贼也。你到处想要讨好人，所有人都会看不起你。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笔记，随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员还是工程师？]]></title>
    <url>%2F2019%2F04%2F07%2F2019-04-13%20%E9%9A%8F%E7%AC%94-%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%98%E6%98%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[程序员和工程师之间有什么区别？我到底要做程序员还是工程师？ 我是一名程序员，但是每次我向别人自我介绍时，说我就是一个程序员的时候，我的内心是自卑的。 我觉得这个名词没有给我带来自豪感，让我觉得自己的工作就像一个流水线的工人一样，一个工地上的工人一样，平庸、平凡。 但是我又觉得自己的工作是很有意义的，我参与开发一个给上千万的用户使用的产品，这给我成就感。 所以我更愿意自称为工程师，一名前端开发工程师。 程序员 ProgrammerProgrammer在国外是一个很普遍的职业，这是一个通过编程解决业务问题的职业。没有高低贵贱之分，一门行业而已，对社会有创造价值即可。 但是在中国，Programmer被翻译为程序员，这个名词开始慢慢带有贬义和轻蔑的意味。由于中国互联网环境的加班文化，以及大众对程序员的普遍印象，大家对程序员有一个刻板印象。油腻、呆滞、情商低、无聊、偏执、不修边幅等等，这些标签伴随着程序员这个名词。所以一个互联网的技术从业者，自我介绍说自己是一个程序员时，对方脑海中的第一印象，就是一个邋遢愚蠢的形象。 这些刻板印象的形成和传播，一是由于互联网信息流对程序员这门行业的曝光越来越多，程序员又是距离互联网最近的一批人，他们的生活状态和个人形象被曝光的几率也很高；二是由于中国互联网的加班文化，让程序员这门行业的工作状态十分紧张，大多数公司的程序员并没有多少时间关注自己的生活，更别说自己的个人形象，个人修养了。 而随着这些印象的逐步传播，大众对于程序员这门行业的评价就趋向于固定，没日没夜的加班，毫无情趣的生活，高智商低情商的屌丝… 这种大众印象，不断给程序员们心理暗示。于是，程序员们默默接受了这个印象，自己甘愿停在这个状态，不愿改变自己。 所以如果一个人如果自称自己是程序员，或多或少会有一点自嘲的意味。 自己的行业本来和其他行业没什么区别，可以说程序员这门行业在所有行业中，应该属于前20%，他们享受互联网公司的高待遇，获得相比其他行业高得多的薪水，虽然加班很严重也很普遍，但是其他行业也加班啊，区别就是，后者没有在网络上有足够的曝光罢了。 工程师 Engineer工程师和程序员的区别很大。 程序员觉得自己是一个螺丝钉。自己只是整个公司，整个系统的一个小蚂蚁，对这个庞大的系统来说，自己微不足道。 工程师认为自己是整个系统的不可或缺的一员，自己对整个系统有很清晰的认识，对公司的业务架构有自己的见解。就算自己的工作只是维护或者开发一个很小的功能，但是以自己的工程能力，自己能对整个系统有更深的认识。 二者的区别程序员管中窥豹，工程师庖丁解牛。 程序员只关注自己的任务，工程师为整个系统考虑，包括安全、性能、可维护等全局的影响。 程序员只关注工作本身，对工作以外的生活没有追求，自己更愿意封闭在自己的世界里。工程师认为工作只是生活的一部分，虽然工作占了很大部分，但是工作之外同样重要，生活是工作的目的，而不是附属。生活往往能给自己启发和灵感，提高工作效率，升华工程思想。一个工程师一定会有自己长期坚持的爱好，他很清楚如何区分自己的工作和生活。而程序员，往往没什么爱好，而且在工作中，效率不高，经常自我干扰打断，在生活中又经常被工作的事务打断。 程序员经常为了各种偏执的问题争吵不休。为了将自己偏爱的语言、工具和别人一较高低，为此获得优越感，这种事情在论坛中屡见不鲜。而工程师具有清晰的价值观和评判标准，语言、工具都是为了解决工程问题而选择的”设备”，它们之间各有优劣却并无高低之分，因为工程问题和应用场景不同，必然会有不同的选择，所以它们互相比较没有意义。纵然所有工具都有缺陷，但是程序员喜欢用田忌赛马的方式，来为自己争取优越感，因为他们生活的优越感来源不多。 程序员经常在工作中因为各种BUG而抱怨不休，抱怨前人写的烂代码，抱怨测试人员的不细致，抱怨项目经理对流程把控不严格。 工程师总是思考系统为什么会有这么多BUG，是软件工程的流程问题，还是系统设计缺陷？如果要解决这个困境，如何寻找更好的解决方案？如果有了解决方案，如何获得团队的认可，号召大家一起来干？ 所以，不要自称程序员，称自己是一个工程师，然后不断朝着成为一位专业的工程师而不断努力。 Written with StackEdit.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文摘-乔布斯在斯坦福大学的演讲]]></title>
    <url>%2F2019%2F04%2F05%2F2019-04-07%20%E9%9A%8F%E7%AC%94-%E4%B9%94%E5%B8%83%E6%96%AF%E5%9C%A8%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%BC%94%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[乔布斯在斯坦福大学的演讲《Speech in Stanford》 乔布斯是我的偶像。纵然他有很多缺点，有的缺点让世人无法接受，他仍然是我的偶像。 这篇演讲是在2005年斯坦福大学的毕业典礼上发表的，乔布斯当时是苹果公司的CEO，兼任皮克斯动画工作室的CEO。乔布斯(1955-2011)，演讲时年50岁，刚刚经历胰腺癌的治疗并且”暂时”痊愈，他用自己的人生经历向当时的斯坦福毕业生，以及全世界的观众，表达了自己对人生坚定的信念。 中心观点 Love what you do, believe it is great work. Keep looking for things you love, don’t settle. Your time is limited, don’t waste it living someone else’s life. Don’t let the noise of others’ opinions drown out your inner voice. Have the courage to follow your heart and intuition. Stay Hungry. Stay Foolish. Time point of the speechThis is a prepared text of the Commencement address delivered by Steve Jobs, CEO of Apple Computer and of Pixar Animation Studios, on June 12, 2005. The original text of the speechI am honored to be with you today at your commencement from one of the finest universities in the world.I never graduated from college.Truth be told, this is the closest i’ve ever gotten to a college graduation.Today I want to tell you three stories from my life.That’s it. No big deal. Just three stories. The first story is about connecting the dots. I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out? It started before I was born.My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption.She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife.Except that when I popped out they decided at the last minute that they really wanted a girl.So my parents, who were on a waiting list, got a call in the middle of the night asking: “ We have an unexpected baby boy; do you want him?”They said: “Of course.”My biological mother later found out that my mother had never graduated from high school.She refused to sign the final adoption papers.She only relented a few months later when my parents promised that I would someday go to college. And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition.After six months, I couldn’t see the value in it.I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out.And here I was spending all of the money my parents had saved their entire life.So I decided to drop out and trust that it would all work out OK.It was pretty scary at the time, but looking back it was one of the best decisions I ever made.The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting. It wasn’t all romantic.I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned Coke bottles for 5$ deposit to buy foods with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple.I love it.And much of what I stumbled into by following my curiosity and intuition turned out be priceless laster on. 我追随自己的好奇心和直觉，偶然发现其中的大部分内容，后来都变得无价之宝。 Let me give you one example:Reed College at that time offered perhaps the best calligraphy instruction in the country.Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed.Because i had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.I learned about serif and sans serif typefaces, about varying the amount of space between defferent letter combinations, about what makes great typography great.It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating. None of this had even a hope of any practical application in my life.But 10 years later, when we were designing the first Macintosh computer, it all came back to me.And we designed it all into the Mac.It was the first computer with beautiful typography.If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts.And since Windows just copied the Mac, it’s likely that no personal computer would have them.If I had never dropped out, I would have never dropped in on the calligraphy class, and personal computers might not have the wonderful typography that they do.Of course it was impossible to connect the dots looking forward when I was in college.But it was very, very clear looking backward 10 years later. Again, you can’t connect the dots looking forward; you can only connect them looking backward.So you have to trust that the dots will somehow connect in your future.You have to trust in something - your gut, destiny, life, karma, whatever.This approach has never let me down, and it has made all the difference inmy life. My second story is about love and loss. I was lucky – I found what I loved to do early in life.Woz and I started Apple in my parents’ garage when I was 20.We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4,000 employees.We had just released our finest creation – the Macintosh – a year earlier, and i had just turned 30.And then I got fired.How can you get fired from a company you started?Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well.But then our visions of the future began to diverge and eventually we had a falling out.When we did, our Board of Directors sided with him.So at 30 I was out.And very publicly out.What had been the focus of my entire adult life was gone, and it was devastating. I really din’t know what to do for a few months.I felt that I had let the previous generation of entrepreneurs down – that I had dropped the baton as it was being passed to me.I met with David Packard and Bod Noyce and tried to apologize for screwing up so badly.I was a very public failure, and I even thought about running away from the valley.But something slowly began to dawn on me – I still loved what I did.The turn of events at Apple had not changed that one bit.I had been rejected, but I was still in love.And so I decided to start over. I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me.The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything.It freed me to enter one of the most creative periods of my life. During the next five years, I started a company name NeXT, another company name Pixar, and fell in love with an amazing woman who would become my wife.Pixar went on to create the world’s first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.In a remarkable turn of events, Apple bought NeXT, I returned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance.And Laurene and I have a wonderful family together. I’m pretty sure none of this would have happened if I hadn’t been fired from Apple.It was awful tasting medicine, but I guess the patient needed it.Sometimes life hits you in the head with a brick.Don’t lose faith.I’m convinced that the only thine that kept me going was that I loved what I did.You’ve got to find what you love.And that is as true for your work as it is for your lovers.Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work.And the only way to do great work is to love what you do.If you haven’t found it yet, keep looking.Don’t settle.As with all matters of the heart, you’ll know when you find it.And, like any great relationship, it just gets better and better as the years roll on.So keep looking until you find it.Don’t settle. My third story is about death. When I was 17, I read a quote that went something like: “If you live each day as if it was your last, somyday you’ll most certainly be right.”It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “if today were the last day of my life, would I want to do what I’m about to do today?”And whenever the answer has been “No” for too many days in a row, I know I need to change something. Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help m make the big choices in life.Because almost everything – all external expectations, all pride, all fear of embarrassment or failure – these thins just fall away in the face of death, leaving only what is truly important.Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose.You are already naked.There is no reason not to follow your heart. About a year ago I was diagnosed with cancer.I had a scan at 7:30 in the moning, and it clearly showed a tumor on my pancreas.I didn’t even know what a pancreas was.The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months.My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die.it means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months.It means to make sure everything is buttoned up so that it will be as easy as possible for your family.It means to say your goodbyes. I lived with that diagnosis all day.Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor.I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery.I had the surgery and I’m fine now. This was the closest I’ve been to facing death, and I hope it’s the closest I get for a few more decades.Having lived through it, I can now say this to you with a bit more certainty that when death was a useful but purely intellectual concept: No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but somyday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true. Your time is limited, so don’t waste it living someone else’s life.Don’t be trapped by dogma – which is living with the results of other people’s thinking.Don’t let the noise of others’ opinions drown out your own inner voice.And most important, have the courage to follow your heart and intuition.They somehow already know what you truly want to become.Everything else is secondary. When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960s, before personal computers and desktop publishing, so it was all made with typewriters, scissors and Polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: It was idealistic, and overflowing with neat tools and great notions. Stewart and his team put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words:” Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you. Stay Hungry. Stay Foolish. Thank you all very much. 参考资料演讲视频链接：https://www.youtube.com/watch?v=UF8uR6Z6KLc演讲报告原文：https://news.stanford.edu/2005/06/14/jobs-061505/]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>文摘</tag>
        <tag>随笔</tag>
        <tag>演讲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔-学习的诀窍：对外输出]]></title>
    <url>%2F2019%2F03%2F27%2F2019-03-27%20%E9%9A%8F%E7%AC%94-%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%80%E7%AA%8D%EF%BC%9A%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[我写博客，对外输出文字，为了让大家认可，让读者有所收获，我会努力将文章写的简洁易懂，并且反复检查自己的观点、看法，思考自己的理解是否准确。 学习是一项输入的过程我们四处收集信息，然后经过大脑的理解和记忆，输入到大脑皮层，存储在神经元。 外界通过感觉器官进入大脑的信息量是很大的，但估计仅有1%的信息能被较长期地贮存记忆，而大部分却被遗忘。能被长期贮存的信息都是对个体具有重要意义的，而且是反复作用的信息。因此，在信息贮存过程中必然包含着对信息的选择和遗忘两个因素。信息的贮存要经过多个步骤，但简略地可把记忆划分为两个阶段，即短时性记忆和长时性记忆。在短时性记忆中，信息的贮存是不牢固的，例如，对于一个电话号码，当人们刚刚看过但没有通过反复运用而转入长时性记忆的话，很快便会遗忘。但如果通过较长时间的反复运动，则所形成的痕迹将随每一次的使用而加强起来；最后可形成一种非常牢固的记忆，这种记忆不易受干扰而发生障碍。 “输出”如何加强学习？我写博客，对外输出文字，为了让大家认可，我会努力将文章写的简洁易懂，并且反复检查自己的观点、看法，思考自己的理解是否准确。 输出对学习的帮助主要在于输出的过程，而不是输出的成果。 写博客，翻译技术文档，发表社区文章，都是输出的优秀渠道。 所以，不用在意大多数是否认同，追求认同感是虚荣的表现。 自己努力了，就能学到很多，理解的更彻底。 参考链接：http://www.a-hospital.com/w/%E7%94%9F%E7%90%86%E5%AD%A6/%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%AE%B0%E5%BF%86]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全手册（一）：资源收集]]></title>
    <url>%2F2019%2F03%2F14%2F2019-03-14%20%E7%AC%94%E8%AE%B0-web%E5%AE%89%E5%85%A8%E6%89%8B%E5%86%8C%EF%BC%9AOWASP%20-%20%E5%BC%80%E6%94%BE%E5%BC%8Fweb%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[OWASPOWASP 全称:# The Open Web Application Security Project中文名称：开放式Web应用程序安全项目 wikipedia介绍：https://zh.wikipedia.org/wiki/OWASPOWASP的官网：https://www.owasp.org/index.php/Main_Page 简单介绍：开放式Web应用程序安全项目（OWASP）是一个在线社区，在 Web应用程序安全性领域 提供免费的文章，方法，文档，工具和技术。 OWASP在github开源了很多项目，这是它的organization：https://github.com/OWASP 包括一些很完善的项目： CheatSheetSeries 这个表列出了几乎所有的网络安全漏洞以及防范指南，不必去各大论坛看良莠不齐的文章了，认真阅读这个仓库，就会有很大的收获。如果它没有中文翻译的话，我希望参与翻译。 The Mobile Security Testing Guide (MSTG) The Mobile Security Testing Guide (MSTG) is a comprehensive manual for mobile app security testing and reverse engineering. 移动安全测试指南，是一个面向移动APP测试和反向工程的全能指南。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>‘安全’</tag>
        <tag>收藏夹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-《远见》读书笔记]]></title>
    <url>%2F2019%2F03%2F09%2F2019-03-09%20%E9%98%85%E8%AF%BB-%E3%80%8A%E8%BF%9C%E8%A7%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[远见是一本关于职业生涯规划的书，从封面看好像很出名。不过这里面有一些核心观点还是很入木三分。 职业生涯至少长达45年，分为三个阶段 加添燃料，强势开局。一般在38岁之前。 聚焦长板，达到高点。一般在53岁前。 优化长尾，持续发挥影响力。一般在68岁之前。 职场燃料：走完职业生涯的基础 可迁移技能 有意义的经验 持久的关系 职场数学：使用数字和表格进行评估目前的职业 对目前工作的4个黄金问题，评估分值 一周100小时测试，合理投资时间 职场路径向导：做出正确的职业决策之前，需要回答三个问题： 你的职业理想是什么？ 你目前有哪些职场燃料？ 你需要多少职场燃料才能实现它？ 快速成长才能获得长远成功。快速成长的工作特点： 你周围都是比你聪明的人 你有失败的机会 公司有向让这样的人肩负重任的传统 看一家公司里的人有多聪明，就看他招聘时的挑剔程度。 Written with StackEdit.]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-如何忽略一个submodule]]></title>
    <url>%2F2019%2F03%2F05%2F2019-03-05%20%E6%8A%80%E6%9C%AF-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BD%A0%E7%9A%84Git%E4%BB%93%E5%BA%93%E4%B8%AD%E5%BF%BD%E7%95%A5%E4%B8%80%E4%B8%AAsubmodule%2F</url>
    <content type="text"><![CDATA[痛点在Hexo和Travis搭配的过程中，遇到了submodule的问题。 HEXO中，我使用了NexT主题，该主题的一些功能，需要依赖一些插件，也就是直接clone一些repo到主题的目录下。比如加载进度的pace插件，移动设备的fastclick插件。但是clone之后，Git会默认为我安装的插件是一个submodule，submodule在一个repo中，是不会被track的，也就是它不会以文件形式存在于repo中。Git这样设计就是为了尽量减小repo的体积，以及更灵活地控制依赖。 但是冲突就来了。 TravisCI在构建时，submodule里的文件不存在，在CI中无法构建，我的博客静态页面生成不了。 要么在构建时报错，要么生成的页面是空白的。 解药直接忽略一个submodule，使用几行命令即可解脱这个痛点。所有submodule的文件都要成为整个repo的一部分。 123456git rm --cached submodule_path # delete reference to submodule HEAD (no trailing slash)git rm .gitmodules # if you have more than one submodules, # you need to edit this file instead of deleting!rm -rf submodule_path/.git # make sure you have backup!!git add submodule_path # will add files instead of commit referencegit commit -m "remove submodule" 参考链接 StackOverflow的解答 https://stackoverflow.com/questions/1759587/un-submodule-a-git-submoduleGit submodule的概念和命令 Written with StackEdit.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Commit Message规范参考]]></title>
    <url>%2F2019%2F01%2F24%2F2019-01-24%20%E5%B7%A5%E7%A8%8B-Git%20Commit%20Message%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[注：在Git协作模式的团队中，Commit Message的规范对版本控制起着很重要的作用。本文引用自团队内部的规范，分享出来，一是为了贡献社区，二是为了加深印象。 Commit Message规范在git开发流程中，每次git commit，都需要对该次commit添加描述信息，描述此次commit的具体改动内容。规范的commit message格式，可以让团队成员对每次改动内容进行快速了解，也可以方便git log时的浏览和筛选。 目前社区使用最广的是 AngularJS 的规范： Google Docs 原文 阮一峰博客对于commit message的介绍 简述一条完整的提交信息(commit message)一般来说包含Header和Body，其中Header是必须的，Body是可选的。 对于大部分可以简单描述清楚的改动，只需要一个Header即可。 而对于一些需要更详细说明、要分条列出的改动，我们在Header进行简述之外，还要在Body中详细描述。 一般而言，Header长度不应超过50个字符，如果超过的话则考虑添加Body进行详述。 我们通常使用的git commit -m &quot;&lt;Commit Message Header&gt;&quot;，就是只添加单行的Header信息。例如： 12# 这里只添加了Headergit commit -m "feat(官网主页): 将iOS的头部背景与Android统一，不再使用默认蓝色图片" 如果需要添加Body详细信息，则使用git commit进入文本编辑器，再进行具体编辑。例如： 1234567# 这里既添加了Header，又添加了Bodychore(构建优化): 解决构建流程几个问题- 每次构建chunkhash会改变的问题- 内联和外链样式重复问题- 图片md5错误问题- 提取项目公共vendor 具体规范从上面的示例可以看到，Header的格式为：&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;。 Header主要由type, scope和subject三部分组成： type用来描述这次提交属于哪一类修改，比如是完成需求还是修复BUG。（必需） scope用来描述这次提交涉及的范围，比如是详情页还是礼包页。对于一些没有明确范围的改动，可以忽略。（可选） subject是这次提交的简单描述，具体做了什么。如果50字符内不能描述清楚，建议添加Body继续描述。（必需） type类别常用： feat - 新增需求、需求迭代、新功能等相关的提交 fix - BUG修复提交 docs - 文档相关的提交 refactor - 技术优化类的代码重构，不影响具体需求和逻辑，也不涉及BUG修复的修改，如：测速优化、性能优化、模块拆分等 chore - 代码维护相关的小改动，如：更新依赖库、构建工具及其配置的改动、代码格式调整等 较不常用： workflow - 开发工作流的改动，比如修改package.json中的scripts，比如增加或修改一些发布脚本 test - 测试相关的修改，比如增加测试用例。 Revert在需要回滚某些改动的时候，使用revert: &lt;reverted commit Header&gt;格式，也就是将回滚的那一条提交的Header作为revert后的内容。 例如，之前进行了某些改动： 1fix(礼包页): 修复了礼包页展示不完全的bug 之后发现这个改动会引起一些其他的bug，不得已需要回滚： 1revert: fix(礼包页): 修复了礼包页展示不完全的bug 注意事项 scope不是必须的，也没有具体的限定，但是有明显范围特征的尽量写上。（比如下面例子中的(详情页)）； 注意描述要清晰，要针对改动本身，让其他成员在没有任何上下文的情况下，也能看懂改动了什么。 不写废话（不过可以偶尔卖个萌😉）； typo修正、代码格式调整之类的，在AngularJS标准里另分到style类别，我们统一放在chore当中。这些很细小的改动，描述可以不用特别详细； 应保证改动和commit一一对应； 一个commit只对应一处改动、一个需求或一个BUG，不要把多个改动集中混在一起提交。在同时修改了多个文件时，不要直接git add .，应该挑选相关的文件进行add和commit，再挑选另一部分文件进行add和commit； 一处改动、一个需求或一个BUG，应尽量集中在同一个commit中，不要开发到中途先提交一次，开发完成再提交一次。 1234567891011# Badfix: bug修复fix: 修复了测试昨天发现的bugfeat: 完成了今天排期的需求# OKchore: 修正了几处拼写错误# Goodfeat: 在新的主页新增了一个关闭按钮fix(详情页): 修复展开活动的sid为string的bug]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>规范</tag>
        <tag>Git</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-如何阅读英文技术文档]]></title>
    <url>%2F2018%2F09%2F08%2F2018-09-08%20%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%BC%9A%E9%98%85%E8%AF%BB%E8%8B%B1%E6%96%87%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[摘要：我喜欢学习、热爱技术，在走了很多弯路后，领悟到快速入门一个工具、一项技术乃至一个领域，最快也是最扎实的方法，往往是从官方文档开始。 如何阅读英文技术文档为什么要读英文文档？ 阅读英文文档是程序员的基础能力 很多技术都是国外开发者创造的，英文文档最接近作者的本意 中文社区鱼龙混杂，合格的中文文档需要时间和精力去搜寻 良性循环提高英文水平 找到文档 通过Google找到官方网站 在官方网站上，找到入门文档和详细的开发文档 准备开始 快速浏览目录、大纲 仔细阅读首页的文档说明 从入门介绍开始 明确自己的目标 克服障碍 生词障碍 语义障碍 文档错误 辅助工具 通过浏览器插件 通过笔记类应用程序 通过纸质笔记本 做标记 阅读进度标记 常用页码标记 生词标记 总结 阅读英文文档是一项很重要的能力 阅读能力决定于英文水平 英文水平和阅读能力是相辅相成的 感谢阅读，祝您生活愉快！The End.]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array.prototype.sort()的高级用法]]></title>
    <url>%2F2018%2F01%2F28%2F2018-01-28%20%E5%89%8D%E7%AB%AF-Array.prototype.sort%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Array.prototype.sort()一、基本操作sort()方法的默认排序顺序是根据串Unicode码点。 12345678var fruit = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];fruit.sort();//[&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;]var scores = [1, 10, 21, 2];scores.sort();//[1, 10, 2, 21]//这里的10竟然在2之前，因为在Unicode指针顺序中 &apos;10&apos; 在 &apos;2&apos; 之前。 二、进阶操作（compareFunction）这时我们需要一个比较函数，来得到我们所需要的排序。如果指明了compareFunction,那么数组会按照调用该函数的返回值排序。即a和b是两个将要被比较的元素： 2.0 字符串排序123456789101112var str_arr = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];function compareStr(a, b)&#123; if(a&lt;b)&#123; return -1; &#125; if(a&gt;b)&#123; return 1; &#125; return 0;&#125;str_arr.sort(compareStr);// [&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;] 2.1 数字排序 如果compareFunction(a, b)小于0，那么a会排到b之前； 如果compareFunction(a, b)等于0 , 那么位置不变； 如果compareFunction(a, b)大于0，那么b会排到a之前；12345678910111213141516function compareNumbers(a, b)&#123; return a - b;&#125;var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b)&#123; return a - b;&#125;);console.log(numbers);//也可以写成：var numbers = [4, 2, 5, 1, 3];numbers.sort((a, b) =&gt; a - b);console.log(numbers);//输出：[1, 2, 3, 4, 5] 2.2 对象按照某个属性排序1234567891011121314151617181920212223242526var items = [ &#123; name: 'Edward', value: 21 &#125;, &#123; name: 'Sharpe', value: 37 &#125;, &#123; name: 'And', value: 45 &#125;, &#123; name: 'The', value: -12 &#125;, &#123; name: 'Magnetic' &#125;, &#123; name: 'Zeros', value: 37 &#125;];//按value值排序items.sort(function (a,b)&#123; return (a,.value - b.value)&#125;);//按name值排序items.sort(function(a, b)&#123; var nameA = a.name.toUpperCase(); var nameB = b.name.toUpperCase(); if(nameA &lt; nameB)&#123; return -1; &#125; if(nameA &gt; nameB)&#123; return 1; &#125; return 0;&#125;); 三、高级操作：使用映射改善排序compareFunction可能需要对元素做多次映射以实现排序，尤其当compareFunction较为复杂，且元素较多的时候，某些compareFunction 可能会导致很高的负载。使用map辅助排序将会是个好主意。 基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。 123456789101112131415161718// 需要被排序的数组var list = [&apos;Delta&apos;, &apos;alpha&apos;, &apos;CHARLIE&apos;, &apos;bravo&apos;];// 对需要排序的数字和位置的临时存储, mapped为临时容器var mapped = list.map(function(el, i) &#123; return &#123; index: i, value: el.toLowerCase() &#125;;&#125;)// 按照多个值排序数组mapped.sort(function(a, b) &#123; return +(a.value &gt; b.value) || +(a.value === b.value) - 1;&#125;);// 根据索引得到排序的结果var result = mapped.map(function(el)&#123; return list[el.index];&#125;);//result : [&quot;alpha&quot;, &quot;bravo&quot;, &quot;CHARLIE&quot;, &quot;Delta&quot;]]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google工程师等级评分卡]]></title>
    <url>%2F2018%2F01%2F02%2F2018-01-02%20Google%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AD%89%E7%BA%A7%E8%AF%84%E5%88%86%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[摘要：Google对于工程师的分级有一套方法论，一共分为十级。 评分等级 You are unfamiliar with the subject area. You can read/understand the most fundamental aspects of the subject area. Ability to implement small changes, understand basic principles and able to figure out additional details with minimal help. Basic proficiency in a subject area without relying on help. You are comfirtable with the subject area and all routine work on it: For software areas - ability to develop medium programs using all basic language features w/o book, awareness of more esoteric feature(with book). For systems areas - understanding of many fundamentals of networking and systems administration, ability to run a small network of system including recovery, debugging and nontrivial troubleshooting that relies on the knowledge of internals. An even lower degree of reliance on reference materials. Deeper skills in a field or specific technology in the subject area. Ability to develop large programs and systems from scratch. Understanding of low level details and internals. Ability to design / deploy most large, distributed systems from scratch. You understand and make use of most lesser known language features, technologies, and associated internals. Ability to automate significant amounts of systems administration. Deep understanding of corner cases, esoteric features, protocols and systems including “theory of operation”. Demonstrated ability to design, deploy and own very critical or large infrastructure, build accompanying automation. Could have written the book about the subject area but didn’t; works with standards committees on defining new standards and methodologies. Wrote the book on the subject area(there actually has to be a book). Recognized industry expert in the field, might have invented it. 科目领域 TCP/IP Networking (OSI stack, DNS etc) Unix/Linux internals Unix/Linux Systems administration Algorithms and Data Structures C C++ Python Java Perl Go Shell Scripting(sh, Bash, ksh, csh) SQL and/or Database Admin Scripting language of your choice(not already mentioned) People Management Project Management]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更好用的border-box]]></title>
    <url>%2F2017%2F10%2F23%2F2017-10-23%20%E5%89%8D%E7%AB%AF-%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84border-box%2F</url>
    <content type="text"><![CDATA[英文原文来自CSS-tricks: Inheriting box-sizing Probably Slightly Better Best-Practice 我是把box-sizing重置为border-box的忠实粉丝，甚至于我们有一个“年度特别日子”。但是这里有一个细小的调整，而且看起来是个不错的思路。这是微调的版本：123456 html&#123; box-sizing: border-box;&#125;*, *:before, *:after&#123; box-sizing:inherit;&#125; 感谢Job Neal的继承思想，他说： This will give you the same result ,and make it easier to change the box-sizing in plugins or other components that leverage other behavior.这会给你同样的结果，而且使得在插件中或其他组件中更容易改变 box-sizing 的值，而不会影响别的表现。 进一步解释，打个比方，你有一个组件，它本被设计为默认的box-sizing 为 content-box. 你只想要使用，又不搞砸它。 12345.component&#123; /*旨在以默认的box-sizing工作*/ /*在你的页面中， 你可以把它重置为normal */ box-sizing: content-box;&#125; 但问题是，这样实际上并不重置整个组件。也许在组件内部有一个&lt;header&gt;，期望它在一个content-box中。如果这个选择器在你的CSS中，老办法就是做一个 box-sizing reset… 123*&#123; box-sizing: border-box;&#125; 然后这个header不是你想要的content-box, 而是 border-box. 就像：1234&lt;div class= "component"&gt; &lt;!-- I'm content box --&gt; &lt;header&gt; &lt;!-- I'm border-box still&gt; &lt;/header&gt;&lt;/div&gt; 为了更简单直观地做到reset，你可以使用文章顶部的继承的代码段，继承的值就会被保留。123456 html&#123; box-sizing: border-box;&#125;*, *:before, *:after&#123; box-sizing:inherit;&#125; 这并不是一个很庞大的东西。你可能已经在使用 box-sizing reset 的老办法，并且从没踩到这个坑。但是，只要我们推广一个“最佳实践”风格的片段，我们也可以慢慢把它变成最好的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-09-05-翻译了第一篇英文文档]]></title>
    <url>%2F2017%2F09%2F05%2F2017-09-05%20%E9%9A%8F%E7%AC%94-%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BF%BB%E8%AF%91MDN%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[9月4日翻译了MDN上的一篇英文文档，这是第一次尝试翻译，尝到了成就感. MDN是Web开发者的参考文档的官方网站——MDN Web 文档，有大量开发者不断贡献和更新文档和教程。 做了什么最近，在对JavaScript中this关键字的细节整理中，查阅MDN的中文文档，有些语句翻译的不错，但是还是存在部分疏漏。 仔细一番MDN的一些中文文档，少数文档的部分语句有明显的语义和内容上的毛病。 索性去看英文文档，豁然开朗，遂决定更新中文翻译文档。 在9月4日翻译了MDN上JavaScript的this关键字的英文文档：原版英文文档。 保留了部分原有翻译，纠正了大部分语义措辞漏洞，并更新了关于箭头函数的this指向。 部分语句参考了谷歌翻译，我承认谷歌翻译真的很NB。 有什么总结 要彻底弄懂this的机制，首先你要准备好面向对象的基础，理解OOP的重要概念： JavaScript面向对象编程 然后记住，this是一个变量，它是一个指针，指向一个对象。再看我的文档: this关键字 在过程中看不懂时，及时查阅相关API的文档: 箭头函数 Function.prototype.call() Function.prototype.apply() Function.prototype.bind() 写在结尾在英文文档末尾的参考链接，有一篇写得非常精彩的博客：Gentle-explanation-of-this-in-JavaScript, 温和解释JS中的this 计划在不久将来，我会挤出时间认真翻译这篇英文博客。 The end.]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-12-03 日记：村上春树的文摘]]></title>
    <url>%2F2017%2F07%2F22%2F2017-12-03%20%E9%9A%8F%E7%AC%94-%E4%BA%BA%E7%94%9F%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E5%A4%9A%E2%80%9C%E5%A4%AA%E6%99%9A%E2%80%9D%2F</url>
    <content type="text"><![CDATA[2017-12-03 日记村上春树，从29岁开始写作，从33岁开始坚持跑步。 人生哪有那么多太晚，都是懒惰和恐惧的借口罢了。 一些人不努力便得不到的东西，有些人却勿需努力便唾手可得。 在学校里，我们学到的最重要的东西，就是“最重要的东西在学校里学不到”这个真理。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React项目中的高频ES6语法]]></title>
    <url>%2F2017%2F07%2F08%2F2017-07-08%20%E7%AC%94%E8%AE%B0-React%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%AB%98%E9%A2%91ES6%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在学习React过程中，注意到无论是GitHub上的Demo还是React相关文档，ES6语法都有大量使用。如果不了解其中一些语法，学习曲线就会越来越陡峭。但是要系统学习ES6，又会消耗大量时间。 在这篇博客里，我把一些常用的ES6语法做一些总结，以更快更好地理解React中的概念和用法。 在线练习ES6的工具：ES6 fiddle 1. let &amp; constES6的两个新关键字，主要是引入了块级作用域，不存在变量提升，不允许重复定义等特性，减少了ES5中很容易踩到的地雷。const用来定义常量，不允许后期修改赋值。参考文档：阮一峰的博客 2.解构赋值 常规用法： 12let &#123;x&#125; = &#123;x:1, y:2&#125;let &#123; PropTypes &#125; = React 这里是对象的解构赋值，等同于let PropTypes = React.PropTypes 这里其实包含了两步： 声明变量PropTypes; 给其赋值为React.PropTypes。 所以等效于这样的写法： 12let PropTypes&#123; PropTypes &#125; = React; 可以同时写多个变量： 1let &#123; PropTypes, Component &#125; = React; 如果想定义的变量名和属性名不一样： 123//声明x1变量，赋值为1. //x是模式，不是变量也不会被赋值let &#123; x : x1 &#125; = &#123; x:1, y:2 &#125; 对象， 数组， 字符串等都有解构赋值的用法。 参考文档：解构赋值 3.对象的拓展3.1 属性的简洁表达式let x = &apos;123&apos;; //等同于：let obj = { x: x, y: &apos;33} let obj = {x, y: &apos;33&apos; }; 3.2 方法名的简写12345let User = &#123; method ()&#123; //等同于method: function()&#123;...&#125; //... &#125;&#125; 3.3属性名表达式12345 let key = 'id'; let obj = &#123; [key] : '1010', //注意方括号 ['use' + 'name' ]: 'x'&#125; 把表达式写在 [] 中， 表达式的值作为字段名称： 1234 let obj = &#123; id : '1010', usename: 'x'&#125; 注意：属性名表达式与属性名简写不能同时使用： 12345 let key = 'id'; let id = '1010'; let obj =&#123; [key]&#125; //Error! 4. ES6 Class语法使用ES6语法定义一个React组件： 123456789101112131415161718192021export class Counter extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;count: props.initialCount&#125;; this.tick = this.tick.bind(this); &#125; tick()&#123; this.setState(&#123;count: this.state.count + 1&#125;); &#125; render()&#123; return ( &lt;div onClick = &#123;this.tick&#125; &lt;/div&gt; ); &#125;&#125;Counter.propTypes = &#123; initialCount : Reart.PropTypes.number &#125;;Counter.defaultProps = &#123; initialCount: 0 &#125;; 注意： ES6的继承语法： extends关键字； 各个方法使用了方法简写，如tick(){}和render(){}, 方法之间不加 “,”； constructor 是构造函数， 可以替代getInitialState ； 构造函数内需要调用父类的构造函数：super(props) , 否则就会报错。因为子类没有自身的this 对象，需要从父类继承。 this.tick = this.tick.bind(this)中， 使用bind来绑定执行作用域（使用React.createClass是自动绑定的), 也可以在render中监听事件的位置，使用bind(this): 12345678910 &lt;div onClick= &#123;this.tick.bind(this)&#125;&gt; Clicks: &#123;this.state.count&#125; &lt;/div&gt; ``` **官方建议统一写在constructor中，这样子该方法就只需绑定一次。**6. 除了使用bind, 还可以使用箭头函数：``` jsx &lt;div onClick = &#123;() =&gt; this.tick()&#125;&gt; Clicks: &#123;this.state.count&#125; &lt;/div&gt; 箭头函数的特性：函数体内的this就是定义是的对象， 而非调用时所在的对象。箭头函数的this指向是固定的， 而普通函数是可变的。 5. 箭头函数 ES6允许使用 =&gt; 来定义函数： 12345let f = v =&gt; v+2//等同于let f = function(v)&#123; return v + 2;&#125; 如果有多个参数： 1234567891011 let f = (x ,y) =&gt; x + y;``` - 函数有多条语句， 用大括号包装：``` js let f = (x,y) =&gt; &#123; x = x + 11; y = y + 33; return x + y; &#125; 箭头函数的this指向能保持不变， 不是因为内部有绑定机制， 而是因为，箭头函数没有自己的this， 导致代码内的this就是外层代码块的this。 参考文档： 箭头函数 6. export &amp; import export用于输出模块对外的接口， import用于导入其他模块提供的功能。 12345export let client = "App" //输出变量export function mul(x, y)&#123; //输出函数 return x + y;&#125;export class Toast()&#123;&#125; //输出类 也可以统一输出： 123456//文件名： Util.jslet client = 'App';function mul (x , y)&#123; return x + y;&#125;export &#123; client, mul &#125; 那么别的组件就要这样导入它： 1import &#123;client, mul&#125; from './Util.js' 还可以打包导入： 12import * as U from './Util.js'U.client //使用U 常用的 export default 命令， 用于输出默认的方法， 变量或类： 123export default React.createClass(&#123; //...&#125;) 引入的时候就更方便， 可以随意指定名称： 1import Tab from 'tab'; 参考文档：export&amp;import 7. 对象的拓展运算符: “…”拓展运算符在Redux的示例Demo中很常见。 拓展运算符可以用来合并两个对象： 123//state = &#123; name: 'y' &#125;return &#123;...state, name: 'x', id: 101 &#125;//返回 &#123; name: 'x', id: 101 &#125; 上面代码有两个过程:1.去除state对象的所有可比案例属性， 拷贝到当前对象上； 2.如果自定义的属性在后面， 拓展运算符的同名属性会被覆盖。 这种用法等同于 Object.assign: 1234567891011121314 //assign字面意思为分配 Object.assign(&#123;&#125;, state, &#123;name: 'x', id:101&#125;)``` - 使用拓展运算符需要安装`transform-object-rest-spread`插件， 然后在babel中配置。 配置如下：``` jstest: /\.js$/,exclude: /node_modules/,loader: 'babel',query:&#123; presets: ['react', 'es2015'], plugins: ["transform-object-rest-spread"]&#125; 参考文档：ES6拓展运算符 The End.]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac安装Sass万能方法]]></title>
    <url>%2F2017%2F06%2F07%2F2017-06-07%20%E6%8A%80%E6%9C%AF-Mac%E5%AE%89%E8%A3%85Sass%E4%B8%87%E8%83%BD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Mac OSX系统下使用RVM修复安装Sass的错误这个万金油方法能解决大多数的gem安装问题。 如果你使用通用的gem install sass 出现错误： 12ERROR: While executing gem ... (Errno::EACCES) Permission denied - /var/lib/gems 那么这篇文章也许能解决你的问题。 这个错误说明Ruby的权限有问题，要解决这个权限问题很麻烦，不过有一个方法可以跳过这个坑： 使用RVM(Ruby Version Manager)安装一个特定版本的Ruby，再安装sass。 以下步骤都在Terminal(终端)中完成! 1. 安装Homebrew/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2. 安装gpg安装RVM之前需要gpg，先别管它是什么。 它是 mpapis public key 公钥用于验证安装包以确保安全。 如果你想知道它到底是什么，点击这里GNU-wiki百科。 brew install gnupg 3. 安装gpg密钥gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB 4. 安装RVM\curl -sSL https://get.rvm.io | bash -s stable --ruby 5. 开始使用RVM1. 查看已有Ruby版本:1rvm list 如果出现警告，如：“Warning! PATH is not properly set up…” ，这是未添加RVM环境变量，请参考解决方案.或者你直接Copy下面的指令： 1[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot; 2. 检查Ruby版本列表：不必输入下面的代码，这是输入rvm list后的结果！1234567rvm rubies=* ruby-2.2.0 [ x86_64 ]# =&gt; - current# =* - current &amp;&amp; default# * - default 3. 安装特定版本Ruby：rvm use ruby --default 检查ruby位置： which ruby 如果显示了一行目录，则表示安装成功。 ruby -v 6. 安装sassgem install sass 7. 安装完成！ 参考文章：Ruby on Mac OSX with RVM]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>指南 笔记 Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述网络原理和优化]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06%20%E5%89%8D%E7%AB%AF-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？ 1.1 浏览器处理请求浏览器开启一个线程处理这个请求，对URL分析判断，如果是HTTP协议，就按Web方式处理。 1.2 浏览器处理URL调用浏览器内核中的对应方法，比如WebView中的loadUrl方法。 1.3 DNS解析通过DNS解析，获取域名的IP地址，设置UA等信息发出第二个GET请求。 1.4 建立连接进行HTTP协议回话，客户端发送报头（请求报头）； 1.5 服务器系统响应进入到Web服务器上的Web Server， 如Apache 、Tomcat 、 Node.JS 等服务器。 1.6 服务器程序处理进入部署好的后端应用，如PHP、Java、JavaScript、Python等，找到相应的请求处理。 1.7 服务器处理完成，返回数据处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，如果一致，则返回304. 1.8 浏览器开始下载HTML浏览器开始下载HTML文档(响应报头，状态码200)，同时使用缓存。 1.9 DOM树建立，加载外部文件文档树开始建立，根据标记请求所需指定MIME类型的文件（比如CSS，JS），同时设置Cookie。 1.10 页面渲染页面开始渲染DOM，JS根据DOM API操作DOM，执行事件绑定等，页面显示完成。 2. HTTP状态码 100 继续， 一般在发送post请求时， 已发送了http header之后，服务器将返回此信息，表示确认。 200 正常返回信息 201 请求成功并且服务器创建了新的资源 202 服务器已接受请求，但尚未处理 301 永久重定向 302 临时重定向 303 临时重定向，且总是使用GET请求新的URI 304 资源未修改，自从上次请求后，请求的网页未修改过。 400 请求格式错误，客户端不应当再犯同样的错误 401 请求未授权 403 禁止访问 404 找不到资源 500 服务器内部错误 502 网关错误 503 服务器暂时无法处理请求，可能是过载或者维护 3. 前端性能优化3.1 减少http请求次数CSS雪碧图，JS、CSS代码压缩，图片压缩； 网页Gzip，CDN托管，data缓存，分离图片服务器。 3.2 前端模板优化精简HTML标签，避免带宽浪费。 用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。 3.3 DOM操作用innerHTML代替DOM操作，减少DOM操作次数，优化JavaScript性能。 缓存DOM节点查找的结果，减少IO读取操作。 3.4 避免直接操作style当需要设置的样式很多时，设置className，而非直接操作style。 3.5 少用全局变量不要给windows添加变量了，他已经很胖了！ The End.]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何应对CSRF攻击]]></title>
    <url>%2F2017%2F05%2F23%2F2017-05-23%20%E6%8A%80%E6%9C%AF-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6CSRF%2F</url>
    <content type="text"><![CDATA[摘要：作为Web安全数一数二的隐患，CSRF一直让开发人员头疼。本文详细介绍了CSRF攻击的概念，危害，案例和解决方案，为网站安全优化理清思路。 CSRF攻击的应对之道一、CSRF的来龙去脉1. 什么是CSRF？CSRF（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。 2. CSRF攻击实例CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。 比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。 通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。 Mallory 可以自己发送一个请求给银行： http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory 但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。 src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ” 并且通过广告等诱使 Bob 来访问他的网站。 当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。 大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。 但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。 这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。 等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 3. CSRF攻击的对象在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。 从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。 因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。 所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。 比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。 二、防御 CSRF 的几种策略在业界目前防御 CSRF 攻击主要有三种策略： 验证 HTTP Referer 字段； 在请求地址中添加 token 并验证； 在 HTTP 头中自定义属性并验证。 1. 验证 HTTP Referer 字段1.1 什么是Referer？根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。 在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory 用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。 这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。 而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。 1.2 如何验证Referer？因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 1.3 Referer验证的优缺点优点：这种方法简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。 缺点： Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。 使用验证值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行CSRF 攻击。 如果用户为了保护隐私，而设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 2. 在请求地址中添加 token 并验证2.1 黑客总是能找到漏洞CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。 2.2 那我们就加一把钥匙要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。 但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把 token 以参数的形式加入请求了。 2.3 使用token的缺点：①. 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。 ②. 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。 为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。 3. 在 HTTP 头中自定义属性并验证3.1 把密钥放到HTTP请求头中这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。 通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。 这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 3.2 缺点：然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。 三、代码实例(java)：1. 使用Filter验证Referer12345678//从HTTP头部取得Referer值 String referer = request.getHeader("Referer"); //判断Referer是否以bank.example开头 if((refirer != null) &amp;&amp; (referer.trim().startsWith("bank.example")))&#123; vhain.doFilter(request, response); &#125;else&#123;request.getRequestDispatcher("error.jsp").forward(request,response);&#125; 以上代码先取得Referer值，然后进行判断，当其非空并以bank.example开头时，则继续请求，否则的话可能是CSRF攻击，转到error.jsp页面。 2.进一步验证请求中的token1234567891011121314151617181920HttpServletRequest req = (HttpServletRequest)request;HttpSession s = req.getSession();//从session中，得到csrftoken属性String sToken = (String)s.getAttribute("csrftoken");if(sToken == null)&#123; //产生新的token放入session中 sToken = generateToken(); s.setAttribute("csrftoken", sToken); chain.doFilter(request, response);&#125;else&#123; //从HTTP头中取得csrftoken String xhrToken = req.getHeader("csrftoken"); //从请求参数中取得csrftoken String pToken = req.getParameter("csrftoken"); if(sToken != null &amp;&amp; xhrToken != null &amp;&amp; sToken.equals(xhrToken))&#123; chain.doFilter(request, response); &#125;else&#123; request.getRequestDispatcher("error.jsp").forward(request,response); &#125;&#125; 3.在客户端对请求附加token1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function appendTOken()&#123; updateForms(); updateTags();&#125;function updateForms()&#123; //获取所有form元素 var forms = document.getElementsByTagName('form'); for (i = 0; i &lt; forms.length; i++)&#123; var url = forms[i].action; //如果这个form的action值为空，则不附加csrftoken if(url == null || url == "") continue; //动态生成input元素，加到 form 之后 var e = docement.createElement("input"); e.name = "csrftoken"; e.value = token; e.type = "hidden"; forms[i].appendChild(e); &#125;&#125;function updateTags()&#123; var all = document.getElementsByTagName('a'); var len = all.length; //遍历所有a元素 for(var i = 0; i&lt; len; i++)&#123; var e = all[i]; updateTag(e, "href" , token); &#125;&#125;function updateTag(element, attr, token)&#123; var location = element.getAttribute(attr); if(location != null &amp;&amp; location != '' '')&#123; var fragmentIndex = location.indexOf("#"); var fragment = null; if(fragmentIndex != -1)&#123; //url中含有#锚标记 fragment = location.substring(fragmentIndex); location = location.substring(0, fragmentIndex); &#125; var index = location.indexOf('?'); if(index !== -1)&#123; //url中已含有其他参数 location = location + '&amp;csrftoken=' + token; &#125;else&#123; //url中没有其他参数 location = location + '?csrftoken=' + token; &#125; if(fragment != null)&#123; location += fragment; &#125; element.setAttribute(attr, location); &#125;&#125; 在客户端html中，主要有两个地方需要加上token，一个是表单form，另一个就是a标签。上面这段代码，首先遍历所有的form, 在form最后添加一段隐藏字段，把csrftoken放入其中。然后，代码遍历所有的a标签，在其href属性中加入csrftoken参数。 注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。 4. 在 HTTP 头中自定义属性var plainXhr = dojo.xhr; // 重写 dojo.xhr 方法 dojo.xhr = function(method,args,hasBody) { // 确保 header 对象存在 args.headers = args.header || {}; tokenValue = &apos;&lt;%=request.getSession(false).getAttribute(&quot;csrftoken&quot;)%&gt;&apos;; var token = dojo.getObject(&quot;tokenValue&quot;); // 把 csrftoken 属性放到头中 args.headers[&quot;csrftoken&quot;] = (token) ? token : &quot; &quot;; return plainXhr(method,args,hasBody); }; 这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。 四、如何选择CSRF防御方法？目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。 如果网站是一个现有系统，想要在最短时间内获得一定程度的 CSRF 的保护，那么验证 Referer 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。 如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。在这种情况下，你需要小心规划你网站提供的各种服务，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。 如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议对于重要的服务，可以尽量使用 XMLHttpRequest 来访问，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。 最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。 五、总结可见，CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF 的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token 方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视 CSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低。 引用：IBM的技术博客]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>技术</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 观察者模式的通用实现]]></title>
    <url>%2F2017%2F05%2F07%2F2017-05-07%20%E5%89%8D%E7%AB%AF-JavaScript%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[这篇文章主要是列举代码，关于一个经典的设计模式——观察者模式，又名发布-订阅模式的通用实现。 12345678910111213141516171819202122232425262728293031323334353637//封装观察者模式，放进一个对象中，可复用。var event = &#123; clientList:[], //订阅的消息添加进缓存列表 listen: function(key, fn)&#123; if( !this.clientList[key])&#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); &#125;, trigger: function()&#123; var key = Array.prototype.shift.call(arguments), fns = this.clientList[key]; if(!fns || fns.length === 0)&#123; return false; &#125; for(var i = 0, fn; fn = fns[i++];)&#123; fn.apply(this, arguments); &#125; &#125;， remove: function(key, fn)&#123; var fns = ClientList[key]; if( !fns )&#123; return false; &#125; if(!fn)&#123; fns &amp;&amp; fns.length = 0; &#125;else&#123; for(var len = fns.length-1; len&gt;=0; len--)&#123; var _fn = fns[len&#125;; if(_fn === fn)&#123; fns.splice(len, 1); &#125; &#125; &#125; &#125;&#125; 123456//所有对象都能动态安装 ‘观察者模式’var installEvent = function(obj)&#123; for (var i in event)&#123; obj[i] = event[i]; &#125;&#125;; 12345678910111213//测试var salesOffices = &#123;&#125;;installEvent(salesOffices); //订阅salesOffices.listen(&apos;squareMeter88&apos;, function(price)&#123; console.log(&apos;88平方米的价格=&apos;+price);&#125;);salesOffices.listen(&apos;squareMeter110&apos;,function(price)&#123; console.log(&apos;110平方米的价格=&apos;+price);&#125;); //发布salesOffices.trigger(&apos;squareMeter88&apos;,2000000); //输出：&quot;88平方米的价格=2000000&quot;salesOffices.trigger(&apos;squareMeter110&apos;,3000000); //输出：&quot;110平方米的价格=3000000&quot;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript对象数组排序]]></title>
    <url>%2F2017%2F05%2F07%2F2017-05-07%20%E7%AE%97%E6%B3%95-JavaScript%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[对象数组排序 一、按照对象的属性排序我要一个函数，传入要对比的key，就能以这个key，把对象数组进行排序。123456789101112131415161718192021222324252627282930313233//示例代码var by = function(key) &#123; return function(o, p) &#123; var a, b; if (typeof o === 'object' &amp;&amp; typeof p === 'object' &amp;&amp; o &amp;&amp; p) &#123; a = o[key]; b = p[key]; if (a === b) &#123; return 0; &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; //如果a,b所属类型不同，则按类型的英文字符排序，比如'function'排在'object'前面。 return typeof a &lt; typeof b ? -1 : 1; &#125; else &#123; throw('error'); &#125; &#125;&#125;var employees=[]employees[0]=&#123;name:"George", age:32, retiredate:"March 12, 2014"&#125;employees[1]=&#123;name:"Edward", age:17, retiredate:"June 2, 2023"&#125;employees[2]=&#123;name:"Christine", age:58, retiredate:"December 20, 2036"&#125;employees[3]=&#123;name:"Sarah", age:62, retiredate:"April 30, 2020"&#125;employees.sort(by('age'));//得到根据age属性排序的数组。//[&#123;name:"Edward", age:17, retiredate:"June 2, 2023"&#125;,//&#123;name:"George", age:32, retiredate:"March 12, 2014"&#125;,//&#123;name:"Christine", age:58, retiredate:"December 20, 2036"&#125;,//&#123;name:"Sarah", age:62, retiredate:"April 30, 2020"&#125;] 二、高级by()函数当主要的键值产生一个匹配的时候，另一个compare方法（第二个参数）将被调用以决出高下。举个例子，在比较两个对象的age属性时，age的值相等，现在我想要age相等的人，按照别的属性进行排序。于是我想增强by() ，现在我这样使用： 12//注意外层by函数内有俩个参数，第二个参数就是备用的比较函数。employees.sort(by(&apos;age&apos;,by(&apos;name&apos;))); 12345678910111213141516171819var by = function(name,minor)&#123; return function(o,p)&#123; var a,b; if(o &amp;&amp; p &amp;&amp; typeof o === &apos;object&apos; &amp;&amp; typeof p ===&apos;object&apos;)&#123; a = o[name]; b = p[name]; if(a === b)&#123; //如果前后元素相同时，用minor函数比较。 return typeof minor === &apos;function&apos; ? minor(o,p):0; &#125; if(typeof a === typeof b)&#123; return a &lt;b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1; &#125;else&#123; throw(&quot;error&quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript精髓(2)]]></title>
    <url>%2F2017%2F03%2F07%2F2017-03-07%20%E5%89%8D%E7%AB%AF-JavaScript%E7%B2%BE%E9%AB%93(2)%2F</url>
    <content type="text"><![CDATA[这篇博客延续上一篇JavaScript精髓(1)，继续总结JavaScript语言的核心特性和思想精髓。 1. JavaScript继承的实现方式 构造继承 原型继承 实例继承 拷贝继承 原型prototype机制或者apply/call方法较简单，建议使用构造函数与原型混合方式。 1234567891011function Parent()&#123; this.name = 'wang';&#125;function Child()&#123; this.age = 28;&#125;Child.prototype = new Parent(); //通过prototype，继承Parent var demo = new Child();alert(demo.age);alert(demo.name); //得到继承的属性 2. DOM操作——添加、移除、移动、复制、创建和查找节点 创建新节点 createDocumentFragment() createElement() createTextNode() 添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() 查找 getElementsByTagName() getElementsByName() getElementById() 3. Ajax的概念和用法 AJAX的全称： Asynchronous JavaScript And XML. 异步的概念：向服务器发送请求时，不必等待结果，而可以同时做其他事情。 Ajax用法： 创建XMLHttpRequest对象，也就是创建一个异步调用对象， 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL和验证信息， 设置响应HTTP请求状态变化的函数， 发送HTTP请求， 获取异步调用返回的数据， 使用JavaScript和DOM实现局部刷新 。 4. document.write 和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以只重绘页面的一部分 5. window对象和document对象 window对象：指的是浏览器打开的窗口 document对象：Document对象的一个只读引用，它是window对象的一个属性。 6. 通用的事件侦听器函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//event工具集，参考来源：github.com/markyunmarkyun.Event = &#123; readyEvent : function(fn)&#123; if(fn==null)&#123; fn = document; &#125; var oldonload = window.onload; if(typeof window.onload != 'function')&#123; window.onload = fn; &#125;else&#123; window.onload = function()&#123; oldonolad(): fn(); &#125; &#125; &#125;, //根据能力分别使用DOM 0级 || DOM 2级 || IE方式，来绑定事件 //参数：操作元素，事件名称，事件处理函数 addEvent: function(element, type, handler)&#123; if(element.addEventListener)&#123; //事件类型，需要执行的函数，是否捕捉 element.addEventListener(type, handler, false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on' + type, function()&#123; handler.call(element); &#125;); &#125;else&#123; element['on' + type ] = handler; &#125; &#125;, //移除事件 removeEvent: function(element,type,handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125;else if(element.detachEvent)&#123; element.detachEvent('on' + type, handler); &#125;else &#123; element['on' + type] = null; &#125; &#125;, //End removeEvent //阻止事件(主要是事件冒泡， 因为IE不支持事件捕获) stopPropagation: function(ev)&#123; if(ev.stopPropagation)&#123; ev.stopPropagation(); &#125;else&#123; ev.cancelBubble = true; &#125; &#125;, //取消事件的默认行为 preventDefault : function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;, //获取事件目标 getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, //获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent: function(e)&#123; var ev = e || window.event; if(!ev)&#123; var c = this.getEvent.caller; while(c)&#123; ev = c.arguments[0]; if(ev &amp;&amp; Event == ev.constructor)&#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125; &#125; //End]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript精髓(1)]]></title>
    <url>%2F2017%2F03%2F06%2F2017-03-06%20%E5%89%8D%E7%AB%AF-JavaScript%E7%B2%BE%E9%AB%93(1)%2F</url>
    <content type="text"><![CDATA[这篇文章主要总结了JavaScript的基础，包括数据类型，值和易混淆的概念。 1. JavaScript的基本数据类型 Undefined Null Number Boolean String Symbol(ES2015新增) 2. JavaScript的内置对象 Object 是JS中所有对象的父对象 数据封装类对象： Object Array Boolean Number String 其他对象： Function Arguments Math Date RegExp Error 参考文档：文档链接 3. JavaScript 中有几种类型的值？ 栈(Stack)：原始(primitive)数据类型(Undefined, Null , Boolean, Number, String) 堆(Heap)：合成(complex)数据类型(Object, Array, Function) 两种类型的区别是： 存储位置不同 原始数据类型：直接存储在栈中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据，所以放入栈中存储； 引用数据类型：存储在堆(Heap)中的对象，占据空间大，大小不固定。如果存储在栈中，则会影响程序的性能。 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后，从堆中获得实体。 内存图： 4. null和undefined的区别 null 表示”没有对象”，即该处不应该有值，典型用法： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 12Object.getPrototypeOf(Object.prototype)//null undefined 表示“缺少值”，即此处应该有值，但是没有被赋值，典型用法： 变量被声明了，但是没有赋值，默认等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性默认值为undefined。 函数没有返回值时，默认返回undefined。1234567891011var i;i //undefinedfunction f(x)&#123;console.log(x)&#125;f() //undefinedvar o = new Object();o.p //undefinedvar x = f();x //undefinde 123456//二者的测试typeof undefined == "undefined" //truetypeof null == "object" //trueNumber(undefined) //NaNNumber(null) //0 注意： 在验证null时，一定要使用 ===,因为 == 无法分辨null和undefined： 12null == undefined //truenull === undefined //false 打个比方： null Q: 有张三这个人吗？ A: 有！ Q: 张三有房子吗？ A: 没有！ undefined Q: 有张三这个人吗？ A: 有！ Q: 张三多少岁了？ A: 不知道（没有被告诉） 5. JavaScript的this this是一个指针 this的指向： 函数直接调用时：this指向函数的直接调用者； 通过new关键字，this指向new产生的新对象； 通过call/apply/bind的绑定，this指向绑定对象。 在JS事件中，this指向触发这个事件的对象，但是在IE中，attachEvent中的this总是指向全局对象Window。 6.JavaScript的作用域链全局函数无法查看局部函数的内部细节，但局部函数刻意查看上层函数的细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。 7. JavaScript原型和原型链 原型：每个对象都会在其内部初始化一个属性，就是prototype(原型)。换句话说，所有对象都是以对象为模板创建实例的。 原型链：当我们访问一个对象的属性A时，如果属性A不存在于该对象中，那么我们会去prototype里查找A，而这个prototype又会有自己的prototype，于是就如此查找下去，就形成了一个原型链。这个原型链表示的是一种连带关系。 关系：instance.constructor.prototype = instance.__proto__ 特点：JS对象是通过引用传递的（对比于值传递），我们创建的每一个新对象实体中，并没有一份属于自己的原型副本。当我们修改了原型，与之相关的对象也会继承这些变化。 终点：原型链的顶端，是Object.prototype, 它的__proto__指向null. 8.JavaScript的闭包 概念闭包是一种手段，一个有权访问另一个函数作用域中变量的函数，记住闭包也是函数。 创建闭包最常见的方式，就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量(相当于一个对外的接口)。 作用利用闭包可以突破作用域链，将函数内部的变量方法传递到外部。 特性 1. 函数内再嵌套函数 2. 内部函数可以引用外层的参数和变量 3. 参数和变量不会被垃圾回收机制回收 9. new操作符到底干了什么？ 创建一个空对象，将this指针指向该对象，同时继承该函数的原型。 属性和方法被添加到this指向的对象中。 新创建的对象由this所应用，并且最后隐式的返回this 。 123var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); 10. JavaScript开发的基本规范 不要在同一行声明多个变量； 请使用 ===/!==来比较布尔值或者数值； 使用对象字面量替代 new Array这种形式； 不要使用全局函数； Switch语句必须带有default分支； 函数应该有返回值； For循环必须使用大括号； if语句必须使用大括号； for-in循环中的变量应该使用let 关键字明确限定作用域，避免命名空间污染。 To be continue。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记：JavaScript事件处理]]></title>
    <url>%2F2017%2F01%2F27%2F2017-01-27%20%E5%89%8D%E7%AB%AF-JavaScript%20Events%20%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JavaScript — 事件处理： 笔记摘要 参考书籍：《Modern JavaScript》(Larry Ullman 著);《JavaScript高级程序设计》 (Nicholas C Zakas著). 一、 事件处理：1.嵌入式事件处理器（强烈不建议）:1234/*比如*/ &lt;form action= &quot;#&quot; method = &quot;post&quot; onsubmit = &quot;validataForm();&quot;&gt; /*或者*/ &lt;a href = &quot;somepage.html&quot; onclick = &quot;doSomething();&quot;&gt;Some link&lt;/a&gt; 2.传统事件处理方法(不建议)：123456/* 以下传统方法不建议使用 */window.onload = init; //易用，可靠，属性名必须全小写。/* 或者 */window.onload = function()&#123; //匿名函数方法//Do whatever.&#125; 原因： 1. 一次只能指定一个时间处理器； 2. 较后的函数会覆盖较前的； 12document.getElementById('theForm').onsubmit = progress;document.getElementById('theForm').onsubmit = calculate; // 呃!有问题. 12345//缓解方法document.getElementById('theForm').onsubmit = function()&#123; progress(); //当然你也可以这样解决，但是这样的代码很丑陋。 calculate();&#125; 3.W3C事件处理(建议) 接受三个参数：事件类型，事件发生时调用的函数，表示事件阶段的布尔值。123456789101112131415161718 addEventListener(&apos;load&apos;, init , false); //可以为相同元素添加多个事件监听器；` removeEventListener()(&apos;load&apos;, process , false);``` 2. IE&lt;9的事件处理(事件名称前缀多了&quot;on&quot;) 1. attachEvent(&apos;onload&apos; , init); 2. detachEvent(&apos;onload&apos; , init);3. 创建一个事件分配器 ``` javascript function addEvent( obj , type , fn)&#123; if(obj &amp;&amp; objEventListener)&#123; //W3c obj.addEventListener(type, fn , false); &#125;else if(obj &amp;&amp; obj.attachEvent)&#123; //IE&lt;9 obj.attachEvent(&quot;on&quot; + type, fn); &#125; &#125; 4. 范例：创建一个实用程序库12345678910111213141516171819202122232425262728293031323334353637383940414243444546//所有函数都定义在全局对象U中，避免多个新函数污染全局命名空间。//新对象U （Utility的缩写）var U = &#123; //定义$()方法 $: function(id)&#123; 'use strict'; if (typeof id == 'string')&#123; return document.getElementById(id); &#125; &#125;,//定义setText 方法，两个参数：要更新的元素id和消息本身 setText: function(id, message)&#123; 'use strict'; if( (typeof id == 'string') &amp;&amp; (typeof message == 'string'))&#123; var output = this.$(id); if (!output) &#123;return false&#125;; //获取id的元素失败 if(output.textContext !== undefined)&#123; output.textContext = message; &#125;else&#123; output.innerText = message; &#125; return true; &#125; //End of main IF. &#125;, //End of setText() function. //封装一个‘添加事件监听器’ 函数 addEvent: function( obj , type , fn)&#123; 'use strict'; if(obj &amp;&amp; obj.removeEventListener)&#123; obj.addEventListener(type, fn, false); &#125;else if (obj &amp;&amp; obj.detachEvent)&#123; obj.attachEvent('on' + type , fn); &#125; &#125;, //End of addEvent() function //封装一个‘移除事件监听器’函数 removeEvent: function( obj , type , fn)&#123; 'use strict'; if(obj &amp;&amp; obj.removeEventListener)&#123; obj.removeEventListener(type, fn, false); &#125;else if (obj &amp;&amp; obj.detachEvent)&#123; obj.detachEvent('on' + type , fn); &#125; &#125; //End of removeEvent() function &#125;; //End of U declaration. 二、事件类型事件类型分为4类： 输入设备 键盘 浏览器 表单 1.输入设备事件1. 输入按钮事件：1. click 事件； 2. dblclick 事件； 3. contextmenu 事件(罕见)； 2. 输入移动事件：1. mouseout 鼠标移出; 2. mouseover 鼠标移过; 3. mousemove 鼠标移动（持续监视鼠标，消耗性能）; 3. 键盘事件：1. keydown (按下); 2. keyup (释放); 3. keypress (按键，前二者组合); 4. 浏览器事件：1. load (加载完成); 2. unload (卸载); 3. resize (改变浏览器窗口大小); 4. scroll (滚动事件); 5. copy; 6. cut; 7. paste; 5. 表单事件： – reset：表单重置(点击重置html按钮)时触发，用户很少有重置表单的需要；若要使用此事件，可以添加监视： 123addEvent(document.getElementById(&apos;theForm&apos;), &apos;reset&apos; , function()&#123; return confirm(&quot;您确定想要重置表单吗？&quot;); &#125;); – select: 文本输入域和文本区域的文本内容被选中时； – change: 元素值变化时； – focus: 单击或Tab键到文本输入域时； – blur: 光标或选择项的移动时； 三、事件可访问性(Accessibility)1. 配对事件(Pairing events): 使用同一个函数处理相同元素的类似事件。 2. 可访问性(Accessibility):在移动设备和其他非标准浏览器上，对于不使用输入设备的浏览器，mouseover和mouseout事件毫无意义，因为它们永远不会发生。例如：1234&lt;a href = &quot;somepage.html&quot; id = &quot;link&quot; &gt; Some Text &lt;/a&gt;&lt;script&gt;addEvent(document.getElementById(&apos;link&apos;), &apos;mouseover&apos;,handleLinkMouseOver);&lt;/script&gt; 上述代码中，事件只能通过鼠标触发。但是还是有缓解方法。如果浏览器仅由键盘控制，那么它是可以监视focus事件的(Tab键)。因此，增强可访问性的事件处理方法是创建两个事件监听器：123456&lt;a href = &quot;somepage.html&quot; id = &quot;link&quot;&gt;some Text&lt;/a&gt;&lt;script&gt;//配对事件addEvent(document.getElementById(&apos;link&apos;), &apos;mouseover&apos;, doSomething);addEvent(document.getElementById(&apos;link&apos;), &apos;focus&apos;, doSomething);&lt;/script&gt; 3.事件和渐进增强 渐进增强的真正原则： 使用JavaScript( 和CSS )改进基本功能，使得用户不管使用何种设备，都不会被抛弃(忽略)。 只有在开发者有意识的忽略一些用户时，JavaScript才是有必要的。 但是在很多情况下，JavaScript是没有必要的：比如表单的提交应该在有无JavaScript的情况下都能进行(在服务端都能验证)。 将渐进增强的思想应用到事件处理中，向已经有默认事件行为的元素添加事件时必须小心。例如：表单提交时，表单的数据发送给服务器端脚本。为表单添加提交事件，为其添加其他功能，在逻辑上是毫无意义的。 四、高级事件处理 引用事件 事件属性 检查按键 阻止默认事件行为 事件的两个阶段：捕捉和冒泡 委派事件处理 1.引用事件 当事件处理程序用于多个元素上的相同事件（或者相同元素上的不同事件）时，事件处理程序就必须考虑其灵活性。 12345function someEventHandler(e)&#123; //e就是引用事件，代表发生的事件 if(typeof e == "undefined")&#123; e = window.event; //考虑IE8及更早 &#125;&#125;; 2.事件属性 事件对象通过各种属性提供信息，但是不同浏览器支持的属性有所差异。(这里不深究，后续补充。) 3.检查按键 当键盘事件触发时，可以通过事件对象确定按下的具体键。这个问题有点复杂，在这里稍微带过。 示例代码：以一致的方式获得字符： 123456var charCode = e.which || e.keyCode; //IE中不支持which// 或者更准确的var charCode = (typeof e.which == &apos;number&apos;)?e.which : e.keyCode;//获得与字符代码相对应的实际字符:String.fromCharCode(charcode); 4.阻止事件默认行为 一些与基本浏览器相关的JS事件： 单击链接、提交表单等。在事件处理器存在时，事件发生会调用对应的函数，在函数运行之后，浏览器仍然继续进行它通常应该进行的事件处理。例如：提交表单时，提交事件处理器可能执行客户端验证。如果发生了错误，应该阻止表单提交到服务器端脚本，让客户有机会改正错误。方法：从事件处理器中返回false。 123456789101112131415161718// 仅在传统方法注册事件处理器时可靠工作，不建议。function handleForm()&#123; //Do whatever. if(errors)&#123; return false; &#125;else&#123; return true; &#125;&#125;//以下是跨浏览器的兼容方法，调用事件对象的preventDefault();if(typeof e == &apos;undefined&apos;) &#123;e = window.event;&#125;if(e.preventDefault)&#123; e.preventDefault();&#125;else &#123; e.returnValue = false;&#125;return false; //额外的预防措施。 使用PreventDefault()或设置returnValue的另一个好处就是：可以在函数开始时执行，使后续的函数代码仍然运行。 5.事件的两个阶段：捕捉和冒泡示例：12345678910&lt;div&gt; &lt;h1&gt;This is a title&lt;/h1&gt; &lt;p&gt;This is a paragraph. &lt;a href = &quot;#&quot; id = &quot;link&quot;&gt;This is a link.&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; // U.$()方法与jquery获取DOM节点方法一致，只是在前文定义了一个新对象U. addEvent(U.$(&apos;link&apos;), &apos;mouseover&apos; , doSomething);&lt;/script&gt; **在上述代码中，包含关系：a&lt; p&lt; div&lt; html&lt; Document&lt; window。当鼠标悬停在链接之上，mouseover事件实际上经历了几个步骤，在两个不同的阶段到达和离开目标（链接）。 注意，事件传播一共有三个阶段：1.捕获阶段； 2.调用事件处理程序； 3.冒泡阶段。 1.捕捉阶段： 当你使用事件捕获时，由外向内，父级元素先触发，子级元素后触发；即div先触发，p后触发。 2.事件处理： 调用查找到的事件处理程序； 3.冒泡阶段： 事件冒泡当你使用事件冒泡时，由内向外，子级元素先触发，父级元素后触发；即p先触发，div后触发。 W3C模型 在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。 程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。 1ele.addEventListener(&apos;click&apos;,doSomething2,true) true=捕获 false=冒泡 传统绑定事件方式 在一个支持W3C DOM的浏览器中，像这样一般的绑定事件方式，是采用的事件冒泡方式。 1ele.onclick = doSomething2 IE浏览器 如上面所说，IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。 1ele.attachEvent(&quot;onclick&quot;, doSomething2); 附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。 事件的传播是可以阻止的：• 在W3C中，使用stopPropagation（）方法• 在IE下设置cancelBubble = true； 在捕获的过程中stopPropagation（）;后，后面的冒泡过程也不会发生了 阻止事件的默认行为 例如click后的跳转:• 在W3C中，使用preventDefault（）方法；• 在IE下设置window.event.returnValue = false; 终于写完了，花了一天时间总结了”事件处理”，文末部分参考了网友的经验。 九月份看的《JS高级程序设计》，当时云里雾里，后来敲了很多代码半懂不懂，现在写完这篇博客才算明白过来。 在写的时候翻阅《JS权威指南》，里面有更深入的细节，有一部分事件类型已经被HTML5标准化。 后续再补充。^_^]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
