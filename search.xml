<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何忽略一个submodule?]]></title>
    <url>%2F2019%2F03%2F05%2F2019-03-05%20%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BD%A0%E7%9A%84Git%E4%BB%93%E5%BA%93%E4%B8%AD%E5%BF%BD%E7%95%A5%E4%B8%80%E4%B8%AAsubmodule%3F%2F</url>
    <content type="text"><![CDATA[痛点在Hexo和Travis结合的过程中，遇到了submodule的问题。HEXO中，我使用了NexT主题，该主题的一些功能，需要依赖一些子组件，也就是直接clone一些repo到主题的目录下。但是Git会默认为我安装de 参考链接 https://stackoverflow.com/questions/1759587/un-submodule-a-git-submodule 123456git rm --cached submodule_path # delete reference to submodule HEAD (no trailing slash)git rm .gitmodules # if you have more than one submodules, # you need to edit this file instead of deleting!rm -rf submodule_path/.git # make sure you have backup!!git add submodule_path # will add files instead of commit referencegit commit -m "remove submodule" Written with StackEdit.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Commit Message规范参考]]></title>
    <url>%2F2019%2F01%2F24%2F2019-01-24%20Git%20Commit%20Message%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[注：在Git协作模式的团队中，Commit Message的规范对版本控制起着很重要的作用。本文引用自团队内部的规范，分享出来，一是为了贡献社区，二是为了加深印象。 Commit Message规范在git开发流程中，每次git commit，都需要对该次commit添加描述信息，描述此次commit的具体改动内容。规范的commit message格式，可以让团队成员对每次改动内容进行快速了解，也可以方便git log时的浏览和筛选。 目前社区使用最广的是 AngularJS 的规范： Google Docs 原文 阮一峰博客对于commit message的介绍 简述一条完整的提交信息(commit message)一般来说包含Header和Body，其中Header是必须的，Body是可选的。 对于大部分可以简单描述清楚的改动，只需要一个Header即可。 而对于一些需要更详细说明、要分条列出的改动，我们在Header进行简述之外，还要在Body中详细描述。 一般而言，Header长度不应超过50个字符，如果超过的话则考虑添加Body进行详述。 我们通常使用的git commit -m &quot;&lt;Commit Message Header&gt;&quot;，就是只添加单行的Header信息。例如： 12# 这里只添加了Headergit commit -m "feat(官网主页): 将iOS的头部背景与Android统一，不再使用默认蓝色图片" 如果需要添加Body详细信息，则使用git commit进入文本编辑器，再进行具体编辑。例如： 1234567# 这里既添加了Header，又添加了Bodychore(构建优化): 解决构建流程几个问题- 每次构建chunkhash会改变的问题- 内联和外链样式重复问题- 图片md5错误问题- 提取项目公共vendor 具体规范从上面的示例可以看到，Header的格式为：&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;。 Header主要由type, scope和subject三部分组成： type用来描述这次提交属于哪一类修改，比如是完成需求还是修复BUG。（必需） scope用来描述这次提交涉及的范围，比如是详情页还是礼包页。对于一些没有明确范围的改动，可以忽略。（可选） subject是这次提交的简单描述，具体做了什么。如果50字符内不能描述清楚，建议添加Body继续描述。（必需） type类别常用： feat - 新增需求、需求迭代、新功能等相关的提交 fix - BUG修复提交 docs - 文档相关的提交 refactor - 技术优化类的代码重构，不影响具体需求和逻辑，也不涉及BUG修复的修改，如：测速优化、性能优化、模块拆分等 chore - 代码维护相关的小改动，如：更新依赖库、构建工具及其配置的改动、代码格式调整等 较不常用： workflow - 开发工作流的改动，比如修改package.json中的scripts，比如增加或修改一些发布脚本 test - 测试相关的修改，比如增加测试用例。 Revert在需要回滚某些改动的时候，使用revert: &lt;reverted commit Header&gt;格式，也就是将回滚的那一条提交的Header作为revert后的内容。 例如，之前进行了某些改动： 1fix(礼包页): 修复了礼包页展示不完全的bug 之后发现这个改动会引起一些其他的bug，不得已需要回滚： 1revert: fix(礼包页): 修复了礼包页展示不完全的bug 注意事项 scope不是必须的，也没有具体的限定，但是有明显范围特征的尽量写上。（比如下面例子中的(详情页)）； 注意描述要清晰，要针对改动本身，让其他成员在没有任何上下文的情况下，也能看懂改动了什么。 不写废话（不过可以偶尔卖个萌😉）； typo修正、代码格式调整之类的，在AngularJS标准里另分到style类别，我们统一放在chore当中。这些很细小的改动，描述可以不用特别详细； 应保证改动和commit一一对应； 一个commit只对应一处改动、一个需求或一个BUG，不要把多个改动集中混在一起提交。在同时修改了多个文件时，不要直接git add .，应该挑选相关的文件进行add和commit，再挑选另一部分文件进行add和commit； 一处改动、一个需求或一个BUG，应尽量集中在同一个commit中，不要开发到中途先提交一次，开发完成再提交一次。 1234567891011# Badfix: bug修复fix: 修复了测试昨天发现的bugfeat: 完成了今天排期的需求# OKchore: 修正了几处拼写错误# Goodfeat: 在新的主页新增了一个关闭按钮fix(详情页): 修复展开活动的sid为string的bug]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>规范</tag>
        <tag>Git</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array.prototype.sort()的高级用法]]></title>
    <url>%2F2018%2F01%2F28%2F2018-01-28%20Array.prototype.sort%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Array.prototype.sort()一、基本操作sort()方法的默认排序顺序是根据串Unicode码点。 12345678var fruit = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];fruit.sort();//[&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;]var scores = [1, 10, 21, 2];scores.sort();//[1, 10, 2, 21]//这里的10竟然在2之前，因为在Unicode指针顺序中 &apos;10&apos; 在 &apos;2&apos; 之前。 二、进阶操作（compareFunction）这时我们需要一个比较函数，来得到我们所需要的排序。如果指明了compareFunction,那么数组会按照调用该函数的返回值排序。即a和b是两个将要被比较的元素： 2.0 字符串排序123456789101112var str_arr = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];function compareStr(a, b)&#123; if(a&lt;b)&#123; return -1; &#125; if(a&gt;b)&#123; return 1; &#125; return 0;&#125;str_arr.sort(compareStr);// [&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;] 2.1 数字排序 如果compareFunction(a, b)小于0，那么a会排到b之前； 如果compareFunction(a, b)等于0 , 那么位置不变； 如果compareFunction(a, b)大于0，那么b会排到a之前；12345678910111213141516function compareNumbers(a, b)&#123; return a - b;&#125;var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b)&#123; return a - b;&#125;);console.log(numbers);//也可以写成：var numbers = [4, 2, 5, 1, 3];numbers.sort((a, b) =&gt; a - b);console.log(numbers);//输出：[1, 2, 3, 4, 5] 2.2 对象按照某个属性排序1234567891011121314151617181920212223242526var items = [ &#123; name: 'Edward', value: 21 &#125;, &#123; name: 'Sharpe', value: 37 &#125;, &#123; name: 'And', value: 45 &#125;, &#123; name: 'The', value: -12 &#125;, &#123; name: 'Magnetic' &#125;, &#123; name: 'Zeros', value: 37 &#125;];//按value值排序items.sort(function (a,b)&#123; return (a,.value - b.value)&#125;);//按name值排序items.sort(function(a, b)&#123; var nameA = a.name.toUpperCase(); var nameB = b.name.toUpperCase(); if(nameA &lt; nameB)&#123; return -1; &#125; if(nameA &gt; nameB)&#123; return 1; &#125; return 0;&#125;); 三、高级操作：使用映射改善排序compareFunction可能需要对元素做多次映射以实现排序，尤其当compareFunction较为复杂，且元素较多的时候，某些compareFunction 可能会导致很高的负载。使用map辅助排序将会是个好主意。 基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。 123456789101112131415161718// 需要被排序的数组var list = [&apos;Delta&apos;, &apos;alpha&apos;, &apos;CHARLIE&apos;, &apos;bravo&apos;];// 对需要排序的数字和位置的临时存储, mapped为临时容器var mapped = list.map(function(el, i) &#123; return &#123; index: i, value: el.toLowerCase() &#125;;&#125;)// 按照多个值排序数组mapped.sort(function(a, b) &#123; return +(a.value &gt; b.value) || +(a.value === b.value) - 1;&#125;);// 根据索引得到排序的结果var result = mapped.map(function(el)&#123; return list[el.index];&#125;);//result : [&quot;alpha&quot;, &quot;bravo&quot;, &quot;CHARLIE&quot;, &quot;Delta&quot;]]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更好用的border-box]]></title>
    <url>%2F2017%2F10%2F23%2F2017-10-23%20%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84border-box%2F</url>
    <content type="text"><![CDATA[英文原文来自CSS-tricks: Inheriting box-sizing Probably Slightly Better Best-Practice 我是把box-sizing重置为border-box的忠实粉丝，甚至于我们有一个“年度特别日子”。但是这里有一个细小的调整，而且看起来是个不错的思路。这是微调的版本：123456 html&#123; box-sizing: border-box;&#125;*, *:before, *:after&#123; box-sizing:inherit;&#125; 感谢Job Neal的继承思想，他说： This will give you the same result ,and make it easier to change the box-sizing in plugins or other components that leverage other behavior.这会给你同样的结果，而且使得在插件中或其他组件中更容易改变 box-sizing 的值，而不会影响别的表现。 进一步解释，打个比方，你有一个组件，它本被设计为默认的box-sizing 为 content-box. 你只想要使用，又不搞砸它。 12345.component&#123; /*旨在以默认的box-sizing工作*/ /*在你的页面中， 你可以把它重置为normal */ box-sizing: content-box;&#125; 但问题是，这样实际上并不重置整个组件。也许在组件内部有一个&lt;header&gt;，期望它在一个content-box中。如果这个选择器在你的CSS中，老办法就是做一个 box-sizing reset… 123*&#123; box-sizing: border-box;&#125; 然后这个header不是你想要的content-box, 而是 border-box. 就像：1234&lt;div class= "component"&gt; &lt;!-- I'm content box --&gt; &lt;header&gt; &lt;!-- I'm border-box still&gt; &lt;/header&gt;&lt;/div&gt; 为了更简单直观地做到reset，你可以使用文章顶部的继承的代码段，继承的值就会被保留。123456 html&#123; box-sizing: border-box;&#125;*, *:before, *:after&#123; box-sizing:inherit;&#125; 这并不是一个很庞大的东西。你可能已经在使用 box-sizing reset 的老办法，并且从没踩到这个坑。但是，只要我们推广一个“最佳实践”风格的片段，我们也可以慢慢把它变成最好的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-09-05-翻译了第一篇英文文档]]></title>
    <url>%2F2017%2F09%2F05%2F2017-09-05%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BF%BB%E8%AF%91MDN%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[9月4日翻译了MDN上的一篇英文文档，这是第一次尝试翻译，尝到了成就感. MDN是Web开发者的参考文档的官方网站——MDN Web 文档，有大量开发者不断贡献和更新文档和教程。 做了什么最近，在对JavaScript中this关键字的细节整理中，查阅MDN的中文文档，有些语句翻译的不错，但是还是存在部分疏漏。 仔细一番MDN的一些中文文档，少数文档的部分语句有明显的语义和内容上的毛病。 索性去看英文文档，豁然开朗，遂决定更新中文翻译文档。 在9月4日翻译了MDN上JavaScript的this关键字的英文文档：原版英文文档。 保留了部分原有翻译，纠正了大部分语义措辞漏洞，并更新了关于箭头函数的this指向。 部分语句参考了谷歌翻译，我承认谷歌翻译真的很NB。 有什么总结 要彻底弄懂this的机制，首先你要准备好面向对象的基础，理解OOP的重要概念： JavaScript面向对象编程 然后记住，this是一个变量，它是一个指针，指向一个对象。再看我的文档: this关键字 在过程中看不懂时，及时查阅相关API的文档: 箭头函数 Function.prototype.call() Function.prototype.apply() Function.prototype.bind() 写在结尾在英文文档末尾的参考链接，有一篇写得非常精彩的博客：Gentle-explanation-of-this-in-JavaScript, 温和解释JS中的this 计划在不久将来，我会挤出时间认真翻译这篇英文博客。 The end.]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-12-03 日记：村上春树的文摘]]></title>
    <url>%2F2017%2F07%2F22%2F2017-12-03%20%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[2017-12-03 日记村上春树，从29岁开始写作，从33岁开始坚持跑步。 人生哪有那么多太晚，都是懒惰和恐惧的借口罢了。 一些人不努力便得不到的东西，有些人却勿需努力便唾手可得。 在学校里，我们学到的最重要的东西，就是“最重要的东西在学校里学不到”这个真理。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React项目中的高频ES6语法]]></title>
    <url>%2F2017%2F07%2F08%2F2017-07-08%20React%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%AB%98%E9%A2%91ES6%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在学习React过程中，注意到无论是GitHub上的Demo还是React相关文档，ES6语法都有大量使用。如果不了解其中一些语法，学习曲线就会越来越陡峭。但是要系统学习ES6，又会消耗大量时间。 在这篇博客里，我把一些常用的ES6语法做一些总结，以更快更好地理解React中的概念和用法。 在线练习ES6的工具：ES6 fiddle 1. let &amp; constES6的两个新关键字，主要是引入了块级作用域，不存在变量提升，不允许重复定义等特性，减少了ES5中很容易踩到的地雷。const用来定义常量，不允许后期修改赋值。参考文档：阮一峰的博客 2.解构赋值 常规用法： 12let &#123;x&#125; = &#123;x:1, y:2&#125;let &#123; PropTypes &#125; = React 这里是对象的解构赋值，等同于let PropTypes = React.PropTypes 这里其实包含了两步： 声明变量PropTypes; 给其赋值为React.PropTypes。 所以等效于这样的写法： 12let PropTypes&#123; PropTypes &#125; = React; 可以同时写多个变量： 1let &#123; PropTypes, Component &#125; = React; 如果想定义的变量名和属性名不一样： 123//声明x1变量，赋值为1. //x是模式，不是变量也不会被赋值let &#123; x : x1 &#125; = &#123; x:1, y:2 &#125; 对象， 数组， 字符串等都有解构赋值的用法。 参考文档：解构赋值 3.对象的拓展3.1 属性的简洁表达式let x = &apos;123&apos;; //等同于：let obj = { x: x, y: &apos;33} let obj = {x, y: &apos;33&apos; }; 3.2 方法名的简写12345let User = &#123; method ()&#123; //等同于method: function()&#123;...&#125; //... &#125;&#125; 3.3属性名表达式12345 let key = 'id'; let obj = &#123; [key] : '1010', //注意方括号 ['use' + 'name' ]: 'x'&#125; 把表达式写在 [] 中， 表达式的值作为字段名称： 1234 let obj = &#123; id : '1010', usename: 'x'&#125; 注意：属性名表达式与属性名简写不能同时使用： 12345 let key = 'id'; let id = '1010'; let obj =&#123; [key]&#125; //Error! 4. ES6 Class语法使用ES6语法定义一个React组件： 123456789101112131415161718192021export class Counter extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;count: props.initialCount&#125;; this.tick = this.tick.bind(this); &#125; tick()&#123; this.setState(&#123;count: this.state.count + 1&#125;); &#125; render()&#123; return ( &lt;div onClick = &#123;this.tick&#125; &lt;/div&gt; ); &#125;&#125;Counter.propTypes = &#123; initialCount : Reart.PropTypes.number &#125;;Counter.defaultProps = &#123; initialCount: 0 &#125;; 注意： ES6的继承语法： extends关键字； 各个方法使用了方法简写，如tick(){}和render(){}, 方法之间不加 “,”； constructor 是构造函数， 可以替代getInitialState ； 构造函数内需要调用父类的构造函数：super(props) , 否则就会报错。因为子类没有自身的this 对象，需要从父类继承。 this.tick = this.tick.bind(this)中， 使用bind来绑定执行作用域（使用React.createClass是自动绑定的), 也可以在render中监听事件的位置，使用bind(this): 12345678910 &lt;div onClick= &#123;this.tick.bind(this)&#125;&gt; Clicks: &#123;this.state.count&#125; &lt;/div&gt; ``` **官方建议统一写在constructor中，这样子该方法就只需绑定一次。**6. 除了使用bind, 还可以使用箭头函数：``` jsx &lt;div onClick = &#123;() =&gt; this.tick()&#125;&gt; Clicks: &#123;this.state.count&#125; &lt;/div&gt; 箭头函数的特性：函数体内的this就是定义是的对象， 而非调用时所在的对象。箭头函数的this指向是固定的， 而普通函数是可变的。 5. 箭头函数 ES6允许使用 =&gt; 来定义函数： 12345let f = v =&gt; v+2//等同于let f = function(v)&#123; return v + 2;&#125; 如果有多个参数： 1234567891011 let f = (x ,y) =&gt; x + y;``` - 函数有多条语句， 用大括号包装：``` js let f = (x,y) =&gt; &#123; x = x + 11; y = y + 33; return x + y; &#125; 箭头函数的this指向能保持不变， 不是因为内部有绑定机制， 而是因为，箭头函数没有自己的this， 导致代码内的this就是外层代码块的this。 参考文档： 箭头函数 6. export &amp; import export用于输出模块对外的接口， import用于导入其他模块提供的功能。 12345export let client = "App" //输出变量export function mul(x, y)&#123; //输出函数 return x + y;&#125;export class Toast()&#123;&#125; //输出类 也可以统一输出： 123456//文件名： Util.jslet client = 'App';function mul (x , y)&#123; return x + y;&#125;export &#123; client, mul &#125; 那么别的组件就要这样导入它： 1import &#123;client, mul&#125; from './Util.js' 还可以打包导入： 12import * as U from './Util.js'U.client //使用U 常用的 export default 命令， 用于输出默认的方法， 变量或类： 123export default React.createClass(&#123; //...&#125;) 引入的时候就更方便， 可以随意指定名称： 1import Tab from 'tab'; 参考文档：export&amp;import 7. 对象的拓展运算符: “…”拓展运算符在Redux的示例Demo中很常见。 拓展运算符可以用来合并两个对象： 123//state = &#123; name: 'y' &#125;return &#123;...state, name: 'x', id: 101 &#125;//返回 &#123; name: 'x', id: 101 &#125; 上面代码有两个过程:1.去除state对象的所有可比案例属性， 拷贝到当前对象上； 2.如果自定义的属性在后面， 拓展运算符的同名属性会被覆盖。 这种用法等同于 Object.assign: 1234567891011121314 //assign字面意思为分配 Object.assign(&#123;&#125;, state, &#123;name: 'x', id:101&#125;)``` - 使用拓展运算符需要安装`transform-object-rest-spread`插件， 然后在babel中配置。 配置如下：``` jstest: /\.js$/,exclude: /node_modules/,loader: 'babel',query:&#123; presets: ['react', 'es2015'], plugins: ["transform-object-rest-spread"]&#125; 参考文档：ES6拓展运算符 The End.]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac安装Sass万能方法]]></title>
    <url>%2F2017%2F06%2F07%2F2017-06-07%20Mac%E5%AE%89%E8%A3%85Sass%E4%B8%87%E8%83%BD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Mac OSX系统下使用RVM修复安装Sass的错误这个万金油方法能解决大多数的gem安装问题。 如果你使用通用的gem install sass 出现错误： 12ERROR: While executing gem ... (Errno::EACCES) Permission denied - /var/lib/gems 那么这篇文章也许能解决你的问题。 这个错误说明Ruby的权限有问题，要解决这个权限问题很麻烦，不过有一个方法可以跳过这个坑： 使用RVM(Ruby Version Manager)安装一个特定版本的Ruby，再安装sass。 以下步骤都在Terminal(终端)中完成! 1. 安装Homebrew/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2. 安装gpg安装RVM之前需要gpg，先别管它是什么。 它是 mpapis public key 公钥用于验证安装包以确保安全。 如果你想知道它到底是什么，点击这里GNU-wiki百科。 brew install gnupg 3. 安装gpg密钥gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB 4. 安装RVM\curl -sSL https://get.rvm.io | bash -s stable --ruby 5. 开始使用RVM1. 查看已有Ruby版本:1rvm list 如果出现警告，如：“Warning! PATH is not properly set up…” ，这是未添加RVM环境变量，请参考解决方案.或者你直接Copy下面的指令： 1[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot; 2. 检查Ruby版本列表：不必输入下面的代码，这是输入rvm list后的结果！1234567rvm rubies=* ruby-2.2.0 [ x86_64 ]# =&gt; - current# =* - current &amp;&amp; default# * - default 3. 安装特定版本Ruby：rvm use ruby --default 检查ruby位置： which ruby 如果显示了一行目录，则表示安装成功。 ruby -v 6. 安装sassgem install sass 7. 安装完成！ 参考文章：Ruby on Mac OSX with RVM]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>指南 笔记 Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述网络原理和优化]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06%20%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？ 1.1 浏览器处理请求浏览器开启一个线程处理这个请求，对URL分析判断，如果是HTTP协议，就按Web方式处理。 1.2 浏览器处理URL调用浏览器内核中的对应方法，比如WebView中的loadUrl方法。 1.3 DNS解析通过DNS解析，获取域名的IP地址，设置UA等信息发出第二个GET请求。 1.4 建立连接进行HTTP协议回话，客户端发送报头（请求报头）； 1.5 服务器系统响应进入到Web服务器上的Web Server， 如Apache 、Tomcat 、 Node.JS 等服务器。 1.6 服务器程序处理进入部署好的后端应用，如PHP、Java、JavaScript、Python等，找到相应的请求处理。 1.7 服务器处理完成，返回数据处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，如果一致，则返回304. 1.8 浏览器开始下载HTML浏览器开始下载HTML文档(响应报头，状态码200)，同时使用缓存。 1.9 DOM树建立，加载外部文件文档树开始建立，根据标记请求所需指定MIME类型的文件（比如CSS，JS），同时设置Cookie。 1.10 页面渲染页面开始渲染DOM，JS根据DOM API操作DOM，执行事件绑定等，页面显示完成。 2. HTTP状态码 100 继续， 一般在发送post请求时， 已发送了http header之后，服务器将返回此信息，表示确认。 200 正常返回信息 201 请求成功并且服务器创建了新的资源 202 服务器已接受请求，但尚未处理 301 永久重定向 302 临时重定向 303 临时重定向，且总是使用GET请求新的URI 304 资源未修改，自从上次请求后，请求的网页未修改过。 400 请求格式错误，客户端不应当再犯同样的错误 401 请求未授权 403 禁止访问 404 找不到资源 500 服务器内部错误 502 网关错误 503 服务器暂时无法处理请求，可能是过载或者维护 3. 前端性能优化3.1 减少http请求次数CSS雪碧图，JS、CSS代码压缩，图片压缩； 网页Gzip，CDN托管，data缓存，分离图片服务器。 3.2 前端模板优化精简HTML标签，避免带宽浪费。 用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。 3.3 DOM操作用innerHTML代替DOM操作，减少DOM操作次数，优化JavaScript性能。 缓存DOM节点查找的结果，减少IO读取操作。 3.4 避免直接操作style当需要设置的样式很多时，设置className，而非直接操作style。 3.5 少用全局变量]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何应对CSRF攻击]]></title>
    <url>%2F2017%2F05%2F23%2F2017-05-23%20%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6CSRF%2F</url>
    <content type="text"><![CDATA[作为Web安全数一数二的隐患，CSRF一直让开发人员头疼。本文详细介绍了CSRF攻击的概念，危害，案例和解决方案，为网站安全优化理清思路。 一、CSRF的来龙去脉1. 什么是CSRF？CSRF（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。 2. CSRF攻击实例CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。 比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。 通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。 Mallory 可以自己发送一个请求给银行： http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory 但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。 src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ” 并且通过广告等诱使 Bob 来访问他的网站。 当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。 大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。 但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。 这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。 等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 3. CSRF攻击的对象在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。 从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。 因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。 所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。 比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。 二、防御 CSRF 的几种策略在业界目前防御 CSRF 攻击主要有三种策略： 验证 HTTP Referer 字段； 在请求地址中添加 token 并验证； 在 HTTP 头中自定义属性并验证。 1. 验证 HTTP Referer 字段1.1 什么是Referer？根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。 在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory 用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。 这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。 而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。 1.2 如何验证Referer？因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 1.3 Referer验证的优缺点优点：这种方法简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。 缺点： Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。 使用验证值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行CSRF 攻击。 如果用户为了保护隐私，而设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 2. 在请求地址中添加 token 并验证2.1 黑客总是能找到漏洞CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。 2.2 那我们就加一把钥匙要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。 但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把 token 以参数的形式加入请求了。 2.3 使用token的缺点：①. 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。 ②. 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。 为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。 3. 在 HTTP 头中自定义属性并验证3.1 把密钥放到HTTP请求头中这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。 通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。 这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 3.2 缺点：然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。 三、代码实例(java)：1. 使用Filter验证Referer12345678//从HTTP头部取得Referer值 String referer = request.getHeader("Referer"); //判断Referer是否以bank.example开头 if((refirer != null) &amp;&amp; (referer.trim().startsWith("bank.example")))&#123; vhain.doFilter(request, response); &#125;else&#123;request.getRequestDispatcher("error.jsp").forward(request,response);&#125; 以上代码先取得Referer值，然后进行判断，当其非空并以bank.example开头时，则继续请求，否则的话可能是CSRF攻击，转到error.jsp页面。 2.进一步验证请求中的token1234567891011121314151617181920HttpServletRequest req = (HttpServletRequest)request;HttpSession s = req.getSession();//从session中，得到csrftoken属性String sToken = (String)s.getAttribute("csrftoken");if(sToken == null)&#123; //产生新的token放入session中 sToken = generateToken(); s.setAttribute("csrftoken", sToken); chain.doFilter(request, response);&#125;else&#123; //从HTTP头中取得csrftoken String xhrToken = req.getHeader("csrftoken"); //从请求参数中取得csrftoken String pToken = req.getParameter("csrftoken"); if(sToken != null &amp;&amp; xhrToken != null &amp;&amp; sToken.equals(xhrToken))&#123; chain.doFilter(request, response); &#125;else&#123; request.getRequestDispatcher("error.jsp").forward(request,response); &#125;&#125; 3.在客户端对请求附加token1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function appendTOken()&#123; updateForms(); updateTags();&#125;function updateForms()&#123; //获取所有form元素 var forms = document.getElementsByTagName('form'); for (i = 0; i &lt; forms.length; i++)&#123; var url = forms[i].action; //如果这个form的action值为空，则不附加csrftoken if(url == null || url == "") continue; //动态生成input元素，加到 form 之后 var e = docement.createElement("input"); e.name = "csrftoken"; e.value = token; e.type = "hidden"; forms[i].appendChild(e); &#125;&#125;function updateTags()&#123; var all = document.getElementsByTagName('a'); var len = all.length; //遍历所有a元素 for(var i = 0; i&lt; len; i++)&#123; var e = all[i]; updateTag(e, "href" , token); &#125;&#125;function updateTag(element, attr, token)&#123; var location = element.getAttribute(attr); if(location != null &amp;&amp; location != '' '')&#123; var fragmentIndex = location.indexOf("#"); var fragment = null; if(fragmentIndex != -1)&#123; //url中含有#锚标记 fragment = location.substring(fragmentIndex); location = location.substring(0, fragmentIndex); &#125; var index = location.indexOf('?'); if(index !== -1)&#123; //url中已含有其他参数 location = location + '&amp;csrftoken=' + token; &#125;else&#123; //url中没有其他参数 location = location + '?csrftoken=' + token; &#125; if(fragment != null)&#123; location += fragment; &#125; element.setAttribute(attr, location); &#125;&#125; 在客户端html中，主要有两个地方需要加上token，一个是表单form，另一个就是a标签。上面这段代码，首先遍历所有的form, 在form最后添加一段隐藏字段，把csrftoken放入其中。然后，代码遍历所有的a标签，在其href属性中加入csrftoken参数。 注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。 4. 在 HTTP 头中自定义属性var plainXhr = dojo.xhr; // 重写 dojo.xhr 方法 dojo.xhr = function(method,args,hasBody) { // 确保 header 对象存在 args.headers = args.header || {}; tokenValue = &apos;&lt;%=request.getSession(false).getAttribute(&quot;csrftoken&quot;)%&gt;&apos;; var token = dojo.getObject(&quot;tokenValue&quot;); // 把 csrftoken 属性放到头中 args.headers[&quot;csrftoken&quot;] = (token) ? token : &quot; &quot;; return plainXhr(method,args,hasBody); }; 这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。 四、如何选择CSRF防御方法？目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。 如果网站是一个现有系统，想要在最短时间内获得一定程度的 CSRF 的保护，那么验证 Referer 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。 如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。在这种情况下，你需要小心规划你网站提供的各种服务，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。 如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议对于重要的服务，可以尽量使用 XMLHttpRequest 来访问，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。 最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。 五、总结可见，CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF 的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token 方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视 CSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低。 参考链接：IBM的技术博客]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript对象数组排序]]></title>
    <url>%2F2017%2F05%2F07%2F2017-05-07%20JavaScript%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[对象数组排序 一、按照对象的属性排序我要一个函数，传入要对比的key，就能以这个key，把对象数组进行排序。123456789101112131415161718192021222324252627282930313233//示例代码var by = function(key) &#123; return function(o, p) &#123; var a, b; if (typeof o === 'object' &amp;&amp; typeof p === 'object' &amp;&amp; o &amp;&amp; p) &#123; a = o[key]; b = p[key]; if (a === b) &#123; return 0; &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; //如果a,b所属类型不同，则按类型的英文字符排序，比如'function'排在'object'前面。 return typeof a &lt; typeof b ? -1 : 1; &#125; else &#123; throw('error'); &#125; &#125;&#125;var employees=[]employees[0]=&#123;name:"George", age:32, retiredate:"March 12, 2014"&#125;employees[1]=&#123;name:"Edward", age:17, retiredate:"June 2, 2023"&#125;employees[2]=&#123;name:"Christine", age:58, retiredate:"December 20, 2036"&#125;employees[3]=&#123;name:"Sarah", age:62, retiredate:"April 30, 2020"&#125;employees.sort(by('age'));//得到根据age属性排序的数组。//[&#123;name:"Edward", age:17, retiredate:"June 2, 2023"&#125;,//&#123;name:"George", age:32, retiredate:"March 12, 2014"&#125;,//&#123;name:"Christine", age:58, retiredate:"December 20, 2036"&#125;,//&#123;name:"Sarah", age:62, retiredate:"April 30, 2020"&#125;] 二、高级by()函数当主要的键值产生一个匹配的时候，另一个compare方法（第二个参数）将被调用以决出高下。举个例子，在比较两个对象的age属性时，age的值相等，现在我想要age相等的人，按照别的属性进行排序。于是我想增强by() ，现在我这样使用： 12//注意外层by函数内有俩个参数，第二个参数就是备用的比较函数。employees.sort(by(&apos;age&apos;,by(&apos;name&apos;))); 12345678910111213141516171819var by = function(name,minor)&#123; return function(o,p)&#123; var a,b; if(o &amp;&amp; p &amp;&amp; typeof o === &apos;object&apos; &amp;&amp; typeof p ===&apos;object&apos;)&#123; a = o[name]; b = p[name]; if(a === b)&#123; //如果前后元素相同时，用minor函数比较。 return typeof minor === &apos;function&apos; ? minor(o,p):0; &#125; if(typeof a === typeof b)&#123; return a &lt;b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1; &#125;else&#123; throw(&quot;error&quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 观察者模式的通用实现]]></title>
    <url>%2F2017%2F05%2F07%2F2017-05-07%20JavaScript%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[这篇文章主要是列举代码，关于一个经典的设计模式——观察者模式，又名发布-订阅模式的通用实现。 12345678910111213141516171819202122232425262728293031323334353637//封装观察者模式，放进一个对象中，可复用。var event = &#123; clientList:[], //订阅的消息添加进缓存列表 listen: function(key, fn)&#123; if( !this.clientList[key])&#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); &#125;, trigger: function()&#123; var key = Array.prototype.shift.call(arguments), fns = this.clientList[key]; if(!fns || fns.length === 0)&#123; return false; &#125; for(var i = 0, fn; fn = fns[i++];)&#123; fn.apply(this, arguments); &#125; &#125;， remove: function(key, fn)&#123; var fns = ClientList[key]; if( !fns )&#123; return false; &#125; if(!fn)&#123; fns &amp;&amp; fns.length = 0; &#125;else&#123; for(var len = fns.length-1; len&gt;=0; len--)&#123; var _fn = fns[len&#125;; if(_fn === fn)&#123; fns.splice(len, 1); &#125; &#125; &#125; &#125;&#125; 123456//所有对象都能动态安装 ‘观察者模式’var installEvent = function(obj)&#123; for (var i in event)&#123; obj[i] = event[i]; &#125;&#125;; 12345678910111213//测试var salesOffices = &#123;&#125;;installEvent(salesOffices); //订阅salesOffices.listen(&apos;squareMeter88&apos;, function(price)&#123; console.log(&apos;88平方米的价格=&apos;+price);&#125;);salesOffices.listen(&apos;squareMeter110&apos;,function(price)&#123; console.log(&apos;110平方米的价格=&apos;+price);&#125;); //发布salesOffices.trigger(&apos;squareMeter88&apos;,2000000); //输出：&quot;88平方米的价格=2000000&quot;salesOffices.trigger(&apos;squareMeter110&apos;,3000000); //输出：&quot;110平方米的价格=3000000&quot;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript精髓(2)]]></title>
    <url>%2F2017%2F03%2F07%2F2017-03-07%20JavaScript%E7%B2%BE%E9%AB%93(2)%2F</url>
    <content type="text"><![CDATA[这篇博客延续上一篇JavaScript精髓(1)，继续总结JavaScript语言的核心特性和思想精髓。 1. JavaScript继承的实现方式 构造继承 原型继承 实例继承 拷贝继承 原型prototype机制或者apply/call方法较简单，建议使用构造函数与原型混合方式。 1234567891011function Parent()&#123; this.name = 'wang';&#125;function Child()&#123; this.age = 28;&#125;Child.prototype = new Parent(); //通过prototype，继承Parent var demo = new Child();alert(demo.age);alert(demo.name); //得到继承的属性 2. DOM操作——添加、移除、移动、复制、创建和查找节点 创建新节点 createDocumentFragment() createElement() createTextNode() 添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() 查找 getElementsByTagName() getElementsByName() getElementById() 3. Ajax的概念和用法 AJAX的全称： Asynchronous JavaScript And XML. 异步的概念：向服务器发送请求时，不必等待结果，而可以同时做其他事情。 Ajax用法： 创建XMLHttpRequest对象，也就是创建一个异步调用对象， 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL和验证信息， 设置响应HTTP请求状态变化的函数， 发送HTTP请求， 获取异步调用返回的数据， 使用JavaScript和DOM实现局部刷新 。 4. document.write 和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以只重绘页面的一部分 5. window对象和document对象 window对象：指的是浏览器打开的窗口 document对象：Document对象的一个只读引用，它是window对象的一个属性。 6. 通用的事件侦听器函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//event工具集，参考来源：github.com/markyunmarkyun.Event = &#123; readyEvent : function(fn)&#123; if(fn==null)&#123; fn = document; &#125; var oldonload = window.onload; if(typeof window.onload != 'function')&#123; window.onload = fn; &#125;else&#123; window.onload = function()&#123; oldonolad(): fn(); &#125; &#125; &#125;, //根据能力分别使用DOM 0级 || DOM 2级 || IE方式，来绑定事件 //参数：操作元素，事件名称，事件处理函数 addEvent: function(element, type, handler)&#123; if(element.addEventListener)&#123; //事件类型，需要执行的函数，是否捕捉 element.addEventListener(type, handler, false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on' + type, function()&#123; handler.call(element); &#125;); &#125;else&#123; element['on' + type ] = handler; &#125; &#125;, //移除事件 removeEvent: function(element,type,handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125;else if(element.detachEvent)&#123; element.detachEvent('on' + type, handler); &#125;else &#123; element['on' + type] = null; &#125; &#125;, //End removeEvent //阻止事件(主要是事件冒泡， 因为IE不支持事件捕获) stopPropagation: function(ev)&#123; if(ev.stopPropagation)&#123; ev.stopPropagation(); &#125;else&#123; ev.cancelBubble = true; &#125; &#125;, //取消事件的默认行为 preventDefault : function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;, //获取事件目标 getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, //获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent: function(e)&#123; var ev = e || window.event; if(!ev)&#123; var c = this.getEvent.caller; while(c)&#123; ev = c.arguments[0]; if(ev &amp;&amp; Event == ev.constructor)&#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125; &#125; //End]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript精髓(1)]]></title>
    <url>%2F2017%2F03%2F06%2F2017-03-06%20JavaScript%E7%B2%BE%E9%AB%93(1)%2F</url>
    <content type="text"><![CDATA[这篇文章主要总结了JavaScript的基础，包括数据类型，值和易混淆的概念。 1. JavaScript的基本数据类型 Undefined Null Number Boolean String Symbol(ES2015新增) 2. JavaScript的内置对象 Object 是JS中所有对象的父对象 数据封装类对象： Object Array Boolean Number String 其他对象： Function Arguments Math Date RegExp Error 参考文档：文档链接 3. JavaScript 中有几种类型的值？ 栈(Stack)：原始(primitive)数据类型(Undefined, Null , Boolean, Number, String) 堆(Heap)：合成(complex)数据类型(Object, Array, Function) 两种类型的区别是： 存储位置不同 原始数据类型：直接存储在栈中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据，所以放入栈中存储； 引用数据类型：存储在堆(Heap)中的对象，占据空间大，大小不固定。如果存储在栈中，则会影响程序的性能。 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后，从堆中获得实体。 内存图： 4. null和undefined的区别 null 表示”没有对象”，即该处不应该有值，典型用法： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 12Object.getPrototypeOf(Object.prototype)//null undefined 表示“缺少值”，即此处应该有值，但是没有被赋值，典型用法： 变量被声明了，但是没有赋值，默认等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性默认值为undefined。 函数没有返回值时，默认返回undefined。1234567891011var i;i //undefinedfunction f(x)&#123;console.log(x)&#125;f() //undefinedvar o = new Object();o.p //undefinedvar x = f();x //undefinde 123456//二者的测试typeof undefined == "undefined" //truetypeof null == "object" //trueNumber(undefined) //NaNNumber(null) //0 注意： 在验证null时，一定要使用 ===,因为 == 无法分辨null和undefined： 12null == undefined //truenull === undefined //false 打个比方： null Q: 有张三这个人吗？ A: 有！ Q: 张三有房子吗？ A: 没有！ undefined Q: 有张三这个人吗？ A: 有！ Q: 张三多少岁了？ A: 不知道（没有被告诉） 5. JavaScript的this this是一个指针 this的指向： 函数直接调用时：this指向函数的直接调用者； 通过new关键字，this指向new产生的新对象； 通过call/apply/bind的绑定，this指向绑定对象。 在JS事件中，this指向触发这个事件的对象，但是在IE中，attachEvent中的this总是指向全局对象Window。 6.JavaScript的作用域链全局函数无法查看局部函数的内部细节，但局部函数刻意查看上层函数的细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。 7. JavaScript原型和原型链 原型：每个对象都会在其内部初始化一个属性，就是prototype(原型)。换句话说，所有对象都是以对象为模板创建实例的。 原型链：当我们访问一个对象的属性A时，如果属性A不存在于该对象中，那么我们会去prototype里查找A，而这个prototype又会有自己的prototype，于是就如此查找下去，就形成了一个原型链。这个原型链表示的是一种连带关系。 关系：instance.constructor.prototype = instance.__proto__ 特点：JS对象是通过引用传递的（对比于值传递），我们创建的每一个新对象实体中，并没有一份属于自己的原型副本。当我们修改了原型，与之相关的对象也会继承这些变化。 终点：原型链的顶端，是Object.prototype, 它的__proto__指向null. 8.JavaScript的闭包 概念闭包是一种手段，一个有权访问另一个函数作用域中变量的函数，记住闭包也是函数。 创建闭包最常见的方式，就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量(相当于一个对外的接口)。 作用利用闭包可以突破作用域链，将函数内部的变量方法传递到外部。 特性 1. 函数内再嵌套函数 2. 内部函数可以引用外层的参数和变量 3. 参数和变量不会被垃圾回收机制回收 9. new操作符到底干了什么？ 创建一个空对象，将this指针指向该对象，同时继承该函数的原型。 属性和方法被添加到this指向的对象中。 新创建的对象由this所应用，并且最后隐式的返回this 。 123var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); 10. JavaScript开发的基本规范 不要在同一行声明多个变量； 请使用 ===/!==来比较布尔值或者数值； 使用对象字面量替代 new Array这种形式； 不要使用全局函数； Switch语句必须带有default分支； 函数应该有返回值； For循环必须使用大括号； if语句必须使用大括号； for-in循环中的变量应该使用let 关键字明确限定作用域，避免命名空间污染。 To be continue。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记：JavaScript事件处理]]></title>
    <url>%2F2017%2F01%2F27%2F2017-01-27%20JavaScript%20Events%20%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JavaScript — 事件处理：笔记摘要 参考书籍：《Modern JavaScript》(Larry Ullman 著);《JavaScript高级程序设计》 (Nicholas C Zakas著). 一、 事件处理：1.嵌入式事件处理器（强烈不建议）:1234/*比如*/ &lt;form action= &quot;#&quot; method = &quot;post&quot; onsubmit = &quot;validataForm();&quot;&gt; /*或者*/ &lt;a href = &quot;somepage.html&quot; onclick = &quot;doSomething();&quot;&gt;Some link&lt;/a&gt; 2.传统事件处理方法(不建议)：123456/* 以下传统方法不建议使用 */window.onload = init; //易用，可靠，属性名必须全小写。/* 或者 */window.onload = function()&#123; //匿名函数方法//Do whatever.&#125; 原因： 1. 一次只能指定一个时间处理器； 2. 较后的函数会覆盖较前的； 12document.getElementById('theForm').onsubmit = progress;document.getElementById('theForm').onsubmit = calculate; // 呃!有问题. 12345//缓解方法document.getElementById('theForm').onsubmit = function()&#123; progress(); //当然你也可以这样解决，但是这样的代码很丑陋。 calculate();&#125; 3.W3C事件处理(建议) 接受三个参数：事件类型，事件发生时调用的函数，表示事件阶段的布尔值。123456789101112131415161718 addEventListener(&apos;load&apos;, init , false); //可以为相同元素添加多个事件监听器；` removeEventListener()(&apos;load&apos;, process , false);``` 2. IE&lt;9的事件处理(事件名称前缀多了&quot;on&quot;) 1. attachEvent(&apos;onload&apos; , init); 2. detachEvent(&apos;onload&apos; , init);3. 创建一个事件分配器 ``` javascript function addEvent( obj , type , fn)&#123; if(obj &amp;&amp; objEventListener)&#123; //W3c obj.addEventListener(type, fn , false); &#125;else if(obj &amp;&amp; obj.attachEvent)&#123; //IE&lt;9 obj.attachEvent(&quot;on&quot; + type, fn); &#125; &#125; 4. 范例：创建一个实用程序库12345678910111213141516171819202122232425262728293031323334353637383940414243444546//所有函数都定义在全局对象U中，避免多个新函数污染全局命名空间。//新对象U （Utility的缩写）var U = &#123; //定义$()方法 $: function(id)&#123; 'use strict'; if (typeof id == 'string')&#123; return document.getElementById(id); &#125; &#125;,//定义setText 方法，两个参数：要更新的元素id和消息本身 setText: function(id, message)&#123; 'use strict'; if( (typeof id == 'string') &amp;&amp; (typeof message == 'string'))&#123; var output = this.$(id); if (!output) &#123;return false&#125;; //获取id的元素失败 if(output.textContext !== undefined)&#123; output.textContext = message; &#125;else&#123; output.innerText = message; &#125; return true; &#125; //End of main IF. &#125;, //End of setText() function. //封装一个‘添加事件监听器’ 函数 addEvent: function( obj , type , fn)&#123; 'use strict'; if(obj &amp;&amp; obj.removeEventListener)&#123; obj.addEventListener(type, fn, false); &#125;else if (obj &amp;&amp; obj.detachEvent)&#123; obj.attachEvent('on' + type , fn); &#125; &#125;, //End of addEvent() function //封装一个‘移除事件监听器’函数 removeEvent: function( obj , type , fn)&#123; 'use strict'; if(obj &amp;&amp; obj.removeEventListener)&#123; obj.removeEventListener(type, fn, false); &#125;else if (obj &amp;&amp; obj.detachEvent)&#123; obj.detachEvent('on' + type , fn); &#125; &#125; //End of removeEvent() function &#125;; //End of U declaration. 二、事件类型事件类型分为4类： 输入设备 键盘 浏览器 表单 1.输入设备事件1. 输入按钮事件：1. click 事件； 2. dblclick 事件； 3. contextmenu 事件(罕见)； 2. 输入移动事件：1. mouseout 鼠标移出; 2. mouseover 鼠标移过; 3. mousemove 鼠标移动（持续监视鼠标，消耗性能）; 3. 键盘事件：1. keydown (按下); 2. keyup (释放); 3. keypress (按键，前二者组合); 4. 浏览器事件：1. load (加载完成); 2. unload (卸载); 3. resize (改变浏览器窗口大小); 4. scroll (滚动事件); 5. copy; 6. cut; 7. paste; 5. 表单事件： – reset：表单重置(点击重置html按钮)时触发，用户很少有重置表单的需要；若要使用此事件，可以添加监视： 123addEvent(document.getElementById(&apos;theForm&apos;), &apos;reset&apos; , function()&#123; return confirm(&quot;您确定想要重置表单吗？&quot;); &#125;); – select: 文本输入域和文本区域的文本内容被选中时； – change: 元素值变化时； – focus: 单击或Tab键到文本输入域时； – blur: 光标或选择项的移动时； 三、事件可访问性(Accessibility)1. 配对事件(Pairing events): 使用同一个函数处理相同元素的类似事件。 2. 可访问性(Accessibility):在移动设备和其他非标准浏览器上，对于不使用输入设备的浏览器，mouseover和mouseout事件毫无意义，因为它们永远不会发生。例如：1234&lt;a href = &quot;somepage.html&quot; id = &quot;link&quot; &gt; Some Text &lt;/a&gt;&lt;script&gt;addEvent(document.getElementById(&apos;link&apos;), &apos;mouseover&apos;,handleLinkMouseOver);&lt;/script&gt; 上述代码中，事件只能通过鼠标触发。但是还是有缓解方法。如果浏览器仅由键盘控制，那么它是可以监视focus事件的(Tab键)。因此，增强可访问性的事件处理方法是创建两个事件监听器：123456&lt;a href = &quot;somepage.html&quot; id = &quot;link&quot;&gt;some Text&lt;/a&gt;&lt;script&gt;//配对事件addEvent(document.getElementById(&apos;link&apos;), &apos;mouseover&apos;, doSomething);addEvent(document.getElementById(&apos;link&apos;), &apos;focus&apos;, doSomething);&lt;/script&gt; 3.事件和渐进增强 渐进增强的真正原则： 使用JavaScript( 和CSS )改进基本功能，使得用户不管使用何种设备，都不会被抛弃(忽略)。 只有在开发者有意识的忽略一些用户时，JavaScript才是有必要的。 但是在很多情况下，JavaScript是没有必要的：比如表单的提交应该在有无JavaScript的情况下都能进行(在服务端都能验证)。 将渐进增强的思想应用到事件处理中，向已经有默认事件行为的元素添加事件时必须小心。例如：表单提交时，表单的数据发送给服务器端脚本。为表单添加提交事件，为其添加其他功能，在逻辑上是毫无意义的。 四、高级事件处理 引用事件 事件属性 检查按键 阻止默认事件行为 事件的两个阶段：捕捉和冒泡 委派事件处理 1.引用事件 当事件处理程序用于多个元素上的相同事件（或者相同元素上的不同事件）时，事件处理程序就必须考虑其灵活性。 12345function someEventHandler(e)&#123; //e就是引用事件，代表发生的事件 if(typeof e == "undefined")&#123; e = window.event; //考虑IE8及更早 &#125;&#125;; 2.事件属性 事件对象通过各种属性提供信息，但是不同浏览器支持的属性有所差异。(这里不深究，后续补充。) 3.检查按键 当键盘事件触发时，可以通过事件对象确定按下的具体键。这个问题有点复杂，在这里稍微带过。 示例代码：以一致的方式获得字符： 123456var charCode = e.which || e.keyCode; //IE中不支持which// 或者更准确的var charCode = (typeof e.which == &apos;number&apos;)?e.which : e.keyCode;//获得与字符代码相对应的实际字符:String.fromCharCode(charcode); 4.阻止事件默认行为 一些与基本浏览器相关的JS事件： 单击链接、提交表单等。在事件处理器存在时，事件发生会调用对应的函数，在函数运行之后，浏览器仍然继续进行它通常应该进行的事件处理。例如：提交表单时，提交事件处理器可能执行客户端验证。如果发生了错误，应该阻止表单提交到服务器端脚本，让客户有机会改正错误。方法：从事件处理器中返回false。 123456789101112131415161718// 仅在传统方法注册事件处理器时可靠工作，不建议。function handleForm()&#123; //Do whatever. if(errors)&#123; return false; &#125;else&#123; return true; &#125;&#125;//以下是跨浏览器的兼容方法，调用事件对象的preventDefault();if(typeof e == &apos;undefined&apos;) &#123;e = window.event;&#125;if(e.preventDefault)&#123; e.preventDefault();&#125;else &#123; e.returnValue = false;&#125;return false; //额外的预防措施。 使用PreventDefault()或设置returnValue的另一个好处就是：可以在函数开始时执行，使后续的函数代码仍然运行。 5.事件的两个阶段：捕捉和冒泡示例：12345678910&lt;div&gt; &lt;h1&gt;This is a title&lt;/h1&gt; &lt;p&gt;This is a paragraph. &lt;a href = &quot;#&quot; id = &quot;link&quot;&gt;This is a link.&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; // U.$()方法与jquery获取DOM节点方法一致，只是在前文定义了一个新对象U. addEvent(U.$(&apos;link&apos;), &apos;mouseover&apos; , doSomething);&lt;/script&gt; **在上述代码中，包含关系：a&lt; p&lt; div&lt; html&lt; Document&lt; window。当鼠标悬停在链接之上，mouseover事件实际上经历了几个步骤，在两个不同的阶段到达和离开目标（链接）。 注意，事件传播一共有三个阶段：1.捕获阶段； 2.调用事件处理程序； 3.冒泡阶段。 1.捕捉阶段： 当你使用事件捕获时，由外向内，父级元素先触发，子级元素后触发；即div先触发，p后触发。 2.事件处理： 调用查找到的事件处理程序； 3.冒泡阶段： 事件冒泡当你使用事件冒泡时，由内向外，子级元素先触发，父级元素后触发；即p先触发，div后触发。 W3C模型 在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。 程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。 1ele.addEventListener(&apos;click&apos;,doSomething2,true) true=捕获 false=冒泡 传统绑定事件方式 在一个支持W3C DOM的浏览器中，像这样一般的绑定事件方式，是采用的事件冒泡方式。 1ele.onclick = doSomething2 IE浏览器 如上面所说，IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。 1ele.attachEvent(&quot;onclick&quot;, doSomething2); 附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。 事件的传播是可以阻止的：• 在W3C中，使用stopPropagation（）方法• 在IE下设置cancelBubble = true； 在捕获的过程中stopPropagation（）;后，后面的冒泡过程也不会发生了 阻止事件的默认行为 例如click后的跳转:• 在W3C中，使用preventDefault（）方法；• 在IE下设置window.event.returnValue = false; 终于写完了，花了一天时间总结了”事件处理”，文末部分参考了网友的经验。 九月份看的《JS高级程序设计》，当时云里雾里，后来敲了很多代码半懂不懂，现在写完这篇博客才算明白过来。 在写的时候翻阅《JS权威指南》，里面有更深入的细节，有一部分事件类型已经被HTML5标准化。 后续再补充。^_^]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
