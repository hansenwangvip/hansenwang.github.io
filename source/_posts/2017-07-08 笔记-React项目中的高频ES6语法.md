---
title: React项目中的高频ES6语法
date: 2017-07-08 16:06:44
categories: 技术
keywords: 前端 React
---


---
在学习React过程中，注意到无论是GitHub上的Demo还是React相关文档，ES6语法都有大量使用。如果不了解其中一些语法，学习曲线就会越来越陡峭。但是要系统学习ES6，又会消耗大量时间。

在这篇博客里，我把一些常用的ES6语法做一些总结，以更快更好地理解React中的概念和用法。

<!--more-->

在线练习ES6的工具：[ES6 fiddle](http://www.es6fiddle.net)

--- 

## 1. let & const
ES6的两个新关键字，主要是引入了块级作用域，不存在变量提升，不允许重复定义等特性，减少了ES5中很容易踩到的地雷。const用来定义常量，不允许后期修改赋值。
参考文档：[阮一峰的博客](http://es6.ruanyifeng.com/#docs/let)

## 2.解构赋值

 - 常规用法：

``` js
	let {x} = {x:1, y:2}
	let { PropTypes } = React
```
	
这里是对象的解构赋值，等同于`let PropTypes = React.PropTypes`
> 这里其实包含了两步：
> 
> 1. 声明变量PropTypes;
> 2. 给其赋值为React.PropTypes。

所以等效于这样的写法：

	```
	    let PropTypes
	    { PropTypes } = React;
	```

 - 可以同时写多个变量：
 
``` js
    let { PropTypes, Component } = React;
```

 - 如果想定义的变量名和属性名不一样：
 
``` js
    //声明x1变量，赋值为1. 
    //x是模式，不是变量也不会被赋值
    let { x : x1 } = { x:1, y:2 }
```
  

 - **对象， 数组， 字符串等都有解构赋值的用法。**
 
 - 参考文档：[解构赋值](http://es6.ruanyifeng.com/#docs/destructuring)

## 3.对象的拓展
### 3.1 属性的简洁表达式

    let x = '123';
    //等同于：let obj = { x: x, y: '33}
    let obj = {x, y: '33' };
   
### 3.2 方法名的简写
```
    let User = {
	    method (){   //等同于method: function(){...}
		    //...
	    }
    }
```

### 3.3属性名表达式

``` js
    let key = 'id';
    let obj = {
		    [key] : '1010', //注意方括号
		    ['use' + 'name' ]: 'x'
	}
```

把表达式写在 [] 中， 表达式的值作为字段名称：

``` js
    let obj = {
	    id : '1010',
	    usename: 'x'
	}
```
**注意**：属性名表达式与属性名简写不能同时使用：

``` js
    let key = 'id';
    let id = '1010';
    let obj ={
	    [key]
	}  //Error!
```

## 4. ES6 Class语法
使用ES6语法定义一个React组件：

``` jsx
export class Counter extends React.Component{
	constructor(props){
		super(props);
		this.state = {count: props.initialCount};
		this.tick = this.tick.bind(this);
	}

	tick(){
		this.setState({count: this.state.count + 1});
	}
	render(){
			return (
				<div onClick = {this.tick}
				</div>
			);
	}
}

Counter.propTypes = { initialCount : Reart.PropTypes.number };

Counter.defaultProps = { initialCount: 0 };
```

**注意**：

1. ES6的继承语法： extends关键字；
2. 各个方法使用了方法简写，如tick(){}和render(){}, 方法之间不加 “,”；
3. `constructor` 是构造函数， 可以替代getInitialState ； 
4. 构造函数内需要调用父类的构造函数：`super(props)` , 否则就会报错。因为子类没有自身的`this` 对象，需要从父类继承。
5. `this.tick = this.tick.bind(this)`中， 使用**bind**来绑定执行作用域（使用React.createClass是自动绑定的), 也可以在render中监听事件的位置，使用bind(this):
	
	``` jsx
    <div onClick= {this.tick.bind(this)}>
	      Clicks: {this.state.count}
    </div>
	```    
**官方建议统一写在constructor中，这样子该方法就只需绑定一次。**
6. 除了使用bind, 还可以使用箭头函数：
``` jsx
	<div onClick = {() => this.tick()}>
		Clicks: {this.state.count}
	</div>
```
> 箭头函数的特性：
> 函数体内的this就是定义是的对象， 而非调用时所在的对象。箭头函数的this指向是固定的， 而普通函数是可变的。

## 5. 箭头函数 

 - ES6允许使用 `=>` 来定义函数：

	``` js
	let f = v => v+2
	//等同于
	let f = function(v){
		return v + 2;
	}	
	```

 - 如果有多个参数：

	``` js
		let f = (x ,y) => x + y;
	``` 

 - 函数有多条语句， 用大括号包装：

	``` js
		let f = (x,y) => {
			x = x + 11;
			y = y + 33;
			return x + y;
		}	
	```

> 箭头函数的this指向能保持不变， 不是因为内部有绑定机制， 而是因为，**箭头函数没有自己的this， 导致代码内的this就是外层代码块的this。**

 - 参考文档： [箭头函数](#)

## 6. export & import
 - export用于输出模块对外的接口， import用于导入其他模块提供的功能。 
 
``` js
export let client = "App"	//输出变量
export function mul(x, y){	//输出函数
	return x + y;
}
export class Toast(){}		//输出类	
```

 - 也可以统一输出：
 
``` js
	//文件名： Util.js
	let client = 'App';
	function mul (x , y){
		return x + y;
	}
	export { client, mul }	
```

- 那么别的组件就要这样导入它：

``` js
	import {client, mul} from './Util.js'
```

- 还可以打包导入：
``` js
	import * as U from './Util.js'
	U.client //使用U
```

- 常用的 `export default` 命令， 用于输出默认的方法， 变量或类：
``` js
	export default React.createClass({
		//...
	})	
```
- 引入的时候就更方便， 可以随意指定名称：
``` js
	import Tab from 'tab'; 
```
- 参考文档：[export&import](#)

## 7. 对象的拓展运算符: “...”
拓展运算符在Redux的示例Demo中很常见。

- 拓展运算符可以用来合并两个对象：
``` js
	//state = { name: 'y' }
	return {...state, name: 'x', id: 101 }
	//返回 { name: 'x', id: 101 }
```
	> 上面代码有两个过程:1.去除state对象的所有可比案例属性， 拷贝到当前对象上；
					  2.如果自定义的属性在后面， 拓展运算符的同名属性会被覆盖。

- 这种用法等同于 Object.assign:

``` js
	//assign字面意思为分配
	Object.assign({}, state, {name: 'x', id:101})
``` 

- 使用拓展运算符需要安装`transform-object-rest-spread`插件， 然后在babel中配置。 配置如下：

``` js
test: /\.js$/,
exclude: /node_modules/,
loader: 'babel',
query:{
    presets: ['react', 'es2015'],
    plugins: ["transform-object-rest-spread"]
}
```

- 参考文档：[ES6拓展运算符](#)

---
The End.
<!--stackedit_data:
eyJoaXN0b3J5IjpbNjU1OTY4MjM0XX0=
-->