---

title: 前端-JS的深拷贝
date: 2018-05-22
categories: 技术
tags: [技术]
keywords: 技术

---

# 为什么要深拷贝？
JS的值分为引用类型和原始类型，当我们在开发过程中需要拷贝一个对象时，希望生成一份完全独立的副本，这时候我们就需要深拷贝。

# 最高效的深拷贝？

## 不要重复造轮子

如果你的项目中依赖了第三方类库，并且它们提供了克隆方法，请使用它们的方法，不要重复造轮子！

比如：
-   lodash -  [`cloneDeep`](https://lodash.com/docs#cloneDeep); 可以通过  [lodash.clonedeep](https://www.npmjs.com/package/lodash.clonedeep) 独立引用。
-   AngularJS -  [`angular.copy`](https://docs.angularjs.org/api/ng/function/angular.copy)
-   jQuery -  [`jQuery.extend(true, { }, oldObject)`](https://api.jquery.com/jquery.extend/#jQuery-extend-deep-target-object1-objectN);  注意：`.clone()` 方法只复制了DOM对象。

## 简单的递归

```JS
function deepCopy(src) {
    var ret = {}
    for (var k in src) {
        ret[k] = typeof src[k] ==='object' ? deepCopy(src[k]) : src[k]
    }
    return ret
}
```

## 高速但是会丢数据：JSON.parse/stringify

注意：这个方法很快，使用会丢失原型链，得到的是一个全新的对象。并且它只能复制简单的值，如果对象中有Date、函数等复杂类型的值，这个方法会丢失数据！

> If you do not use `Date`s, functions, `undefined`, `Infinity`, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays or other complex types within your object, you can use JSON.parse/stringify to clone your object.

```js
function deepClone(a){
	return JSON.parse(JSON.stringify(a));
}
```


## 容易产生错觉的浅拷贝： `Object.assign()`

Object.assign是ES6的新语法，对象的第一层是深拷贝，但是下面的全是浅拷贝！它只复制了属性名，却没有复制属性值。如果值是一个引用类型，那它只复制了引用值，即浅拷贝。

> 引用MDN的解释：For deep cloning, we need to use other alternatives because `Object.assign()` copies property values. If the source value is a reference to an object, it only copies that reference value.

```js
function fakeDeepClone(target){
	return Object.assign({}, target)
}
```

## ES6还有一个浅拷贝: 扩展运算符

[Spread_syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

<!--stackedit_data:
eyJoaXN0b3J5IjpbMzMyMjkzNTddfQ==
-->