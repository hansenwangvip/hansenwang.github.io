---
title: 翻译-JavaScript的执行上下文和调用堆栈
date: 2019-10-05
categories: 翻译
tags: 翻译
keywords: 翻译

---

> 译者介绍：这篇文章用简洁的文字解释了JS的执行上下文和调用堆栈的概念，并通过让读者换位思考的方式，理解JS引擎在运行代码时的行为。对于进阶的JS程序员来说，执行上下文和调用堆栈是理解JS代码运行原理的关键。  
> 原文链接：[JavaScript: What Is The Execution Context? What Is The Call Stack?](valentinog.com/blog/context/)  
> 原文更新日期：2019.5.14  
> 译文更新日期：2019.10.5  
 
 <!--more-->
 
术语对照表：  
  
英文|译文  
-----|-----  
Execution Context | 执行上下文  
Scope | 作用域  
Closure | 闭包  
Call Stack | 调用堆栈  



正文：

---

![image](https://user-images.githubusercontent.com/18462980/66252280-3e68bd00-e78c-11e9-82b4-facf99258546.png)  
  
# JavaScript：什么是执行上下文？什么是调用堆栈？  
  
  
**JavaScript中的执行上下文**是什么？  
  
我打赌您不知道这个答案。一门编程语言的最基础的组件是什么？  
  
> 更新：这里有一片改进并扩展的博客文章：[JavaScript引擎：它们是如何工作的？从调用堆栈到Promise，您需要知道的一切](https://www.valentinog.com/blog/engines/)  
  
变量和函数对吗？每个人都可以学会这些基础的概念。但是，除了这些基础之外还有什么？  
  
在成为中级（甚至是高级）JavaScript开发者之前，您应该掌握哪些**JavaScript的核心**？  
  
答案有许多：作用域，闭包，回调函数，原型等等。  
  
但是在深入理解这些概念之前，您至少应该知道**JavaScript引擎如何工作？**  
  
这篇文章，我们将介绍每个JavaScript引擎都具备的两个基本部分：**执行上下文和调用堆栈**  
  
（不要害怕，比您想象的要简单）  
  
准备好了吗？  
  
序号 | 目录  
----- | -----  
1 | 您将会学到哪些东西  
2 | JavaScript如何运行您的代码？  
3 | JavaScript引擎  
4 | 它是怎么工作的？  
5 | 全局内存  
6 | 调用堆栈是什么？  
7 | 局部执行上下文  
8 | 总结  
  
## 1. 您将会学到哪些东西  
  
通过这篇文章，您将学到：  
  
- JavaScript引擎如何工作  
- JavaScript的执行上下文  
- 调用堆栈是什么  
- 全局执行上下文和局部执行上下文之间的区别  
  
## 2. JavaScript如何运行您的代码？  
  
如果您是一个高级开发者，您可能已经知道了答案。  
如果您是新手，那我们一起来探索。  
  
现在，看看下面的代码：  
  
```js  
var num = 2;  
  
function pow(num){  
    return num * num  
}  
```  
  
好了吗？  
  
看起来不难嘛！  
  
现在告诉我：**您认为浏览器会以什么顺序来执行这段代码？**  
  
换句话说，如果**您**是浏览器，您会如何解读这段代码？  
  
这看起来好像很简单。  
  
大多数人认为：“嗯，浏览器先执行函数`pow`，返回了结果，然后把2赋值给num。”  
  
您想知道我的学生们的回答吗？  
  
> _从上到下_  
> _浏览器会从函数pow开始，计算num*num_  
> _JS 引擎会一行一行地运行代码（好像是这样）_  
  
我倒是希望那样。  
  
几年前我也说过同样的回答。  
  
在接下来的几个部分，您将了解这些**貌似简单的几行代码**背后的机制。  
  
  
## 3. JavaScript 引擎  
  
要理解JavaScript如何运行，我们首先要了解第一个可怕的东西：**执行上下文**。  
  
JavaScript中的执行上下文是什么？  
  
**每次在浏览器（或者Node）中运行JavaScript时，引擎都会执行一系列步骤。**  
  
其中一步就是：**创建全局执行上下文**。  
  
等等，瓦伦蒂诺(作者名字)，**引擎是啥？**  
  
简单来说，JavaScript引擎就是运行JavaScript代码的“引擎”。  
  
如今有两个著名的JavaScript引擎：[Google V8](https://developers.google.com/v8/) 和 [SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey)  
  
V8是Google开源的 JavaScript 引擎，被用于Chrome浏览器和 Node.js 中。  
  
SpiderMonkey 是Mozilla的JavaScript引擎， 被用于Firefox浏览器。  
  
到目前为止，我们已经有了JavaScript引擎和一个执行上下文。  
  
现在是时候了解它们是如何协同工作的了。  
  
## 它是如何运作的？  
  
每次您运行JavaScript代码时，引擎就创建了一个全局执行上下文。  
  
执行上下文是描述JavaScript代码运行环境的漂亮词汇。  
  
> 译者注：Execution Context被译作执行上下文，“上下文”一词对于一些初学者来说可能有些抽象，我们可以理解为 **供代码执行的一个环境，一个容器**。  
  
很难想象这些抽象的东西，我理解您。  
  
现在，把 全局作用域 想象成一个盒子：  
![image](https://user-images.githubusercontent.com/18462980/66252642-6e19c400-e790-11e9-94f4-381c56327ba8.png)  
  
  
我们在来看之前的代码：  
  
```javascript  
var num = 2;  
  
function pow(num) {  
    return num * num;  
}  
```  
  
引擎会如何解读这些代码？  
  
这是一个简化的版本：  
  
**引擎**：第一行。这里有一个变量！酷！我们把它存到全局内存(Global Memory)里吧。  
**引擎**：第三行。我看到了一个函数声明。酷！我们把它也存进全局内存吧！  
**引擎**：看起来我完事了。  
  
如果我再问您一次：浏览器怎么“看”这些代码，您会怎么回答？  
  
是的，它是自上而下的，但是...  
  
您能看到，引擎并没有执行函数`pow`！  
  
它是一个**函数声明**，不是函数调用。  
  
上面的代码将转换存储在**全局内存**中的一些值：一个函数声明和一个变量。  
  
**全局内存？**  
  
老哥，我已经被执行上下文搞得晕头转向了，现在您又扔一个“全局内存”给我？  
  
是的。  
  
让我们来看看全局内存是啥玩意。  
  
  
## 全局内存  
  
**JS引擎也有一个全局内存。**  
  
全局内存包含了全局变量和函数声明，供以后使用。  
  
如果您读过 Kyle Simpson的 “**Scope和Closures**”，您会发现“全局内存”和“全局作用域”的概念重叠。  
  
实际上，它们是同一样东西。  
  
我扯这么远，是有原因的。  
  
这些都是很难理解的概念。  
  
但是您现在不必担心。  
  
我想要您理解两个重要的点。  
  
当JS引擎运行您的代码时，它创建了：  
  
- 一个全局执行上下文  
- 一个全局内存（也叫做全局作用域或者全局变量环境）  
  
现在清楚了吗？  
  
如果我是您的话，我现在会这么做：  
  
- 写一些JavaScript代码  
- 把自己当作引擎，一步一步解析代码  
- 在执行过程中，用图形表示**全局执行上下文和全局内存**  
  
您可以在纸上或者原型工具上试试。  
  
对于我的小例子，图片看起来是这样的：  
  
![image](https://user-images.githubusercontent.com/18462980/66252961-12e9d080-e794-11e9-836d-c9515ca3727f.png)  
  
在接下来的部分，我们将看到另一个可怕的东西：**调用堆栈**。  
  
  
## 调用堆栈是什么？  
  
您是否清楚**执行上下文**、**全局内存**和**Javascript引擎**是如何配合的？  
  
如果没有，请花时间回看上一部分。  
  
我们将要介绍拼图中的另一块：**调用堆栈**。  
  
让我们首先重温一下，当JS引擎运行您的代码时，它创建了：  
- 一个全局执行上下文  
- 一个全局内存  
  
除此之外，在我们的例子中没有发生什么：  
  
```javascript  
var num = 2;  
  
function pow(num) {  
    return num * num;  
}  
```  
  
这段代码就是单纯的值分配。  
  
让我们走远一点。  
  
如果我调用函数，会发生什么？  
  
```javascript  
var num = 2;  
function pow(num) {  
    return num * num;  
}  
  
var res = pow(num);  
```  
  
有趣的问题。  
  
在JavaScript中**调用函数**的行为，**会使引擎请求帮助**。  
  
这个帮助来自JavaScript引擎的一个朋友： **调用堆栈**。  
  
这听起来可能不太明显，但是JavaScript引擎需要跟踪正在发生的事情。  
  
它依赖于调用堆栈。  
  
那在JavaScript中，调用堆栈到底是什么？  
  
**调用堆栈类似于程序当前执行的日志。**  
  
实际上，它是一个数据结构：一个[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)。  
  
不出意外，它有两个方法：加入数据（英语：push）和移除数据（英语：pop）。  
  
加入数据就是**把某些东西加入堆栈**。  
  
也就是说，当您在JavaScript中执行一个函数，引擎会把函数加入调用堆栈中。  
  
每个函数都会被加入到调用堆栈中。  
  
第一个加入的是`main()`(或者`global()`)，执行JavaScript程序的主线程。  
  
现在，上面的图片将会是这样：  
  
![image](https://user-images.githubusercontent.com/18462980/66253168-69580e80-e796-11e9-8f75-ff6e8d4e5f1c.png)  
  
  
当一个函数执行完毕，它将会从调用堆栈中移除。  
  
然后我们的调用堆栈就会这样：  
  
![image](https://user-images.githubusercontent.com/18462980/66253178-b6d47b80-e796-11e9-8e96-225062b6ebf7.png)  
  
那么现在呢？您已经做好准备去掌握每一个JavaScript概念了。  
  
我没开玩笑。  
  
但是我们还没结束！进入下一节！  
  
  
## 局部执行上下文  
  
到目前为止一切似乎都很清楚。  
  
我们是不是遗漏了什么？  
  
我们知道，**JavaScript引擎创建了一个全局执行上下文和一个全局内存**。  
  
然后，当您在代码中调用一个函数时：  
  
- JS引擎求助  
- JS引擎的朋友 调用堆栈 过来帮忙  
- 调用堆栈追踪代码中正在调用的函数  
  
当您在执行一个函数时，还会发生另外一件事情。  
  
首先，函数出现在了全局执行上下文。  
  
然后，另一个 迷您版的上下文出现在函数身边：  
  
那个小盒子叫做：**局部执行上下文**。  
  
啥？？  
  
如果您注意到了，在前一幅图中，全局内存中出现了一个新变量: `var res`。  
  
变量`res`最初的值为`undefined`。  
  
  
然后，一旦`pow`**出现在全局执行上下文中，函数执行，res获取到函数的返回值**。  
  
在执行过程中，一个局部的执行上下文创建了，用于存储局部变量。  
  
多么强大的概念。  
  
  
![image](https://user-images.githubusercontent.com/18462980/66253275-29922680-e798-11e9-8384-91222c4fe9c8.png)  
  
请记住这些概念。  
  
理解全局和本地执行上下文是掌握[作用域和闭包](https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed)的关键。  
  
## 总结  
  
您能相信这四行代码背后是什么吗？  
  
Javascript引擎创建执行上下文、全局内存和调用堆栈。  
  
但是，一旦您调用了一个函数，引擎就会创建一个本地执行上下文，其中包含一个本地内存。  
  
在这篇文章的最后，您应该能够理解当您运行一些Javascript代码时发生了什么。  
  
Javascript的内部机制常常被新手视为神秘的东西，也常常被忽视。  
  
然而，它们是掌握高级Javascript概念的关键。  
  
如果您学习了执行上下文、全局内存和调用堆栈，那么**作用域、闭包、回调和其他东西**就会很容易了。  
  
特别是，理解调用堆栈是至关重要的。  
  
一旦您将它可视化，所有的Javascript将开始清晰: 您将最终理解为什么Javascript是异步的，为什么我们确实需要回调。  
  
您知道4行Javascript代码背后是什么吗？  
  
现在您知道了。  
  
感谢阅读，敬请关注！
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI3NDUwNjg2OF19
-->